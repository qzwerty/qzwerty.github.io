---
layout:     post
title:      iReplayer: In-situ and Identical Record-and-Replay for Multithreaded Applications
subtitle:   PLDI'18
date:       2020-09-14
author:     qzwerty
header-img: img/blog-bj-1.png
catalog: true
tags:
    - RR security




---

## iReplayer: In-situ and Identical Record-and-Replay for Multithreaded Applications

pRnR定期创建快照以保存VM执行的中间状态。每个快照都是VM状态的一个时间点副本，包括重新生成多线程程序的执行非常具有挑战性，因为存在许多内在和外部的非确定性因素。现有RnR系统实现价格不能进步的性能开销,但没有目标现场设置,回放记录过程发生在相同的过程。而且，大多数现有的工作不能实现相同的重放，这可能会影响一些错误的重现。

本文介绍了iReplayer，它的目的是在原始进程中(在“原位”设置下)相同地回放多线程程序。iReplayer的新颖的就地和相同的回放使得它更有可能重现错误，并允许它直接使用调试机制(例如观察点)来帮助故障诊断。目前，iReplayer平均只带来3%的性能开销，这使得它可以在生产环境中始终启用。iReplayer支持一系列的可能性,提出了三个例子:两个自动工具检测栈溢出和use-after-free bug,和一个互动结合GDB调试工具。

### 1 Introduction

多线程程序包含内在的不确定性因素,可能影响不同执行的进度和结果。因此，重新生成多线程程序是非常具有挑战性的。记录-重放(RnR)系统记录原始执行的非确定性事件，例如同步的顺序和某些系统调用的结果，然后在重新执行期间重现这些事件[62]。甚至一些RnR系统记录的顺序内存访问[13],或利用离线分析推断出内部的内存访问的顺序执行(5,37,38,46)。然而,现有RnR系统有两个共同的缺点,除了他们提到的第7节中描述的问题。

首先,他们不支持现场回放,通常在不同的进程中重新生成执行。它们或许可以实现更好的诊断能力，因为它们可以访问整个执行[6]中的所有信息。然而，有几个问题。(1)如同experts观察到的那样[40，71], 离线回放需要与记录过程相同的运行时环境,这将大大限制其使用,因为由于业务和隐私问题，普通用户可能不希望将第三方库或敏感输入/日志分享给程序员。(2)不能用来帮助在线恢复[71]。

其次,大多数现有RnR系统(RR(55,60)除外)不能复现与记录完全相同执行,因为他们不能保证相同的系统状态,如进程/线程id和文件描述符(5，16，33-35,37,46,52,54,62,66,72),系统调用的相同结果(例如,时间)(36、37、48),或不同内存布局(5 16，33-35,37,46,52,54,62,66,72]。因此，某些类型的bug是不可能重现的:(1)可能无法可靠地重现与内存布局相关的错误。图1显示了这样的一个例子,一个事故发生在对缓冲区溢出产生的空指针进行释放时。如果一个整数(不是指针)在溢出发生后立刻被分配,一个不同的内存布局,可能在重新执行时将这个崩溃隐藏;(2)错误依赖于系统的状态,比如线程id, 文件描述符,或内存地址,可能不会重现,在回放时不一样在最初的执行。然而，许多实际的系统被设计为显式地利用系统状态。例如，Hoard根据线程ID[10]的哈希值给每个线程分配堆，一些哈希表使用对象地址作为它们的键[41]。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1giy3ivpqgsj30jc07q74w.jpg)

介绍iReplayer,全新的系统保证in-situ和一致性地回放多线程程序,它具有和现有RnR系统的以下区别。

**首先，iReplayer设计了一种原地回放技术，它总是在同一进程中回放最后一阶段的执行。**原地回放使回放相同的系统状态变得更容易，并且更有可能重现错误。这in-situ回放不同于现有在线回放(64、71、72),他们实际上回放过程发生在与记录阶段不同的进程。目前，iReplayer只在默认情况下回放lastepoch执行。但是，它特别适合于识别bug。根据最近的研究[6,29,64]，大多数bug的错误传播距离非常短，这表明可能在故障发生前不久找到了根本原因。Replaying-last-epoch也避免花费大量等待问题出现的时间。

**其次，iReplayer的目标是完全相同的重新执行，严格保留所有系统状态、系统调用结果、同步的顺序和结果，以及原始执行的相同内存分配/释放，甚至对于不活跃的应用程序也是如此。**在与原始执行相同的进程中重新执行有助于保存系统状态，比如进程id。此外，iReplayer特别地处理系统调用，延迟线程的回收，以维护每个线程的内存映射和id状态，并使用一个自定义内存分配器来管理应用程序堆的多次执行，如2.2节所述。基于我们的评估，iReplayer可以完全复制所有不包含隐式同步(即，不使用pthread api)的评估过的应用程序(甚至是不活跃的应用程序)。

**第三,iReplayer记录开销平均3%,这是相当低的部署。**iReplayer利用多种方法来减少日志记录开销:(1)利用in-situ设置,以避免记录读/写的内容;(2)受已有工作启发[45,52]，通过处理重放阶段的竞态条件，避免了对内存访问的记录;(3)灵感来自Dthreads[48]，采用了一种新颖的堆设计，避免了记录内存分配;(4)它也设计一种新颖的数据结构有效地记录同步的本地顺序,同时还确保相同的回放;(5) iReplayer设计了一个间接的级别用于记录同步事件，类似于现有的工作[4]。这就是为什么iReplayer比过去的相关技术有更少的开销的主要原因，如Respec[44]。更多细节见3.2节。

**iReplayer的相同和in-situ重新执行使多种可能性成为可能，本文展示了三种工具。**这些工具可以用于分段部署或金丝雀部署，特别是在推出新特性时。此外，iReplayer的原位和相同的重放提供了独特的可能性:(1)它启用了on-site工具，可以自动诊断程序失败的根本原因，如内存错误、分割错误、中止和断言。例如，在出现错误时，我们可以执行二进制分析来查明错误地址，然后在这些地址上安装监视点来现场识别根本原因，而无需人工参与。相比之下,离线RnR不能进行on-site分析,通常需要额外的人工支持。(2)它使基于证据的方法能够防止程序失败，如内存错误或死锁。例如，可以扩展iReplayer来延迟内存释放，以防止发现use-afterfree，或者强制另一种锁顺序以避免死锁。现有离线RnRs是不可能执行在线修复。

总体而言，本文的贡献如下:

多线程程序的第一现场记录回放技术:iReplayer提出第一现场记录重放系统，重放发生在与原始记录执行相同的进程,提供了新的可能性。

同样的重放技术:iReplayer支持多线程程序的相同的重播,不需要自定义同步。相同的回放可以帮助重现错误，并简化自动工具的开发。

减少开销的实用实现技术:iReplayer进行了多种设计选择来减少记录开销:提出了一种新的数据结构，支持相同的回放，低记录开销，并支持回放过程中轻松检查发散;它设计了一个新的堆来避免记录内存分配。

**一个实用的系统结合了低记录开销和方便**:iReplayer是一个软件解决方案与微不足道的记录开销，平均只有3%。iReplayer是一个drop-in库，完全运行在用户空间中,并且不需要不存在硬件、定制的操作系统或程序的修改。

多个有前途的应用程序:为了演示iReplayer的有用性，本文开发了两个工具来检测堆重写和use-after-free错误，以及一个交互式调试工具(连接到GDB)。

本文的其余部分组织如下。第2节概述了我们的方法，包括实现多线程支持的挑战。然后，第3节介绍详细的实现，第4节讨论在iReplayer上构建的几个应用程序。第5节提出实验结果，并在第6节讨论限制。最后，第7节回顾了相关工作，第8节作了总结。

### 2 Overview

本节提供iReplayer的概述，以及支持原地和相同回放多线程应用程序的主要挑战。

#### 2.1 Overview of Execution

iReplayer整个执行分为多个部分,根据不可撤销的系统调用(定义在2.2节),异常退出,或者用户定义标准。例如，用户可以使用日志记录的大小作为标准，以减少内存/磁盘的消耗。

图2展示了iReplayer的概况，其中显示了两个线程的执行。在一个阶段的开始,iReplayer需要程序的状态的快照,如内存和打开文件的位置,这样程序可以回滚到这一点(3.1节)。最初的执行期间,iReplayer记录同步的顺序(3.2节),并另外处理系统调用(2.2.3节)。当一个线程遇到不可撤销系统调用——改变了状态,但不能安全地回滚——或到达记录阶段的用户定义标准,它将被视为协调员线程,将协调与其他线程暂停执行(3.3节)。所有线程已达到静止状态后,协调器线程决定是否继续执行,或者进行重放，取决于用户指令或tool-specic evidence(见第4节)。如果需要重演,协调器通知所有其他线程回滚(3.4节)和重新执行程序(3.5节)。否则,通知所有的其他线程继续到下一个阶段。

#### 2.2 Challenges for In-situ and Identical Replay

iReplayer的主要挑战是确保同步、内存访问、系统调用和内存布局在in-situ设置下的相同重放。

##### 2.2.1 确保相同的同步

我们记录原始执行期间的同步顺序，然后在重新执行时重播这个顺序[62]。然而,最大的挑战是实现有效的记录,这是进一步在3.2节描述。由于一些应用程序依赖于同步函数的结果，如try locks或barrier wait, iReplayer还记录同步的返回值，并在重放中返回它们。

目前，iReplayer不支持特殊同步的程序，程序使用自己的同步方法而不是显式的pthreads api[74])，这在第6节中进一步讨论。

##### 2.2.2 确保相同的内存访问顺序

在多线程应用程序中存在两种类型的内存访问，包括线程私有访问和共享访问。线程私有访问的顺序由指令的顺序决定，对于相同的重播不需要特殊的处理。当显式同步被相同地复制时，如果它们被显式同步正确地保护，共享访问将是相同的。因此,困难在于确保相同的重播竞态条件。

**处理竞争条件:**iReplayer不记录存在竞争的访问，因为这太昂贵了。相反,它处理竞争条件在回放阶段,在程序不公开竞态条件的常见情况下,避免了大量的记录开销。在回放期间，它将检查与记录的事件之间的差异。如果重播的行为与原始执行完全相同，即系统调用和同步的顺序相同，那么竞争条件要么没有公开，要么被成功复制。否则，iReplayer立即启动另一次重播，并利用多次重播来搜索匹配的调度。当重播的事件与记录的事件相匹配时，iReplayer假定重播与原始执行相同，并将停止搜索。

#### 2.2.3 确保相同的系统调用

现有的RnR系统会记录系统调用的结果，并在回放过程中重播相同的状态[62,67]。例如，gettimeofday的记录结果将在重播阶段返回。然而，目前没有任何工作以in-situ为目标。为了确保相同的系统调用，in-situ带来了一些额外的挑战。例如,如果一些文件相关系统调用序列包括打开和关闭后重播,或许不可能确保相同的文件描述符,因为它现在可能被占据。munmap系统调用可能会出现类似的结果。iReplayer把系统调用分为五个类别,类似于DoubleTake[49]。