---
layout:     post
title:      InSight A Framework for Application Diagnosis using Virtual Machine Record and Replay
subtitle:   ()
date:       2020-07-18
author:     qzwerty
header-img: img/blog-bj-1.png
catalog: true
tags:
    - RR security


---

## InSight A Framework for Application Diagnosis using Virtual Machine Record and Replay

非确定性执行对软件系统(用户级应用程序和操作系统)的诊断(调试、分析和执行状态挖掘)提出了几个挑战。虽然存在使用修改过的库、库包装器、二进制工具和内存隐藏技术的几种技术，但我们的目标是利用虚拟化所支持的记录和回放技术来提供通用诊断框架。我们的解决方案的动机是执行的可重现性需求、不修改应用程序源代码、没有或最小的二进制插装开销——所有这些都是现有技术很少提供的。我们的诊断框架InSight由两个阶段组成——第一个阶段记录应用程序和虚拟机的执行状态，第二个阶段回放和分析记录的执行。我们在基于Linux内核的虚拟机(KVM)平台上实现了InSight，作为贡献，我们实现了KVM的高效记录和重放基板以及使用该基板的诊断框架。本文介绍了这些组件的设计和实现，并开发了一套诊断工具——潜在死锁检测、锁使用情况分析和功能分析。我们也提出实验来证明正确性，洞察力的低开销和相关的诊断结果。

**Keywords**

Virtual machine record and replay, application diagnosis

### 1 INTRODUCTION

诊断是软件系统(用户空间应用程序和操作系统)正确和有效工作的一项重要活动。不同变量的诊断包括调试、分析和执行状态挖掘，通常用于此目的。诊断服务有不同程度的好处(就诊断所需的信息而言)，也有不同程度的费用。

像gdb[1]和gprof[2]这样的工具需要使用调试信息选项来编译二进制文件以便获取状态单步执行。其他工具，如ftrace[3]、systemtap[4]和PinPlay[5]，需要启用脚本来提取所需事件的信息。像valgrind[6]这样的诊断工具使用重量级的插装来提取信息，并且由于在线诊断而导致较高的开销。此外，像OProfile[7]这样的分析工具利用硬件计数器对运行时执行状态进行采样，并且需要与感兴趣的应用程序一起执行。每个工具都提供了诊断功能的子集，并且需要不同程度的执行开销和用户干预(在设置诊断环境方面)。诊断越“精细”，成本(就执行时间而言)就越高。例如，考虑一个写保护内存区域，用于跟踪进程/线程的所有写操作。由于每次内存写入都被捕获，应用程序很少能以本机速度执行。对于粗糙的诊断设置，不能检索所有所需的信息，例如，分析工具只提供执行状态、调用图等的定量分析。另一个诊断需求是跟踪多个实体(进程/线程)，以捕获它们之间交互的时间顺序，例如，进程间调用等。这些需求通常通过使用所有相关实体的细粒度捕获执行来满足，这可能会增加执行开销。

此外，当问题的来源未知时，通常需要诊断工具，例如，bug是不确定的，死锁依赖于线程的交叉离开顺序等。使用分析和调试器的运行时诊断无法捕获未发生的条件。一个有用的需求是能够记录系统的执行状态，并定期或在感兴趣的事件发生时，使用各种诊断工具来处理它，以发现所需的信息。

作为这项工作的一部分，我们的目标是提供一个诊断应用程序的框架，其目标如下:不确定性执行状态的再现性、最小化执行开销和检测需求。我们的诊断服务框架InSight利用了虚拟化环境中可用的记录和回放功能。该框架为诊断提供了通用且快速可配置的服务，同时最大限度地减少了对应用程序执行的干扰。虚拟机记录功能允许以确定的方式重播对虚拟机(客户操作系统和应用程序)的非确定性状态的记录。对于不同类型的诊断需求，可以多次重播执行。在Crosscut[8]中使用了类似的方法，其中多阶段重放用于提取集中时间间隔和选定进程的执行状态。提取的状态可以在诊断工具valgrind或perl执行环境中重播。

作为诊断框架的一部分，我们使来宾操作系统与主机(hypervisor)协调，以交换关于事件的状态信息。修改后的guest的一个优点是，要诊断的应用程序不需要担心与状态收集相关的基本检测，只需少量配置就可以快速使用诊断服务。虽然客户检测需要提供事件状态信息(例如，进程映射的指令指针、符号表等)，但事件本身的生成依赖于现有的操作系统工具。

提供此服务的一个重要要求是最小化干扰——低开销的状态收集和可靠地重现执行状态以进行诊断。我们利用带有插装的记录和回放功能来满足上述需求，并通过InSight，我们的诊断即服务框架，做出以下贡献:

* 为基于linux的内核虚拟机(KVM)平台设计并实现一个优化的记录和回放基板。我们的基板支持网络流量重放和始终基于dma的磁盘访问。

* 测量记录和重放系统以获得可重现的诊断状态。

* 实证验证诊断框架的正确性和开销。

* 提供一组诊断工具、锁争用分析、潜在死锁检测和函数级分析，以演示InSight的适用性和可用性。

### 2 THE INSIGHT ARCHITECTURE AND IMPLEMENTATION

InSight由各种组件组成，以实现可重现性和可忽略的开销/失真的执行跟踪收集。在本节中，我们将描述InSight的各个组件以及这些组件如何协同工作。本节还描述了InSight组件的实现。

#### 2.1 架构

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gh12e0myudj30s80e8ju3.jpg)

如图1所示，InSight由两个主要组件组成:(i)支持记录和回放的hypervisor，和(ii)诊断子系统。与hypervisor协作，虚拟机充当执行应用程序的平台，并便于提取执行事件跟踪。诊断子系统使用存储在事件数据库中的事件跟踪来回答有关执行的有趣查询。

在InSight框架中，来宾vm以记录模式(应用程序执行阶段)执行。在这一阶段，不收集诊断信息，只记录关于外部(非确定性)事件的信息，这是重放所必需的。在稍后的时间点，可以重新播放虚拟机(及其应用程序)的记录状态，以进行诊断——诊断阶段。在回放期间，所有外部事件都被正确地注入，以使应用程序和操作系统执行相同的执行。此外，事件探测将事件的发生通知InSight系统。我们实现的事件探测集将在第3节中描述。

InSight框架使用一个仪表化的客户虚拟机，即，客户虚拟机存储有关事件的状态信息并向管理程序公开状态信息。例如，在一个锁获取事件上，虚拟机会显示获得锁的线程。由于InSight和probes都知道用于信息交换的预定义结构，所以InSight收集事件probes准备的信息，并将它们存储在events DB中用于诊断。

所有状态信息都存储在特定于事件的预定义结构中，供hypervisor使用。在诊断期间，hypervisor逐步捕获所有感兴趣的事件的状态信息，并将它们存储在事件数据库中。诊断工具进一步使用事件数据库来分析应用程序执行。

InSight架构允许并行执行多个诊断阶段，从而能够对长时间的测试场景进行有效的分析。例如，数据竞争分析可以与潜在的死锁分析并行进行。

#### 2.2 Record and replay implementation

InSight的两个主要组件中的第一个是虚拟机记录和重放基板。记录和回放特性使虚拟机的执行具有再现性。InSight的虚拟机记录和回放旨在实现忠实的回放和最小化日志开销。记录和回放系统遵循非确定性外部事件记录的标准实现技术[9,10]。作为InSight的一部分，我们设计并实现了网络事件的记录和回放以及基于dma的磁盘IO。根据我们的文献调查，我们还没有遇到同时考虑这两个因素的记录文献和重放文献。

基于dma的IO和网络事件的高效记录和重放实现对于IO绑定的应用程序(磁盘和网络)的可靠执行非常重要。

在Linux内核虚拟机(KVM)上实现了InSight记录和回放。基片记录非确定性的外部事件，如从外部设备读取的数据(键盘、鼠标、磁盘)，注入到虚拟机的外部中断，以及由外部设备复制到VM内存中的数据(DMA读取、网络包接收)。重播是通过在记录阶段事件发生的同一实例中将这些事件重新注入客户虚拟机来实现的。作为事件注入引用的时间戳与外部事件一起记录。我们使用<分支计数器、指令指针、ECX值>元组作为时间戳，它标识在[9]中讨论的执行中的任何点。

接下来，我们将简要描述我们对记录和回放技术的主要贡献(作为洞察的一部分)。

##### 2.2.1 Deterministic replay of network events

为了使具有网络连接的虚拟机能够独立记录和重放，我们记录了传入数据包的状态。（独立指重放时不需要有网络连接）重放网络数据包到达的挑战是来宾使用的数据包是不确定的。在轮询模式下操作的客户设备驱动程序可以在任何时间使用接收到的包。用一个完整位表示是否在接收缓冲区中接收到包(当前)。

为了记录包的状态，我们修改了QEMU[11]中的Intel eepro100网络设备仿真。仿真是基于[12]中提供的设备规范实现的。

在回放期间，为了确保与记录期间同时读取数据包，我们将(接收到的数据包的)完整位的设置与定义良好的来宾事件关联起来。例如，QEMU会延迟设置接收到的包的完整位，直到引发一个带有时间戳的事件(中断)或来宾VM事件(基于端口/mmio的IO事件)到达后再设置。如果在定义良好的事件发生时设置完整位，而不是在接收包时设置完整位，那么我们可以确保来宾读取接收到的包与记录的事件相关联。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gh134uo99qj30sg0iu76o.jpg)

图2中的示例显示了在客户执行期间数据包pkt 1、pkt 2、pkt 3和pkt 4的到达。但是这些数据包的完整位直到一个定义良好的事件e才被设置。这种技术在定义良好的事件和接收到的数据包集之间创建一个happened -before关系。在我们的例子中，来宾VM只能在它接收到事件E之后才能看到包(因此这些包是间接绑定到事件E的)。在记录过程，每当一个定义良好的事件到达时，会将设备接收到的未设置完整位的包记录在一个日志文件中，并设置相应的完整位。在图2中，缓冲包1-4在事件E期间被记录，并且E的日志记录将有缓冲包的列表pkt 1..4。在重播期间，在注入一个定义良好的事件之前，我们检查是否有任何随事件记录的包，如果有，我们复制这些包接收缓冲区和设置他们相应的完整位，以此来传递这些包。在图2中，当来宾执行到达重播时间i时，hypervisor应该注入事件E。在注入事件E之前，hypervisor找到pkt 1..4用事件E记录并复制记录的包内容放进接收缓冲区，并在恢复客户执行之前设置完整位。保存/恢复包内容、设置完整位和记录/注入定义良好的事件这三种操作都是来自客户机的透视图的原子操作——客户机看不到中间状态。

##### 2.2.2 Replay of Direct Memory Access(DMA)-based disk I/O

实现磁盘访问的有效记录和回放有两个主要挑战，(i)为回放维护一致的磁盘状态，和(ii)支持不同的访问方法，基于端口或基于dma的IO。为了解决第一个问题，我们使用QEMU提供的基于写时复制(COW)的磁盘格式。使用写时复制磁盘映像进行记录，客户机生成的写操作被重定向到临时磁盘文件(保留初始磁盘映像的状态)。为了重放，我们使用相同的“写即拷”磁盘映像，该映像具有磁盘的初始状态，并再次将写操作重定向到一个临时磁盘文件。在记录和重播中，从临时磁盘文件提供写后读取。该方法允许初始磁盘状态保持不变(在记录和回放期间)，并且可以用于任意数量的回放执行。

为了执行IO密集型应用程序，我们提供基于dma的磁盘访问(而不是基于端口的IO)，并记录和回放相同的数据。我们最初的实验表明，基于端口的IO是相当慢的比较基于DMA的IO，不能处理甚至中等IO密集的应用。基于dma的磁盘访问是异步的。即，磁盘访问由来宾启动，并通过磁盘驱动器的中断通知完成。在记录和回放场景中，DMA完成时间——从DMA开始到DMA完成中断到达的持续时间——在记录和回放阶段应该是相同的。如果没有保留基于dma的IO的完成时间，重播将是不忠实的。

