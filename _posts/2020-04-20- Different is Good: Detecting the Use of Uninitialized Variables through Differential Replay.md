---
layout:     post
title:      Different is Good: Detecting the Use of Uninitialized Variables through Differential Replay
subtitle:   ccs19
date:       2020-04-20
author:     qzwerty
header-img: img/blog-bj-1.png
catalog: true
tags:
    - RR security




---

## Different is Good: Detecting the Use of Uninitialized Variables through Differential Replay

使用未初始化的变量是一个常见的问题。它可能导致内核信息泄露，从而破坏广泛部署的安全防御，即，内核地址空间布局随机化（KASLR）。尽管最近一个名为Bochspwn Reloaded的系统报告了Windows内核中的多个内存泄露，但如何有效检测这个问题仍然是一个很大的问题。

在本文中我们提出了一种新的技术，即，differential replay，可以有效的探测未初始化变量的使用情况。具体地说，它在多个实例中记录和重放程序的执行。一个实例使用普通的内存，另一个实例更改（或poison，貌似是内存泄漏相关的？）从栈和堆中分配的变量的值。然后，比较程序状态，以查找未初始化变量的引用。主要思想是，如果一个变量被正确初始化，它将覆盖poison的值，在两个运行的实例中程序状态应该是一样的。在检测到差异后，我们的系统利用符号污点分析进一步确定变量的位置。这有助于我们确定根本的原因，实施真正的exploit。我们实现了一个TimePlayer的原型。将它应用于Windows7和windows10内核（x86/x64）之后，成功识别出了34个新问题和85个补丁问题（其中一些未公开）。在34个新问题中，有17个被微软认定为0日漏洞。

1 INTRODUCTION

在诸如Windows和Linux这样的现代操作系统中，变量的值通常在显式初始化之前是不确定的。这些未初始化的变量可能会危及系统的安全性，特别是当它们跨越不同的权限域时。例如，如果变量保存内核对象的地址并流入用户空间，内核地址就会被泄露到不可信的用户程序。这破坏了KASLR机制。一个真实的例子是2015年7月发现的一个内核漏洞，它利用堆中的一个内核数据泄露（CVE-2015-2433）来获得win32k.sys的随机基址，然后利用它来利用其他的漏洞来升级自己的特权。之前的研究表明，未初始化的数据的使用是C和C++语言中最严重的漏洞之一，在2000年到2015年的所有内存泄露CVE（388）中占1/3以上（147）。更糟糕的是，最近的一项研究演示了利用未初始化的变量自动执行特权升级攻击的方法。

不幸的是，检测这样的问题并不容易，因为它通常不会导致崩溃或其他可感知的影响。一个可能的方法是使用动态污点分析来跟踪系统中变量的流。具体来说，它将栈和堆中新分配的内存区域设置为taint source，并传播污染标记。如果污点内存区域被写入新值（正在初始化），则将删除标记。如果程序引用了污点内存区域，说明使用了未初始化的变量。

这个方法虽然可行，但在实际应用中存在较大的局限性。具体地说，在整个系统软件堆栈（包括内核、系统组件和用户程序）中利用动态污点分析将不可避免地引入高性能开销。因此，Bochspwn Reloaded，这个最先进的工具主要关注内核内存公开bug，只传播特定指令的污染标记，以减少性能开销。然而，它引入了漏报。正如论文中所述，“这意味着每次通过寄存器间接复制内存中的数据时，污染信息在此过程中被丢弃，可能产生不希望出现的漏报。”

**本方案。**在本文中，我们提出了一种利用两个关键技术来检测由于使用未初始化变量而导致的内核信息泄露的方法。具体来说，我们利用了第一个关键技术，即，差分重放，来快速发现未初始化的变量的使用。然后我们使用第二个关键技术，即符号污点分析，用于确定分配未初始化变量的位置。

首先，我们的系统采用差分重放来记录内核和用户程序的执行情况。然后，我们将重放两个不同的实例，分别使用栈和堆的普通值和poisoned值。我们比较程序状态的差异，如，内存操作指令的地址和内容。由于poisoned变量将在初始化期间被覆盖，如果新分配的变量已被正确初始化，那么这两个实例应该完全相同。换句话说，程序状态的差异可能表明使用了未初始化的变量。

之后，我们的系统将进行符号污点分析，来确定变量被分配的确切位置。为此，我们的系统对记录的执行跟踪实施了离线污点分析。他将新变量设置为污点源，然后给该变量分配一个符号值。然后它传播符号污点标记，并沿着跟踪生成符号表达式。这个过程直到到达使用未初始化变量的指令后才会停止。最后，我们得到了该变量的符号表达式。通过使用这样的表达式，分析人员能够确定是否分配了变量的位置。为了加快这个过程，会按需堆符号表达式进行打包。

注意最近的一个系统kMVX使用了多变量执行（MVE）的概念来检测Linux中的内核信息泄露。MVE的思想类似于执行多个实例的差分重放。但是，它需要内核源码，因此不能应用于未开源Windows内核。相反，TimePlayer是一个非侵入性的系统，可以面向闭源系统工作。它的有效性已经通过了Windows7和Windows10内核中的新漏洞得到了证明。

**原型和评估。**我们实现了一个名为TimePlayer的原型系统。基于PANDA系统实现了差分重放，符号污点分析利用了SinyVEX库。为了评估它的有效性，我们在7个月的时间内将它应用于Windows7和Windows10内核。它从内核空间到用户空间成功检测到34个信息泄露的问题。其中微软安全响应公司确认了17个CVE。在撰写本文时剩下的17个还在评估潜在安全后果。

为了进一步评估我们的系统检测已知漏洞的能力，我们在系统中使用了Google Project Zero的公共测试用例（exploits）。我们已经在Windows7和Windows10中发现了85个漏洞。其中，有55个公开的CVE漏洞。但是，还有30个没有CVE编号的。我们手动分析确认它们确实是内核信息泄漏。

为了评估TimePlayer的差分重放的效率，我们实现了一个参考系统，完全利用污点分析来跟踪未初始化的变量。我们运行了相同的测试用例，并记录了检测到内核信息泄露的时间。结果表明，我们的系统在大约47小时内可以检测到34个新问题，而参考系统在大约66小时内只能检测到7个新问题。这证明了TimePlayer检测新漏洞的效率。

综上所述，本文的贡献如下：

* 我们提出了一种称为差分重放的技术，可以快速检测未初始化变量在Windows内核中的使用情况，而不需要源代码。
* 我们提出使用符号污点分析来定位未初始化变量的来源，并提供两种优化来加速这一过程。
* 我们已经实现了一个原型，并在7个月的时间内将其应用于Win7和Win10。报告了34个问题，其中17个已经被确认为零日漏洞。

我们发布了测试用例，程序跟踪记录，重放过程中的不同程序状态差异导致发现的新漏洞，在[链接](https://github.com/AlibabaOrionSecurityLab/TimePlayer)中。

本文的其余部分的结构如下：我们在第2节中介绍了背景和一个激励性的示例，在第3节中说明了我们系统的总体设计。我们将分别在第4节和第5节中说明系统的两个关键技术。然后，我们在第6节中给出评估结果，并在第7节中讨论我们工作的潜在局限性。最后，我们在第8节对相关工作进行了描述，并在第9节对我们的工作进行了总结。

### 2 背景和实例

#### 2.1 背景

**PANDA的确定性RR。**PANDA是一个开源动态分析平台，具有很多独特的功能，是分析复杂软件的强大平台。我们的系统利用了PANDA提供的RR功能来记录执行，然后使用内核堆栈中的poisoned内存值来重放程序。

为了通过比较两个重放实例的差异来检测未初始化的变量，记录和重放应该是确定的。PANDA以下面的方法解决了这个挑战。当开始记录的时候，它首先获取机器状态的快照，包括寄存器值和内存值。然后记录三种非确定性事件，包括输入事件（通过IN指令），硬件中断和DMA事件。当任何事件发生时，它将记录跟踪点的信息，其中包括程序计数器（PC值），记录开始以来的指令计数和x86循环指令中使用的ECX计数器值。这些信息足以区分每一个跟踪点。*（ECX 是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。）*

在重放期间，PANDA首先根据保存的快照恢复系统状态。然后，当当前跟踪点与记录跟踪点相同时，执行程序，将不确定性事件输入系统。这样的话，就能够确保在与记录进程相同的（虚拟）时间轴中生成不确定性事件。图1显示了这个过程。注意，多线程不会引起任何问题，因为多线程程序的执行轨迹将被确定性重放。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ge3oy11janj31020qawk9.jpg)

值得一提的是，在重放期间，没有执行任何设备模拟代码，重放不能实时接收新输入。PANDA的目的是分析记录的跟踪。这种设计选择使得RR的实现非常简单和干净。

**污点分析。**污点分析是一种应用广泛的数据流分析技术。基本思想是将某些类型的数据标记为污点源（source），将污点标记分配给它们，然后再程序执行时传播这些标记。当程序到达某些位置，即污点sink时，可以通过检查标记来执行规则。我们的系统使用符号污点分析来识别分配未初始化数据的位置。

#### 2.2 案例

在介绍详细的系统设计实现之前，我们首先使用系统检测到的一个新的内核信息泄漏漏洞（CVE-2018-8408）来展示现有工具的局限性。图2显示了该漏洞的代码片段，该漏洞从堆栈中泄漏内核数据。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ge3pvfojr5j30zl0u0n43.jpg)

**内核信息泄露漏洞。**这个漏洞存在于Win7和Win10内核中。系统调用NtDeviceIoControlFile可以用一个FIONBIO标志设置UDP套接字，实现非阻塞I/O模式。这个例程由用户模式函数WSARecvFrom调用。如果在没有任何传入UDP数据的情况下调用该函数，那么将为变量IoStatusBlock.Status分配一个特殊的状态值0xc00000a3 (STATUS_DEVICE_NOT_READY)。在函数FltpFastIoDeviceControl返回值非0的情况下，内核堆栈上的四个未初始化字节将被泄露给一个名为IoStatusBlock.Information的用户空间变量。

**为什么它不能被Bochspwn检测到。**Bochspwn是检测内核内存泄露错误的最先进工具。其核心思想是使用双重污点（double-tainting）技术来跟踪未初始化变量的数据流。

但是，由于污点分析能力的限制，改工具无法检测到此漏洞。例如，为了降低性能开销，该工具只将内存指令的污点标记传播到内存操作。换句话说，当污点数据流入寄存器时，标记将丢失（正是该漏洞的情况）。另外，正如作者所述，只有在满足一定条件，即，当esi处于内核模式而edi处于用户模式时，才会进行bug探测模式。但是，在这种情况下，未初始化内核栈的内存首先被传递到ecx寄存器，然后泄露给用户空间内存（图2第3行0x83e24501 mov dword ptr [eax + 4], ecx）。这个会导致该工具产生错误的污点状态，漏掉这个漏洞。

**为什么我们的系统能探测这个漏洞。**我们的系统应用差分重放技术来快速发现未初始化数据的使用，不需要在运行时动态跟踪数据流。下面我们描述我们的工具是如何使用高级描述来检测这个漏洞的。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ge40wcex3xj30u20u0wlq.jpg)

首先，我们利用系统的第一项关键技术，用poisoned的内核栈重放记录的执行。在此过程中，我们会发现程序状态的差异，如图3所示。具体来说，在两个实例种内存位置0x021afad8的值是不同的。这意味着使用了来自内核栈的未初始化数据。此外，我们通过使用TimePlayer附带的函数符号和栈信息来进行栈跟踪。栈跟踪有助于手动分析漏洞。

之后，我们利用系统的第二个关键技术来定位未初始化变量的来源，即，这个数据在哪里。为此，我们从最后n个（我们在实验中使用了500个）内核栈帧开始进行符号污点分析，通过对执行跟踪应用污点分析来查找泄漏的内核数据的来源，如图5所示。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ge41ip5heij31220je79f.jpg)

从图5中我们可以看出，内核帧是在指令0x83c6f838 (sub esp, eax)处分配的。我们的系统将内存区域([0x9e12fc44:0x9e12fcbf])设置为污染源source，并使用符号污点标记<BV992 TAINT_s_0_992>，（BV992表示标记是长度为992位的位向量，每个位表示一个受污染的内存位）。然后，随着程序的执行，如果污点标记被初始化（第二行），或者传播到其他内存区域（第三行）、其他寄存器（第四行），污点标记会被从内存区域移除。最后，探测到未初始化变量的使用（第五行）。在本例中，污点标记首先传播到ecx寄存器（第四行），然后通过指令地址0x83e24501 (nt!IopXxxControlFile+418)（第五行）处的ecx寄存器泄漏到用户空间内存([0x21afad8:0x21afadb])。注意，符号污点标记<BV32 TAINT_s_0_992[256:287]>表示内核堆栈的一部分已经泄漏（从比特位256到287，一共4字节）。

**Takeaway。**与传统的动态污点跟踪技术不同，TimePlayer利用差分回放来检测未初始化数据的使用情况，其他工具可能会忽略这些数据。此外，符号污点分析进一步帮助我们找到未初始化数据的位置，以及泄漏的内存区域的位级粒度的确切部分。

### 3 系统概述

检测为初始化变量的使用不容易。一个变量可以从多个位置（堆和栈）分配，并且频繁使用，可能会跨越不同的特权域。如果我们利用动态污点分析来跟踪整个系统（包括内核和用户程序）中的变量，可能会引入较高的性能开销。因此，通常只对指令进行部分跟踪，这就引入了漏报。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ge430mybi6j30ui0higoh.jpg)

我们系统提出了差分重放，来快速检测这样的问题。图4显示了系统的总体架构。具体来说，我们使用一个全系统模拟器来记录操作系统内核和用户程序的执行(❶)。然后重复执行，但带有从栈和堆中分配的变量poisoned值(❷)。如果变量在使用之前已正确初始化，那么两个重放实例应该具有相同的程序状态，因为初始化将覆盖poisoned的值。但是，如果使用变量时没有初始化，就会导致程序状态的差异。因此我们的系统可以在重放过程中检测使用未初始化的变量(❸)期间的差异，不需要执行耗时的全系统污点跟踪。

在这之后，我们进一步利用符号污点跟踪来帮助我们识别未初始化变量的来源(❹)。我们的系统执行了一个沿着程序执行跟踪的前向符号污点跟踪(❺)。这样做，我们可以确定变量分配的具体位置(❻)，以及被泄漏的未初始化内存区域。

在下面的两节中我们会描述这两个关键技术：差分重放和符号污点执行。

### 4 差分重放

记录程序执行的主要目的是为了保存状态以便回放。尽管有很多框架，如PIN，Valgrind，可以利用，我们系统利用了PANDA，一个基于QEMU的全系统模拟器和分析工具，理由如下：

1. PANDA是一个非侵入性的框架，在记录执行过程时不会改变程序的状态，如，内存布局。其他如PIN和Valgrind等用户级工具将驻留在程序的内存空间内，可能会改变用户程序的行为，如内存分配。这种对目标程序（或操作系统）的非入侵性需求对我们的系统非常重要。
2. 我们的系统需要跟踪整个系统内的数据流，因为变量可以跨不同的特权域。因此，我们需要一个全系统仿真器，它可以运行操作系统内核、系统服务和用户模式应用程序。用户模式插装架构，如PIN和Valgrind等不能满足这个需求。
3. PANDA能够执行系统范围内的确定性重放。它确保指令和其他不确定的系统事件（如中断）可以按确定的顺序重放输入。这个功能使得我们能够可靠地比较程序状态，以发现poison带来的区别。

在我们的系统中，记录功能是建立在PANDA系统上的。在实现过程中，我们发现并修复了PANDA中的几个bug，如某些类型的PCI DMA数据丢失、多线程场景中处理syscalls2的错误等。

#### 4.2 Poisoning Memory

在重放过程中，我们启动了两个实例。一个实例不更改任何内存，而另一个实例的栈和堆的内存都是poisoned。本文中我们把普通内存的实例称为普通记录重放实例（RRNormal）。对于另一个重放实例，在创建时用特殊的值初始化内存区域。这样的实例称为poisonde记录重放实例（RRPoisoned）。具体地说，我们改变从内核堆栈分配的内存的初始值。之后，如果RRNormal和RRPoisoned之间的程序状态不同，就会检测到未初始化变量的使用。

**Poisoning timing。**为了poison内核堆栈分配的内存，我们需要找到一种方法来监视新[栈帧](https://blog.csdn.net/jelly_9/article/details/53239718)的创建，以及从堆分配新的内存区域。

```
栈帧（stack  frame）：简单来讲，栈帧就是函数运行的环境。每个函数在被调用时都会在栈区形成一个叫栈帧的结构，这个结构中保存了函数参数、函数的局部变量、函数执行完后返回到哪里等等一些数据
```

（1）*栈帧创建：*当栈指针寄存器（如x86中的esp）上有减法操作时，就会创建一个新栈帧，它的大小可以通过减法指令的常数操作符获得。然后，我们可以相应的在新分配的栈帧中poison内存区域。

（2）*堆内存分配：*当通过call指令（或类似的指令）调用一个函数时，我们检查被调用者，以确定是否发生堆分配。例如，在Windows中如果被调用的是ExAllocatePoolWithTag，那么会从堆中分配新的空间，内存大小可以从这些函数的参数中获取。

**Poisoning policies。**不同场景在粒度和poison值方面有不同的需求。为此，TimePlayer支持不同的内存poison策略来满足这些需求。

（1）*粒度：*我们的系统支持不同的poison粒度，从细粒度的字节级到粗粒度的字级。例如，在使用字节级poison粒度时，每个poison的字节都是不同的。这是本系统的默认粒度。

（2）*poison值：*通过poison内核内存，并与内存空间比较内存写操作，我们的系统可以识别内核信息泄漏。例如，我们可以用一个特殊值0xaa来poison内核栈中分配的每一个字节。

TimePlayer将所有的poisoned内存的记录保存在一个poisoning history表中。这个表会在第五节中符号污点分析中用到，帮助找到未初始化变量的source。

#### 4.3 比较重放实例

我们的系统比较了RRNormal和RRPoisoned的状态。同时检查比较了一些特定指令的执行，这些指令被定义为检查点。

**检查点。**记住，TimePlayer主要用于检测未初始化变量的使用。因此，我们只在某些指令上进行比较，即检查点。检查点包括内存读写指令。例如，对于mov rax, qword ptr [rsi]指令，我们的系统比较寄存器rsi中的地址值和从两个重放实例中获取的内存值。但是，我们的系统只在1）内存写指令使用内核特权执行，2）目标地址在用户空间区域，并且3）两个实例中存在不同时才会考虑内核信息泄漏。

**差异比较。**我们在PANDA中通过内存R/W回调来实现差异比较。我们的系统维护两个重放实例之间的一个共享内存块，使用一个名为检查点的信息记录（Checking Points’ Information Record (CPIR)）的数据结构，来记录详细的上下文信息，如，访问的内存地址和内容。所有的CPIR实体都是使用共享内存的链表来维护的。

具体来说，两个重播实例以生产者-消费者的方式交互。RRNormal实例首先回放。在执行基本块后，相应的CPIR实体被推到CPIR列表的顶部。一旦共享内存满了，就会通知RRPoisoned实例开始执行，RRNormal停止执行。RRPoisoned从共享内存中获取CPIR，比较访问的内存地址和内容，重复这个过程，直到共享内存为空。然后它通知RRNormal实例继续执行，并暂停自身。

一旦发现差异，系统将记录详细的上下文信息。在本文中，我们把有差异的检查点称为differential point差分点。上下文信息以及poisoned history会被用于识别未初始化变量被分配的确切位置（第五节）。

**差分点之后继续执行。**在确定一个差分点后，我们的系统需要继续执行以找到更多的差分点。如果未初始化的变量不影响程序的控制流，则可以直接继续重放。然而，未初始化的变量可能会影响控制流。例如，程序控制流可能依赖于变量和常量或其他变量的比较操作。由于变量被poison了，它会导致控制流改变，与原本记录的控制流不同。这个可能导致PANDA的重放功能混淆，因为指令计数不一致。在这种情况下，我们要找到一种方法来修复这些副作用，让PANDA继续程序的重放。

具体地说，如果我们知道哪条分支指令将使用未初始化变量，我们就可以在差分点用RRNormal实例中的数据动态地向该指令提供数据，而不是用来自RRPoisoned实例中的数据。这样做是透明的，因为RRNormal的执行是在RRPoisoned之前进行的，并且使用共享内存进行同步。因此我们直接从RRNormal实例中复制数据，在RRPoisoned实例中使用。

**并行重放。**由于我们需要比较每个检查点的程序状态，因此差分重放回到值较高的性能开销。为了加快这个过程，我们在系统中引入了并行回放的概念，基于PANDA的scissors插件。我们的并行重放是这样工作的。它首先执行一个普通的重放，但是保存多个快照（N1、N2等等）和非确定性事件（S1、S2等等），事件其中包含指令计数C1、C2等等。在此之后，我们可以并行的重放保存的快照以及保存的非确定性事件，每个快照作为一个普通的重放实例（第二节说明了PANDA的RR的背景信息）。

并行回放在理论上会导致漏报。如，若果快照中的一条指令使用了前一条指令分配的变量，那么我们的并行回放将会错过它，因为不同片段中的poisoned状态是分开的。尽管这个问题可以通过跟踪切片机制得到缓解，（这种机制会仔细选择变量不会被分割的点），但是我们系统采用了一种更简单的解决办法。当整个快照被分割为多个部分时，我们扩展了每个部分的范围，使其与相邻的部分重叠。虽然这种机制不能完全解决问题，但是他减少了发生的机会。我们将在第6.3节展示并行回放的评估结果。

### 5 符号污点分析

当检测到一个差分点时，我们需要进一步确定未初始化变量的来源，即，变量被分配的位置。本系统第二个关键技术——符号污点分析，旨在满足这个要求。

#### 5.1 为污点分析准备跟踪和上下文

我们的污点分析适用于程序执行的跟踪。但是，出于性能考虑，我们系统不主动收集差分重放过程中的执行跟踪上下文。相反，当检测到一个差分点时，我们回看一定数量的指令（数量自适应决定），并将执行从那里回放到差分点。然后我们收集每个指令的详细上下文信息的跟踪。

我们实现了一个PANDA的插件来收集执行跟踪的上下文。具体来说，对于每条指令，我们的系统记录程序计数器（PC）的值、堆栈指针和通用寄存器、指令序列计数、访问内存地址等。在此过程中，需要使用每个指令的语义来保证只检查和记录被使用过的操作数（显式和隐式）。这是分别通过Intel XED和Capstone for x86以及ARM实现的。我们的系统还支持扩展指令集，如x87/MMX/SSE/AVX for x86。

然而，如何设置跟踪开始的代码位置，即，我们需要回看到多远，需要进一步的思考。如果位置离差分点太远，就需要很长时间才能从该地址重放，日志的大小也会很大。相反，如果位置太近，我们可能会错过分配初始化变量的位置。

在本文中我们提出了一种类似于滑动窗口协议的机制。具体来说，我们将栈帧的数量定义为窗口大小，并设置窗口大小的初始值。然后，如果窗口内的指令没有覆盖到分配变量的位置，我们将自适应地增加大小。我们继续这个过程，直到成功找到分配点，或当窗口大小达到一个阈值。

#### 5.2 符号污点分析

在获取了跟踪和上下文信息之后，就可以进行符号污点分析。在我们的系统中，我们将poisoned的内存区域定义为污点source（并分配符号表达式），而在差分点处的指令的内存操作数的地址和内容定义为污点sink。然后，实施符号执行，使污点表达式（tag）沿着跟踪传播。如果在执行过程中，会按需对表达式进行分割或简化。下面，我们用一个示例来详细说明这个过程。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ge41ip5heij31220je79f.jpg)

图5演示了污点标记传播的过程，其中未初始化变量从内核堆栈泄漏到用户空间程序中（参见2.2节中的示例）。主要操作是在内存区域和寄存器中添加或删除污点标记。具体来说，在图中第一行中，分配了一个新的内核栈帧。我们的系统为整个栈帧内存区域分配一个新的污点标记，使用表达式<BV992 TAINT_S_0_992>。符号TAINT_S_0_992表示这是一个索引为0，污点内存长度为992bits（124字节）的污点栈。由于在程序执行之间我们将有多个栈帧，所以系统维护了一个从堆栈索引到具体内存地址的映射表。第二行是，从内存区域[0x9e12fca4: 0x9e12fca4] (1字节长)中删除污点tag，因为这1字节常量值已经被写入内存了（就是被初始化了）。我们继续这个过程，直到图中的第4条指令将污点标记从内存传播到ecx寄存器，然后第5条指令将污点标记从ecx寄存器传播到内存。结果表明，目标内存地址是用户空间内的，也就是说污点内存值（未初始化变量）已经泄漏给了用户程序。此外，使用污点表达式，我们可以进一步定位分配变量的堆栈和泄漏数据的长度（32位）。在本系统中，符号污点分析是通过使用SimuVEX库和基于VEX IR的符号执行引擎实现的。注意本系统不需要解决这个表达式。

#### 5.3 优化

我们的系统引入了两种优化，即选择性执行和符号表达式包装，提高符号污点跟踪性能。

**选择性执行。**我们的系统并不总是使用符号执行引擎来执行每条指令。如果一条指令没有对污点内存或寄存器进行操作，就没有必要对他进行符号执行，可以安全跳过。

具体来说，我们首先解析生成的跟踪并将每条机器指令转换成VEX IR，当且仅当该指令在污点内存或寄存器上执行。如果指令不在，就保持不变。所有转换后的VEX IR和本机指令都保存在一个内存区域中，每个指令使用一个bit（指令模式位）来表示执行模式（符号或本机）。当我们发现从符号执行到本机执行的切换时，我们可以安全地跳过接下来的所有本机指令，直接跳到下一个操作污点值的符号指令。由于指令的具体上下文信息已经保存了，我们可以恢复上下文并从那里继续符号执行后面的内容。

**符号表达式包装。**随着符号表达式复杂度的增加，处理新表达式的时间和空间开销也在增加。我们的系统使用了另一种优化，表达式包装，来实现更好的性能。

具体来说，我们在传播每个符号表达式之前评估其复杂性。如果表达式太复杂，我们会拆分一个新符号作为别名来替换旧的。在我们的系统中，一个表达式的复杂度是由它的长度和深度来衡量的。表达式的长度是指表达式中原子符号的数量，而深度表示生成表达式的步骤的数量。在实践中，我们设置1024作为长度的阈值，6作为深度的阈值。这些域值是通过多个基准测试程序的实验得到的。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1geat5la178j30u00x4tip.jpg)

图6显示了最新版本的win7内核中污点分析的真实示例。在本例中，我们首先将内核栈帧[0xb1dab99c:0xb1dab9df]设置为污点source，标记为<BV544 TAINT_544>。然后，在三个复制指令(rep movs/push/mov)之后，内核栈中的4个字节被传递到edx寄存器并保持未初始化。经过多次算术运算和按位运算（加法、减法、乘法、符号扩展、位移bit等）后，这个符号表达式的复杂度将超过阈值。我们的系统相应地打包表达式并生成一个新的简单表达式，用于后续的计算。为了保存污点信息，我们的系统记录了新表达式和原表达式之间的关系。

### 6 评估

评估旨在回答以下问题：

**Q1-有效性：**TimePlayer能否检测到新的漏洞，并比最先进的工具表现的更好？

**Q2-效率：**TimePlayer可以快速检测漏洞吗？

**Q3-性能开销：**TimePlayer使用的关键技术的性能开销多大？提出的优化是否改善了系统的性能？

在评估期间，所有的实验都是在使用Intel I7-7700K Quad-core 4.20 GHz处理器，32G bytes RAM，运行Ubuntu 14.04.1的服务器上进行的。TimePlayer是基于全系统模拟器PANDA实现的。因此所有的操作系统都作为guest os运行，每个os分配了2G字节RAM。

#### 6.1 有效性

我们在7个月内将系统应用于多个Win7和Win10版本（32位和64位）。具体来说，我们利用了8个测试用例，并在打了当时最新补丁的Win7和Win10系统中运行它们，并使用我们的系统来记录和回放执行，以检测从内核空间到用户空间的信息泄漏。我们评估中使用的测试用例如表1所示。在测试期间，我们使用字节级粒度poison内核内存数据。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1geebd35awdj310a0fsad5.jpg)

**新漏洞：**表2显示了新检测到的问题（issues，指微软没有确认的发现）和漏洞（vulnerabilities，指已经确认的发现）的结果及详细信息。我们的系统在多个Windows内核组件中总共发现了34例内核信息泄漏。我们将我们的结果报告给了Microsoft Security Response Center。其中17个位确认为有CVE编号的漏洞。剩下的在写这篇文章时还在与微软评估安全结果。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1geebeeey7zj314z0u0dvf.jpg)

**Case study: CVE-2018-8477。**下面我们使用一个Case study: CVE-2018-8477来展示我们的系统是怎么在最新版本的windoes内核中检测新漏洞的。这个漏洞存在于Win10内核的nt!NtRaiseHardError模块。漏洞模块的部分代码可以在WRK(Windows Research Kernel) v1.2 project (Listing 1)找到。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1geebtgrtd0j31060du76g.jpg)

这个漏洞会在设置OptionShutdownSystem中的ValidResponseOptions值时被触发。在这种情况下，ExpRaiseHardError函数的返回值将是STATUS_PRIVILEGE_NOT_HELD(c0000061)，内核堆栈中的四个字节(LocalResponse)将泄漏给用户空间内存Response。

我们的系统在使用poisoned内核堆栈进行重放实例时定位这个漏洞。在执行了5.3 billion条指令后，PC 0x819e6147 (nt!NtRaiseHardError+0x175)位置发现了差分点。位于差分点的指令是`mov dword ptr [ebx], eax`，eax中的0xaa（即poison值）的4个字节被泄露给ebx指向的用户空间内存。然后，我们回到差分点之前500栈帧的地方，并开始前向符号污点分析。当到达差分点时，eax的污点符号表达式为TAINT_FunctionID_896[224:255]，说明未初始化的值来自栈偏移0x1C-0x1F处的NtRaiseHardError。表达式清楚地反映了未初始化的内核栈和泄露给用户空间内存的信息之间的关系。这说明我们的系统能够检测未初始化变量的使用情况。此外，它还演示了符号表达式可以帮助分析人员了解哪部分内存被泄漏了。

与Bochspwn比较：由于Bochspwn是检测内核内存泄漏的最先进的工具，我们希望将我们的工具与它进行比较。为此,我们使用了proof-of-concept(PoC)Bochspwn公开发布的exploits，在旧版本的Windows系统上运行(Windows 7 Service Pack 1 6.1.7601.17514 32/64位，Windows 10 pro 1703 10.0.15063.674 32位和Windows 10 pro 1607 10.0.14393.0  64位)。我们使用这些旧版本，因为它们包含在最新版本中已经修复的漏洞。我们总共从Bochspwn收集了52个公共漏洞，并将它们用于我们的评估。

结果令人鼓舞。我们的系统检测到85个漏洞，而Bochspwn只能检测到其中的67个。结果如图7所示(表3和表4显示了详细信息)。我们仔细检查了所有的调查结果，并与微软公司2016年和2018年的CVE信息进行了交叉核对，发现其中有55个CVE编号。另外30个没有CVE编号，也还没有被公布。然而，我们的人工分析证实它们确实是内核信息泄漏。我们相信这些漏洞是微软内部发现并修补的。这证明了我们系统的有效性。

**总结：**TimePlayer可以检测到影响最新版本Windows系统的新漏洞。使用相同的测试用例，Bochspwn报告的所有漏洞也可以被我们的系统检测到，我们的系统又报告了18个漏洞。

#### 6.2 效率

我们的系统的一个优点是利用差分重放来快速检测未初始化变量的使用，而不是使用污点分析来跟踪数据流。下面，我们将从跟踪未初始化变量的角度，比较差分重放和污点分析的效率。

为此，我们使用污染分析实现了一个跟踪数据流的系统(这个系统称为参考系统)。具体来说，我们使用PANDA来记录执行跟踪，然后对跟踪执行脱机污点分析，以检测内核空间中的变量是否已泄漏给用户空间。我们将相同的测试用例(表1)一个一个地提供给参考系统和TimePlayer，并记录每个漏洞被检测到的时间。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gegk49wy6uj30u00vu441.jpg)

结果如图8所示。x轴表示实验经过的时间，y轴表示检测到的漏洞的累计数量。TimePlayer花费了165,102秒来检测所有34个问题，总共分析了553,385,983,467条指令。平均速度约为每秒3,351,775条指令。然而，对于使用污点分析的系统，它消耗了超过24万秒(66小时)，在这段时间内只检测到其中的7个。这是由于整个系统跟踪的污点分析带来的高性能开销。

注意，我们的系统还利用污点分析来定位变量的来源。然而，我们只需要将污点分析应用到整个系统跟踪的一小部分，并且这个过程通常在不到一分钟内完成(Section 6.3)。

**总结：**针对关键技术差分重放，在检测未初始化变量的使用时，微分重放比污点分析更有效。

#### 6.3 性能

下面，我们将分别展示两个关键技术的性能评估结果，即，差分重放和符号污点分析。

**差分重放：**表5显示了差分重放的开销。ReactOS_a是我们评估中使用的ReactOS测试套件中的一个测试用例。我们还使用Chrome访问多个网页，并使用cp操作复制和粘贴1226个文件(总大小约40M字节)到guest Windows操作系统中。结果表明，差分重放比普通重放慢22-24倍左右。注意，尽管绝对速度很慢，但是它仍然比动态污点分析检测漏洞效率更高(第6.2节)。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gegkbmtczyj31060isadw.jpg)

我们的系统利用一个优化策略来并行重播多个实例(4.3节)。在下面，我们将评估这种优化的有效性。我们使用与前一个实验相同的测试用例ReactOS_a和Chrome。由于机器上的CPU核心数量为4个，我们将记录的跟踪划分为4个实例，这些实例被poisoned并并行地重播。结果如表6所示。我们可以看到，消耗的时间取决于最慢的实例，即，运行时间为1,354.33秒的实例。与没有并行回放的5,063.25秒相比，这种优化的速度提高了近4倍。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gegkmtd2ljj30u00vptgf.jpg)

**符号污点分析：**如表7所示，符号污点分析是非常有效的。当检测到一个差分点时，我们的系统会回看几个栈帧，并从那里重播，以生成详细的系统跟踪，以便进行进一步的污染分析。第二、第三和第四列显示用于生成跟踪的时间、跟踪的大小和跟踪中的指令数量。然后，我们对跟踪应用(离线)符号污染分析。特别是，TimePlayer传播污点标记并沿着跟踪生成符号表达式，直到到达差分点。时间在最后一列中报告。

注意，在评估期间，我们将窗口大小的初始值设置为500，并将阈值设置为5000(第5.1节)。在大多数情况下，我们的系统可以成功地定位窗口大小小于1500的source。由于我们只需要考虑窗口内的指令，污染分析通常会在一分钟内结束。

**总结：**差分重放比PANDA的普通重放慢22-24倍。然而，这个过程可以通过并行回放进行优化。对于真实的测试用例，符号污点分析通常在一分钟内完成。

### 7 讨论和局限性

**误报：**我们的系统比较程序状态的差异，以确定未初始化变量的使用。此操作在检查点执行(第4.3节)。在我们的原型和评估中，我们的系统用于检测内核信息泄漏。它只在使用内核特权执行内存写指令并且目标地址位于用户空间区域，而同时在两个重播实例之间存在差异时考虑内核信息泄漏。这是一个非常保守的策略，不会引入误报。我们的发现证实了这一点，所有报告的泄漏都可以人工确认(表2、表3和表4)。

**漏报：**我们的系统可能有漏报。即一些漏洞可能会被遗漏。这是由于动态系统的性质，其有效性取决于在此过程中的代码覆盖率。在我们的评估中，我们利用ReactOS测试套件和流行的程序(表1)来驱动和记录系统的执行。这导致了34个问题和漏洞的发现。但是，我们没有利用任何路径探索技术来主动触发新路径。我们认为，在代码覆盖改进方面的正交努力，例如，模糊测试工具AFL[69]或KAFL[56]可以借鉴。此外，由于DMA请求，我们的系统可能会错过内核内存泄漏。这是因为我们的系统不检查从DMA控制器发出的内存操作。

Poison内存的值需要仔细选择。这是因为在某些情况下，poison内存所造成的差异可能会消失。例如，如果未初始化的数据(其值为0 x0)被用来和一个常数值(例如0 x1)执行按位与操作，poisoned word是0 xaa，它不会引起普通重播实例和poison回放实例之间产生不同，这样的话未初始化的变量不会被检测出来。为了解决这个问题，我们可以使用不同的中毒数据多次运行程序，以减少误报的可能性。

**性能开销和优化：**评价结果表明，与PANDA的普通重放相比，差分重放慢了22 -24倍。请注意，这种减速并不影响我们的系统检测漏洞的有效性，正如我们的系统报告的新漏洞所显示的那样。此外，这种开销可以通过并行回放进行优化。具体来说，我们将跟踪划分为多个跟踪，并根据可用CPU内核的数量并行地重播它们。我们的实验显示了明显的加速(表6)，但是优化的潜在问题是可能会导致漏报。如果未初始化的变量是跨并行重播实例使用的，那么在应用此优化之后，我们的系统将错过它。

### 8 相关工作

**未初始化变量检测：**现代编译器(如GCC[37]、Clang[32]和Visual Studio[39])通常提供检测未初始化变量的功能。但是，它们中的大多数都局限于单个函数，无法处理数组、指针和循环[53]。一些商业产品，如CoBOT[2]、Coverity[4]和Code Sonar[3]，也展示了它们检测未初始化变量使用的能力。但是它们有很高的误报率，尤其是在分析数组时。R. Jiresal等人[27]试图通过利用基于总结的函数分析和COBOL上的控制流分析来减少误报。然而，它的方法是否适用于像C或c++这样的其他语言还不得而知。这些工具主要用于分析源代码，而TimePlayer可以在没有源代码的情况下分析二进制文件。

其他一些工具[11,58]使用动态分析或混合分析[24,25,62,66]来检测此类漏洞。例如，Memcheck[58]使用Valgrind[45]二进制翻译系统来检测基于影子内存的未初始化内存的使用情况。memorysanializer[62]依赖于编译时插装和位精确的影子内存。但是，这些系统要么用于用户级应用程序，要么需要编译器辅助工具，这些工具不能应用于特权和闭源的Windows内核。

Digtool[48]在栈和堆/池分配期间使用特定的字节模式来填充内存区域，并在从内核到用户空间传输的数据中搜索该模式。它可以检测内核信息泄漏，但是，它不能检测泄漏的数据在传输期间被修改的情况。与Digtool中使用的简单模式匹配相比，差分重放不受传输过程中数据更改的影响(因为它仍然可能导致程序状态差异)。DieHard[9]执行差分系统调用fuzzing，以发现未初始化变量在系统调用中的使用。这个想法很接近我们的系统。但是，它只关注系统调用，而TimePlayer的目标是检测整个系统中未初始化的变量漏洞。

UniSan[34]和SafeInit[40]都打算使用基于编译器的解决方案来检测和修复未初始化的数据泄漏。具体来说，UniSan使用静态数据流分析来检查未初始化的数据是否可以到达一些预定义的sink，例如copy_to_usr和sock_sendmsg。如果是这样，它将在LLVM编译器的帮助下修复脆弱性代码。SafeInit向LLVM编译器添加一个初始化传递，以便在变量没有正确初始化的情况下对它们进行初始化。我们的系统与这两个系统的主要区别是，它们需要源代码并利用编译器来执行分析，而我们的系统直接处理Windows内核的二进制代码。由于这种差异，我们的系统面临着不同的挑战，例如，如何利用差分重放来查找未初始化的变量(不使用源代码)。

最近的一个系统kMVX[70]使用多变量执行(MVE)的概念来检测Linux中的内核信息泄漏。但是，kMVX需要大量地更改目标系统的源代码，因此它不能应用于Windows内核。相比之下，TimePlayer是一个非侵入性的系统，它可以向闭源系统工作，它的有效性已经通过检测Windows 7和Windows 10内核的零日漏洞得到了证明。

**差分测试Differential testing：**我们的系统利用差分重放来检测内核信息泄漏。观察程序状态差异的思想也用于差异测试领域。例如，使用差异测试来测试C语言[38,52,65]、SSL/TLS实现[10,13,49,60]和复杂软件系统[5,12,26,29,61]的编译器。这些系统通常利用源代码来进行测试。相比之下，我们的系统并不依赖于源代码来发挥作用。

**RR：**记录重放技术旨在为存在非确定性事件的程序提供确定性重放，可应用于调试和安全等领域[19,54,55]。非确定性事件通常是记录和回放系统面临的主要挑战。其中一些依赖于自定义硬件来处理非确定性事件[22、43、44、50、64]，而另一些则需要修改OS内核[6、8、31]。SMP-ReVirt[20]是第一个在普通多处理器硬件中记录和回放整个未修改系统的执行的系统。它使用硬件页面保护来检测不同CPU内核之间的交互。RR[47]是一个轻量级、实用的用户空间工具，用于记录回放。它一次只运行一个线程，以避免不同内核之间的交互造成的不确定事件。我们的系统使用PANDA[18]来完成整个系统的确定性记录和回放。通过这样做，我们能够使用易于使用的api来分析Windows内核，从而扩展PANDA的功能。

**动态污点分析：**在过去的十年中，污点分析在计算机安全领域得到了广泛的应用，如数据泄漏跟踪、漏洞发现等。有些系统，如TaintCheck[46]、Taintgrind[30]、TaintPipe[42]、TaintTrace[14]，是基于二进制插装来执行污点传播的。这些工具通常用于跟踪单个二进制文件中的数据流，而不是用于整个系统的数据流分析。

其他一些工具，如TEMU[67]、Panorama[68]、TaintDroid[21]和OFFDTAN[63]，使用虚拟机来执行整个系统的污染跟踪。由于污点标记和跟踪会消耗大量的资源，因此这些工具的效率成为它们的主要弱点。

FlowWalker[15]是一个离线的动态污点分析工具，它将记录和分析过程分离开来。这样的架构提高了污点分析的效率。基于FlowWalker的in-memory fuzzing[16]和灰箱文件格式分析[17]等技术也取得了良好的实验效果。FlowWalker直接在x86汇编语言上构建污点分析逻辑，这使得它很难扩展到其他架构(比如x86-64)。此外，FlowWalker很难处理位移位、逻辑操作和算术操作造成的污染消除，而TimePlayer中的符号污染分析可以轻松地处理这些问题。StraightTaint[41]使用了符号污点标记和离线分析，这与TimePlayer的符号污点分析类似。然而，StraightTaint利用用户级检测工具PIN，这使得它无法分析操作系统内核。

### 9 结论

在本文中，我们的目标是检测由于使用未初始化变量而导致的内核信息泄漏。为此，我们提出两项关键技术，即，差分重放和符号污染分析，以快速找到使用未初始化的变量和变量被分配的位置。我们开发了一个名为TimePlayer的原型系统。在Windows 7和Windows 10内核上应用我们的系统的评估证明了它的有效性，发现了34个新问题(其中17个已被确认为漏洞)。