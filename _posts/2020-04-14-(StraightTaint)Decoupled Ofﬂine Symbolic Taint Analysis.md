---
layout:     post
title:      (StraightTaint)Decoupled Ofﬂine Symbolic Taint Analysis
subtitle:   ASE2016
date:       2020-04-14
author:     qzwerty
header-img: img/blog-bj-1.png
catalog: true
tags:
    - RR  
    - security analysis 



---

## (StraightTaint)Decoupled Ofﬂine Symbolic Taint Analysis

污点分析的多方面好处使其在事后安全应用程序中得到广泛应用，如攻击溯源，计算机取证分析和协议逆向工程。不幸的是，动态污点分析带来的高运行时开销使得它在很多场景中难以实现。关键的障碍是程序执行和污点跟踪逻辑代码的严密耦合。为了缓解这一性能瓶颈，最近的工作试图将污点分析从程序执行中隔离出来，在空闲的核心或者另一个CPU上运行。然而，由于污点分析有大量的数据和对程序执行的控制依赖，有大量数据需要记录转换，使得分开处理这个方法也不好使。在本文中我们提出了一种新的技术，使用非常轻量级的日志记录，从而大大减少了执行的延迟，但依然能够允许我们执行全功能的离线污点分析，包括bit级和多tag污点分析。我们开发了StraightTaint，一个混和污点分析工具，完全解耦了程序执行和污染分析。StraightTaint依赖于对执行信息的非常轻量级的日志记录来重建代码，从而支持离线符号污点分析，不需要频繁地与应用程序进行数据通信。虽然StraightTaint不记录完整的运行时或输入值，但他能够准确确定sources（污点源）和sink（污点汇聚点）之间的因果关系。与传统的动态污点分析工具相比，StraightTaint具有更低的应用程序运行时开销。

```
污点分析可以抽象成一个三元组<sources,sinks,sanitizers>的形式,其中,
·source 即污点源,代表直接引入不受信任的数据或者机密数据到系统中;
·sink 即污点汇聚点,代表直接产生安全敏感操作(违反数据完整性)或者泄露隐私数据到外界(违反数据保密性);
·sanitizer 即无害处理,代表通过数据加密或者移除危害操作等手段使数据传播不再对软件系统的信息安全产生危害.
```



### 1 INTRODUCTION

污点分析作为数据流分析的一种特殊形式，有很多应用。除了运行时强制安全策略之外，对二进制代码的污点分析也在事后应用程序中广泛应用（ex post facto security application，如攻击溯源，计算机取证分析，恶意软件分析，逆向工程）。静态污点分析（STA）的目的是在执行之前对source和sink之间的因果数据流关系进行推理。然而，当源代码不可用时，尤其是对于模糊的二进制代码，静态污点分析不够精确。另一方面，动态污点分析（DTA）沿着程序执行路径传播污染标记，在许多静态分析达不到精度的情况下是准确的。然而，动态污点分析通常存在高性能的代价。通常，最先进的动态污点分析工具，如libdft，通常会带来6倍的slowdown。最坏的情况下，slowdown可以达到20-30倍。动态污点分析带来的高运行时开销严重限制了他的应用范围。

进一步提升动态污点分析性能的关键障碍是程序执行与污染跟踪逻辑代码的紧密耦合。污点分析必须维护一个影子内存，将指令操作数映射到它们相应的污染标记。要在不同的residence之间传播污点tag，通常需要6-8个额外的指令。此外，由于污点跟踪代码与程序运行交织在一起，应用程序和污点分析代码之间频繁的上下文切换进一步增加了寄存器和数据缓存的压力（如，寄存器溢出和cache miss），导致大量开销。

为了降低这些高性能带来的开销，现有工作提出了很多方法将污点跟踪代码放到单独的核心或者不同的CPU上。现有工作大致可分为两类。第一类依赖于多核系统来并行动态污点分析，主要是通过记录「另一个核心中污点分析」所需的运行时值。然而， 由于污点分析具有很强的连续的对程序执行的数据和控制依赖，所以并行污点分析需要通过自定义硬件或共享内存进行频繁同步，以进行数据通信（如，控制流方向和内存地址）。第二类首先记录应用程序的执行，然后在不同的CPU上重放污点分析[15, 42, 45, 48]。与第一类的局限性类似，大量的在线日志数据也是实现预期性能收益的一个障碍。

本文提出StraightTaint，是一种静态和动态结合的方法，实现了非常轻量的日志记录，执行slowdown非常小，而且仍然允许我们执行完整的离线污点分析。原则上，StraightTaint属于第二类解耦DTA方法。因此StraightTaint非常适合事后安全应用程序。StraightTaint中，我们不记录所有的运行时值（runtime values）。我们在首次引入污点种子时记录控制流信息和执行状态，这些是非常轻量的。根据所记录的分支信息，我们构造了用于离线污点分析的直线（straight-line）代码跟踪。污点种子被标记为符号变量，污点传播类似于在构建的直线代码上的符号执行。使用初始执行状态和直线代码，多数内存加载和存储操作的地址都是可计算的。通过求解路径条件，可以将符号内存索引缩小到一个范围内。与纯静态的方法相比，StraightTaint仍然可以提供与动态污染分析类似的精度水平。例如，我们能够正确识别多个source和sink之间复杂的因果关系（见Section 6），而静态污染分析在这种情况下是失败的。

由于计算资源的限制，传统的DTA在不完全污点传播策略方面存在一些缺陷。首先，由于多tag污点传播会消耗更多的影子内存，并引入更高的运行时开销，因此大多数DTA工具选择将单tag传播作为默认值。然而，多tag污点分析对于许多逆向工程任务是必不可少的，如恢复未知协议格式的结构，以及通过计算不同的污染输入字节来检测恶意软件中的编码功能。其次，在处理复杂的x86算术和逻辑运算指令（如，add和xor）时，为了获得更好的性能，先前的DTA工具通常采用一些简单但保守的传播策略。一个例子是流行的“short circuiting”方法：如果任何一个源操作数被污染，那么目标操作数被污染。这些保守的解决方案在许多情况下会导致精度损失。由于StraightTaint已经完全把污点逻辑代码转移到离线分析，就可以支持全功能的污点传播策略。在本方案中，支持bit级和多tag污点分析。每个符号bit或变量都可以自然的表示一个污点tag，附加的开销可忽略不计。并且，我们的符号执行风格污点传播可以忠实地模拟指令的特定语义。此外，在对直线代码进行符号污点分析的基础上，我们介绍了一个新的概念，Conditional Tainting，条件污点，即，在什么条件下，StraightTaint可以准确识别source和sink的因果数据流关系。这样，新的输入和运行时值可以被映射到某些场景的现有分析结果中，这样有利于进行新的分析。

我们已经开发了一个StraightTaint的原型。我们的实现基于Pin，用于运行时日志记录的有效并行化，而BAP用于不完整输入的精确离线符号污点分析。我们已经对一些应用程序进行了比较研究，如通用实用程序、SPEC2006和现实生活中的软件漏洞。结果显示StraightTaint可以与动态污点分析的精度相当，但是在线执行slowdown要小得多。性能实验表明，StraightTaint给应用程序执行性能增加的开销很小，平均对SPEC2006增加了最多3.25倍。离线污点分析花费时间与先进的DTA工具相比大概相同。我们还证明了StraightTaint在攻击溯源调查任务中支持多tag污点传播和条件污点的价值。这样的实验证据表明，StraightTaint可以用于各种大规模的事后安全应用。

**Contributions。**

1. StraightTaint使用非常轻量的日志方法来构造直线代码，从而完全解耦离线符号污染分析的动态污染分析。StraightTaint大大降低了程序执行slowdown，并且与动态污染分析有相似的精度。
2. 以前解耦污点工作的局限性在于，无法有效收集和传输执行应用程序到分析模块的数据。我们证明了StraightTaint离线分析不需要完整的运行时数据，但仍然可以完成大多数任务。
3. 完全解耦的离线污点分析允许StraightTaint执行全功能的传播策略。符号执行风格的污点传播可以准确描述x86指令的复杂语义，并且自然的支持多tag和bit级污点分析。
4. 在对直线代码进行符号污点分析的基础上，我们提出了一个新的概念，条件污点。条件污点不仅报告了更精确和有用的污染结果，而且支持许多新的重要应用。

我们还总结了我们方法的好处。

1. 一旦日志被捕获，就可以通过StraightTaint多次进行分析。当很安宁预测确切的分析任务时，这个特征尤其有用。在我们的多tag污点传播评估中，我们在每一轮都变化污点tag的数量。StraightTaint只需要记录一次所需的联机数据，并在脱机的情况下执行多轮传播即可。
2. StraightTaint允许在云上进行事后基于日志的污染分析。服务提供商可以在服务中部署轻量的在线日志，而云主机为记录的数据提供存储空间。用户可以请求服务离线审计他们的敏感数据流。

论文的其余部分组织如下。第2节提供了背景信息和我们方法的概述。第3节描述了高效的在线日志记录和我们的优化。离线符号污点分析将在第4节中讨论。第5.1节重点介绍了我们的一些实现选择。我们将在第5节的其余部分中介绍对我们的方法的评估，并在第6节中演示其应用。相关工作见第7节。在第8节中，我们总结了本文并讨论了未来的工作。

### 2 背景和概述

#### 2.1 动态污点分析优化

DTA是一种沿着程序执行路径跟踪污点数据的信息流分析方式。通常，来自于不可信源的数据被标记为污点（即污点种子），根据污点传播策略跟踪对污点数据的传播进行跟踪。然后会在某些关键位置（即污点sink）对这些污点状态进行检查。DTA被广泛应用于软件安全应用程序中。然而，传统的DTA的一个固有限制是污染逻辑和程序执行严密耦合。图1显示了一个基于动态二进制检测（DBI）的传统DTA。污点跟踪代码与程序执行交织在一起，导致频繁的上下文切换，以及应用程序与污点分析代码之间的资源竞争。因此，被检查的应用程序速度会被减慢很多。已经提出了很多先进的DTA技术来实现良好的运行时性能。例如，Minemu利用x86 SSE寄存器为32位应用程序提供轻量级污点跟踪。不幸的是，他们要么依赖于特定的仿真器，要么无法在普通硬件上工作。将污点分析和程序执行解耦是一种有效的方法。然而，由于需要应用程序的执行来提供大量的数据和控制流，解耦的污点分析不能独立运行。直观的说，每个内存地址和控制传输目标都必须交付给解耦污点分析。因此进一步提升性能的障碍是大量的日志数据。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gduk91tmf9j30ri0bg75l.jpg)

如图1，我们的主要观点是，污点分析可以完全从程序执行中解耦出来，不需要频繁的在线通信和同步。离线污点分析可以基于控制流信息以及很少的运行时数据来进行（运行时数据如，引入污点种子时的初始执行状态）。我们注意到x86架构中内存引用操作是通过寄存器和常量偏移量计算来实现的。例如， mov ebx [4\*eax+4] 将存储在地址 4\*eax+4 的内容加载到ebx。使用初始执行状态和直线代码，可以恢复大多数内存引用地址。

注意，执行重放工作记录所需的输入，然后在离线分析中重放，也可以应用于解耦污点分析。这样与StraightTaint相比，日志更小，在线性能更好。但是，记录数据包含的执行信息很少，不能直接进行污染分析。此外，离线重放开销相当高。例如，Aftersight在基于QEMU的CPU模拟器上重放单tag污点分析，性能达到了100倍的slowdown。我们的解决方案代表了平衡在线日志和离线污点分析之间的性能的中间立场。

#### 2.2 不完全污点传播策略

传统的DTA工具受到计算资源的限制，通常他们必须采用不完全污点传播策略才能获得可接受的特性。在许多情况下，这种保守策略会导致精度损失。第一个缺点来自于单tag传播。多数DTA工具将每个变量与影子内存的一个比特或字节关联起来，以表示污点状态：1表示被污染，2表示未污染。尽管单tag可以在一些简单的场景中工作，多tag污点分析能具有更广泛的安全应用。例如，BitFuzz将不同的污点标签分配给输入字节，然后通过识别高污染程度来检测恶意软件中的编码函数；iBinHunt使用多tag污点分析来减少需要被比较的可能的基本块的数量。此外，许多算术运算和逻辑运算结果与操作数重叠，污点tag可能来自于多个源。因此，多tag属性对于准确性也很重要。因此，第二个局限性是由于在处理复杂的x86指令时采用了保守的传播策略。这些简单的策略速度快，但忽略了可能影响污点传播结果的特定指令语义。除了经常使用的short circuiting的解决方法之外，以前的一些工作只通过一元操作（二进制操作的输出被设置为未污染）跟踪污染流，以实现更好的并行化。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gdum3v4s7ij30o805uwfi.jpg)

图2显示了一个编码函数的片段，该函数常用于恶意软件。图2（a）列出了带有复杂算术运算的直线代码。传统的DTA使用单tag和“short circuiting”策略对这段代码进行污点分析。图2（b）显示了传播结果：所有变量都被污染了。仔细看图2（a）中的第三行，变量w的污点tag来自于两个污点种子，但传统的DTA只将其标记为单个tag。此外，变量d总是0，因为c是a的非，这样的话d应该不是污点，标记产生错误，导致了过度污染。StraightTaint的一个自然的好处是，可以直接支持全功能的的污点传播策略，包括多tag和bit级污染分析。此外，我们对直线代码的符号污染分析可以捕获x86指令的复杂细节。图2（c）显示了StraightTaint的多tag符号污点传播分析结果：w和c被正确的标记为污点，d的污点标记被清除。StraightTaint避免了不完全污点传播策略带来的不精确和过度污染的问题。

#### 2.3 结构

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gdumvs77yrj30zu0agwg9.jpg)

图3显示了StraightTaint的结构。由两个阶段组成：在线日志和离线分析。第一阶段，左半边，包括一个非常轻量级的在线日志记录，主要记录控制流信息。我们使用[动态二进制插装（DBI,dynamic binary instrumentation）](https://zhuanlan.zhihu.com/p/42180975)构建了一个日志工具，使StraightTaint能够直接处理未经修改的程序二进制文件。正在检查的应用程序在DBI和日志工具之上运行。我们的日志工具动态测量每个程序的基本块，使用每个基本块特有的tag来记录执行情况。基本块的tag被写入一个跟踪buffer，buffer满了以后存进磁盘空间。提高效率的关键是在线日志工具的设计。因此我们在第3节中提出3个指导方针。

```
DBI，动态二进制插桩技术，可以在不影响程序动态执行结果的前提下，按照用户的分析需求，在程序执行过程中插入特定分析代码，实现对程序动态执行过程的监控与分析。目前，应用广泛的动态二进制分析平台有Pin，DynamoRIO和Frida等。
```

生成的日志数据被传送到离线污点分析（图3右）。这个阶段首先从日志数据中重建直线代码跟踪，然后把x86指令升级到BIL，这一种类似于RISC的中间语言。我们的符号污点分析器的核心是抽象污点分析处理器。与DTA中的影子内存类似，StraightTaint维护一个上下文结构来存储符号污点变量和具体值。我们的离线污点分析器既能够处理前向污点跟踪，探测入侵影响，也能后向跟踪，来确定攻击的来源。即使没有完整的运行时数据，StraightTaint也能实现与动态污点分析相当的精度，在第4节讨论。

### 3 高效的在线日志

StraightTaint应用轻量级日志记录来降低对应用程序性能侧影响。由于不是所有执行的指令都有意义，所以我们在首次引入与定义的污点种子时调用在线跟踪日志记录。在StraightTaint中，用户可以将来自键盘、文件、网络或函数返回值的输入数据作为污点种子。为了避免离线分析中产生符号污点变量爆炸，我们利用引入污点种子时的具体执行状态来约束新的符号变量。我们通过执行进程转储来收集执行状态。除此之外，执行控制流信息被记录下来，用于稍后重新构建直线代码。可能影响控制流的不确定的变量（如，随机数和时间）也被记录。

记录的数据首先存放在内存缓冲区中，然后在缓冲区被填满时转储到磁盘存储中。实现低在线日志开销有三个要求：1）日志数据表示形式应当紧凑，以便跟踪缓冲区能够容纳尽可能多的数据。2）当所有缓冲区被填充满时，应用程序的执行不应该被阻塞，即，对缓冲区的操作是异步的。3）插装开销应最小化。我们通过扩展高级跟踪文件格式来满足第一个要求（3.1节）。为了解决第二个问题，我们提出了一种基于多核的n路快速缓冲方案来并行化配置文件消耗（3.2节）。最后，我们仔细设计了我们的插装代码，来支持内联代码，并避免频繁的上下文切换。第5节，我们会介绍我们采用的其他基于Pin的优化，实现性能收益的增强。

#### 3.1 跟踪分析

应用程序的直线跟踪可以表示为执行的基本块序列。一个基本块是带有一个入口点和一个出口点的直线代码序列。一种简单的方法是记录每个基本块的入口地址。在32位机器上，需要一个4字节的tag来标记一个基本块。然而，一个完整的4字节tag占的空间太大。Zhao等提出了一种高效、详细的执行概要方法Detailed Execution Proﬁle (DEP)。DEP只使用2字节的tag来记录最基本的块，并处理带有额外转义字节的特殊情况。DEP将一个4字节的地址分成2个高字节（H-tag）和2个低字节（L-tag）。在控制流分析期间，如果两个连续的基本块共享相同的H-tag，则每个基本块只有L-tag被记录到配置文件缓冲区中。如果这两个H-tag不同，那么将在缓冲区中输入一个转义tag 0x0000，后面跟着新的H-tag。我们的跟踪分析设计基于DEP，并进行了大量的优化。

某些带有rep前缀的x86字符串指令（MOVS、LODS、STOS、CMPS和SCAS）会重复执行。DBI工具通常将带有rep前缀的指令视为隐式循环。如果一个以rep为前缀的指令会迭代很多次，第一次迭代之后的迭代将生成单个指令基本块。在这种情况下，我们将看到比预期更多的基本块。为了解决这个问题，我们检查了带有rep前缀的指令的第一个循环，并配置Pin来禁用展开下面的循环。然后我们用两个连续的转义值0xﬀﬀ和一个迭代号对rep前缀的指令进行编码。

为什么选择对执行的基本块进行编码，而不是控制流分支决策或者Pin跟踪：首先，可以通过记录条件条转的二进制决策来使用单比特记录一个基本块，这可以使日志数据更加密集。但是，1比特编码不支持Pin代码内联，这会带来更多的插装开销。此外，从1位编码中恢复直线代码非常耗时。其次，Pin跟踪的单入口点多出口点的特性使得轨迹大小不能唯一确定。第三，静态程序分析可以用来去除冗余的插装点。然而，要记住，StraightTaint在攻击者环境中运行，精确的静态特征，如控制流图，都是不可用的。我们的设计选择使得StraightTaint能够分析混淆的二进制文件。

#### 3.2 多线程快速缓冲区方案

本节介绍多核平台上并发缓冲数据的通用方案。利用那些未被充分利用的计算资源来缓解磁盘I/O瓶颈。设计核心是一个缓冲线程池，其中多个缓冲区允许插装的应用程序继续执行和填充缓冲区，而多个Pin-tool内部线程异步处理完整的缓冲区。图4展示了缓冲线程池的工作方式，处理步骤如下：

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gdvs7p9rq4j30zu0h6di7.jpg)

1. 当程序开始运行时，应用程序分配一定数量的空闲缓冲区（图4中分配了8个）。
2. 同时生成多个Pin工具内部线程，称为worker threads（图4中有8个）。worker thread从被填满的缓冲区队列中取出一个缓冲区，将缓冲区数据转储到磁盘存储中。多个worker threads通过缓冲区的锁来独占的访问被填满的缓冲区。
3. 应用程序首先填充一个空闲缓冲区。当这个缓冲区被填满时，一个回调函数BuﬀerFull将被调用来执行两项任务：1）将这个填满的缓冲区放入全局满缓冲区队列，唤醒一个worker thread来处理它。2）将下一个可用的空闲缓冲区返回给应用程序。

我们依靠缓冲方案的实现来降低对应用程序的影响。具体来说，我们创建了足够的工作线程，以确保工作线程可以立即处理一个填满的缓冲区。此外，我们动态调整分配的缓冲区的数量，以及工作线程的数量。未使用的核心的可用性和配置文件缓冲区的大小对运行时性能有很大影响。5.2节中讨论如何调整这两个因素。

#### 4 离线符号执行污点分析

#### 4.1 直线代码的重构

给出从在线日志中收集到的跟踪信息，重建一个完整的4字节基本块起始地址序列是非常简单的。跟踪文件的开头是一个特殊值0x0000，后面跟着一个H-tag。每个基本块的4字节入口地址与它对应的H-tag和L-tag相关联。然后从应用程序的反汇编代码中提取每个基本块的x86指令。要精确的跟踪二进制级别上的污点传播，需要详细的x86 ISA知识。然而，x86 ISA很复杂。例如，以前的工作，如libdft包含5000行以上的代码来处理x86 ISA。图2（a）显示了这样一个涉及复杂算术运算的例子。更糟糕的是，一些具有隐式副作用的指令只能根据EFLAGS的内容有条件的传播污点（如，CMOVcc）。为了避免x86的复杂细节，我们把x86指令转化为BIL，一个类似RISC的中间语言。BIL只给我们留下25条指令，我们仔细分析这些指令就能准确追踪污点。注意，通过控制流信息，我们解决了直线IL代码中的所有间接控制流目标和条件跳转方向。

#### 4.2 符号污点分析

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gdvx13fietj310a0fagny.jpg)

通过将污点种子标记为符号变量，StraightTaint的离线污点传播是一种针对直线代码的符号执行。由于每个污点种子字节可以与一个新的符号相关联，所以多tag污点传播对于StraightTaint是自然的。我们的符号污点分析引擎（如图5）的核心是一个抽象处理器abstract processor，维护一个上下文context结构作为执行状态。上下文结构由 程序计数器pc，变量上下文V以及内存上下文M组成。为简洁，我们用元组s = (pc, V, M)表示抽象处理器的状态。变量上下文V包括所有的符号寄存器值（如通用寄存器和EFLAGS位）和临时变量。临时变量是指BIL静态单赋值形式中使用的表达式。我们还显式的将函数返回值表示为一个特殊的变量，以方便检测缓冲区溢出漏洞。内存上下文M的结构类似于 x86虚拟寻址的两级体系结构，是从内存地址到符号变量的映射。通过解释当前pc的IL，抽象处理器的状态s = (pc, V, M)被翻译成新的状态s ′ = (pc ′ , V ′ , M ′ )， V ′和M ′根据IL的语义进行更新。与此同时，StraightTaint通过检查某个位置（即污点sink）是否为符号表达式，来确定这个位置是否被污染了。最后一条IL被模拟后，pc停止，V和M不再更新。（？）

当预定义的污点种子首次被引入应用程序时，我们开始离线污点分析。除了污点种子之外，可能还有其他未初始化的变量，如堆栈指针和内存内容。原则上，我们可以为每个未初始化的变量分配一个新的符号变量。然而，包含未初始化状态的符号污点执行会很快达到内存容量限制，并导致“过度污染”的问题。我们的解决方案是利用进程转储来分配其他未初始化的有具体值的变量，只把污点种子作为符号变量。这里我们用另一个例子来显示符号执行风格的污点传播的优点。为了减少条件跳转的次数，一些编译优化选项将条件指令转换为一系列算数操作。图6（a）显示了我们在测试用例中找到的这样一个例子。图6（b）列出了每个指令的语义。算术运算序列的最终结果如图6（c），它实际上是一个分支条件。reg的污点tag来自于val1或val2。对于这种情况，StraightTaint成功传播了标记，而之前的工具，Temu, libdft,和FlowWalker都失败了。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gdvyrytlckj30ts0fegnq.jpg)

#### 4.3 内存引用地址解析

StraightTaint离线污点分析的另一个特点是我们不记录内存引用地址，因为这些地址可以通过通用寄存器和常量偏移量计算得到。我们观察到，使用初始执行状态和直线代码，大多数内存引用地址可以通过符号污点分析来确定。图7（a）显示了如何解析间接内存访问。因为我们已经解决了直线代码中的每个间接跳转目标（见4.1节），因此可以确定BB2中通过eax间接访问的内存。为解决无法精确计算的内存地址address_a（如，堆内存分配），我们动态的分配内存。受micro execution启发，我们使用了malloc(1)的返回值作为address_a，保证了address_a不会与现有地址发生冲突。然后我门使用一个符号变量来代表address_a的内容，之后对address_a的读取都会返回这个相同的符号值。符号索引是在使用符号变量作为内存查找的索引时发生的，例如ASCII到Unicode、to lower和to upper的转换函数。直观的说，符号内存索引可以指向任意内存槽。我们通过求解路径条件来解决这个问题。如图7（b）所示，沿直线代码路径条件将符号内存索引j的范围限制在4<j<8之间。然后我们保守地将所有可能的内存值标记为污点。也就是图7（b）中，A[5], A[6], A[7]都被标记为污点。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gdw0rko9nrj30o60k2dht.jpg)

#### 4.4 条件污点

由于x86条件控制传输指令（如jz和jo）通常依靠EFLAGS寄存器的值，我们的虚拟寄存器还跟踪EFLAGS的比特级符号变量。当在条件跳转指令中使用了符号表达式时，我们将它收集为分支条件。在完成符号污点传播运行之后，所有分支条件的连接都是污点逻辑约束。因此，满足污点逻辑约束的值就是具体的污点种子，它可以导致程序执行到与符号污染相同的污点跟踪操作。使用污点逻辑约束，（污点逻辑约束可以由一个定理证明器解决。如[Z3](https://blog.csdn.net/weixin_41637380/article/details/90299136)，一个约束求解器），之前的污点分析结果可以被映射到新的输入和运行时值，不用再次使用DTA。

```
Z3是由微软公司开发的一个优秀的SMT求解器（也就定理证明器），它能够检查逻辑表达式的可满足性。
```

#### 4.5 优化

Pin的块缓存是为了节省频繁执行的基本块重译的开销，我们采用类似的方法来加快离线符号污点分析。称为sub-trace cache（见图5中的sub-trace cache组件）。我们将具有一个前任和一个后继的序列基本块作为一个sub-trace，可以将其视为扩展的基本块。我们将sub-trace的输入输出关系表示为一组符号公式，并在sub-trace单元中维护一个查找表。因此，连续的运行可以直接重用以前的结果，不需要重新计算。我们采用的另一个主要优化是函数摘要。多数著名的库函数都有明确的定义，（如C字符串操作函数定义在string.h中），其中许多库函数并不影响污点传播（如strcmp）。因此，我们可以关闭这些函数边界处的符号污点分析，并根据他们的语义更新上下文。对于带有rep前缀的指令引入的相邻内存访问序列，我们从跟踪配置文件（即log？）中恢复重复的数量，执行批处理，不进行逐字节操作。

### 5 实现和评估

#### 5.1 实现

为展示StraightTaint的思想，我们实现了一个原型，其中包括基于Pin DBI框架（版本2.12）的在线日志记录，使用2660行C/C++代码，以及离线符号污染分析引擎。分析引擎基于BAP（0.8版），使用4540行OCaml代码。我们依靠BAP将汇编指令转换成IL，将IL表达式转换成CVC公式。我们使用z3作为约束求解器。sub-trace cache的查询表的保存和加载是使用OCaml Marshal API实现的，该API将任意数据结构编码为字节序列，然后将其存储在磁盘文件中。

在实现Pin-tool时，我们创建线程本地存储(TLS，thread-local storage)槽来存储和检索每个线程的缓冲区结构。请注意，Pin-tools无法使用pthreads库或Win32线程API。我们使用Pin线程API来派生工作线程，并使用Pin自己的二进制信号量实现计数信号量。为了更好地利用Pin的代码缓存，我们将每个Pin跟踪的最大基本块数量从3个增加到8个。我们还使用GCC的内置宏“__ builtin_expect()”向编译器提供分支预测。此外，我们通过Pin的快速缓冲api来执行低开销的数据缓冲，它支持在缓冲区满时内联一个回调函数。我们还强制Pin使用fastcall调用约定来通过寄存器传递参数，以避免发出堆栈访问指令(即，push和pop)。可以通过https://github.com/s3team/bincfp获得StraightTaint高效的多线程控制流分析Pin-tool。

我们的试验床包含两台机器。一个是服务器机器，它配备了两个Intel Xeon E5-2690处理器(16核2.9GHz)和128GB RAM。另一款是台式机，由英特尔酷睿i7-3770处理器(四核，3.40GHz)和8GB内存组成。两者都运行Ubuntu 12.04。本节中所有的数据都是平均值。我们通过对每个实验案例进行五次重复来计算它们。

#### 5.2 缓冲区大小和worker threads

研究了影响StraightTaint在线日志性能的两个因素:1）控制流文件的缓冲区大小；2）可用worker thread（负责将满了的buffer转储到磁盘）的数量。我们首先调查各种缓冲区大小的影响。为了获得足够的并行性，worker threads的数量分别设置为16和4。因此，总的缓冲区大小是worker threads的数量×单个缓冲区大小。我们选择[SPEC CPU2006](http://m.expreview.com/21482.html)，以测试工作负载作为训练集。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gdy26epv7aj30qk0jytbd.jpg)

如图8所示，随着缓冲区大小的增加，开销大致减少。这主要是由于空闲/满缓冲区切换的减少，以及worker thread在同步上花费的时间更少。当缓冲区大小超过了某个值(16核系统为64MB, 4核系统为128MB)，slowdown开始增加。我们将此归因于大的总缓冲区大小(例如，16×256MB)干扰了应用程序的工作集。然后，我们将16核系统的缓冲区大小固定为64MB, 4核系统的缓冲区大小固定为128MB，并改变worker thread的数量。通常，随着更多的worker thread被添加，性能会更好。由于最大的并行度和调优的缓冲区大小，16个具有64MB缓冲区大小的工作线程实现了最佳结果。我们将这两个参数设置为默认配置，并在16核系统上进行了以下实验。

#### 5.3 StraightTaint vs. libdft

我们首先比较StraightTaint与libdft，建立在Pin上的一个最先进的内置DTA工具(图中“libdft”)。为了帮助评估StraightTaint导致的应用程序性能slowdown，我们开发了一个简单的工具(nullpin)来测量Pin的环境运行时开销，它在Pin下运行一个程序，而不进行任何形式的分析(图中“nullpin”)。我们还测量了在「不把配置文件数据缓冲到磁盘」的情况下日志开销(“online-no I/O”栏)。在这种配置下，应用程序永远不会停止等待空闲的配置文件缓冲区，这可以表示StraightTaint所能达到的性能改进的上限。从另一个角度看，“online-no I/O”栏也显示了Pin的插装带来的开销。本节中提供的所有运行时数据都被规范化为应用程序本机执行时间(不运行Pin)。“online”栏是通过计算wall-clock时间（用户时间？）来计算的，因为我们必须考虑缓冲方案引入的I/O时间。其他的栏是通过计算CPU时间来计算的。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gdy2l0fy68j30za0swjyd.jpg)

图9显示了使用参考工作负载运行SPEC CPU2006 int基准测试套件的规范化开销。由于参考工作负载是[cpu密集型](https://blog.csdn.net/youanyyou/article/details/78990156)的，我们希望这些结果能够估计最坏的情况。平均而言，与本机执行相比，StraightTaint的在线日志记录速度要慢3.06倍，而libdft则落后9.96倍，这表明，StraightTaint将应用程序执行速度提高了3.25倍。值得注意的是，如果以nullpin为基准，StraightTaint唯一引入的减速只有1.97X，而libdft是6.43X。这个数字与之前工作的观察结果一致;也就是说，执行一个污点传播操作通常需要6个额外的指令。而StraightTaint的在线插装产生的开销是2.16X(“online-no I/O”bar)，与Pin的环境运行时开销(1.55X)相比，增加了39.4%的额外性能损失。由于有CPU限制的测试套件，StraightTaint不得不付出更多的努力来处理大量的I/O。因此，引入了对“online-no I/O”版本的额外41.7%开销。

平均而言，对于SPEC2006的参考工作负载，StraightTaint生成约2.8GB的原始跟踪分析数据。与原始的4字节标记配置文件大小相比，StraightTaint的相对大小仅为49.2%。一般来说，就更小的分析数据大小而言，StraightTaint比DEP编码性能好5个百分点。值得一提的是，我们看到h264ref基准测试的大小显著降低，从DEP的4.8GB降低到2.1GB。原因是h264ref集中使用了带有rep前缀的指令，这些指令在StraightTaint的优化中处理得非常好。（h264ref是H264/AVC视频编码中使用的压缩标准，这个测试包括baseline和main两个视频配置。）

图9中每个应用程序的最后一栏显示了符号污染分析的性能，它也被规范化为本机执行。由于我们将污染跟踪与程序执行解耦，离线符号污染分析避免了DBI环境和计算资源竞争带来的开销。另一方面，符号污染分析引擎实际上是每个IL的解释器，它比本地执行慢得多。为了缓解这个问题，我们应用了许多优化方法(在4.5节中讨论)。最终的结果是，我们的离线符号污染分析花费的时间与libdft大致相同(StraightTaint平均10.06X, libdft平均9.96X)。在一些情况下(例如，perlbench和h264ref)，StraightTaint的离线部分优于libdft。考虑到StraightTaint的目标是将动态污染分析成本转移到离线分析阶段，这种程度的减速是可以容忍的。在第8节中，我们将讨论进一步加速离线污染分析的几种可能的方法。

#### 5.4 StraightTaint vs. FlowWalker

FlowWalker可能是在其目标上最接近StraightTaint的工作:都是RR风格的离线污点分析。与StraightTaint类似，FlowWalker也在Pin上记录有限的CPU上下文来离线计算内存地址。然而，FlowWalker在在线日志和离线污点分析方面都缺乏细粒度的优化(参见第7节)。在这个实验中，我们在代表三种工作负载的四种常见Linux实用程序上评估了StraightTaint (ST)和FlowWalker (FW)。（SPEC2006的参考工作量太大，FlowWalker无法在合理的时间内得出结果。）程序tar是有I/O限制的，而bzip2和gzip是CPU密集型程序，而scp则是这两种情况之间的中间层。我们使用tar来存档和提取GNU Core utilities 8.13 package (∼50MB)。然后我们应用bzip2和gzip来压缩和解压缩核心实用程序的存档文件。对于scp，我们复制超过1Gbps链接的核心实用程序的存档文件。我们通过SPEC CPU2006实验实现了类似的改进。如图10所示，StraightTaint对本机执行的平均减速为2.48倍，对FlowWalker的平均加速为1.86倍。此外，与FlowWalker相比，StraightTaint的离线污点分析速度快1.14倍。我们将此归因于我们的sub-trace cache和函数摘要优化（4.5中的两个）。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gdy4h9gs51j30zi0ran1i.jpg)

#### 5.5 离线符号污点分析

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gdz5hwjllqj31fk0hkq9k.jpg)

接下来，我们评估了离线符号污点分析在软件攻击检测任务中的准确性。为此，我们使用表1中列出的一组漏洞利用来测试最近的10个软件漏洞。这些测试用例是从[CVE漏洞数据源](http://www.cvedetails.com/)中选择的，有两个标准:1）在二进制代码中标记污点sink的位置很容易，这样我们就可以在同一位置计数污点字节；2）我们有能够触发这些漏洞的exploit（不是所有的CVE漏洞都有相关的exploit）。所有这些应用程序都是使用“gcc -O2”选项编译的。将这些exploits作为输入，我们在每个应用程序上应用StraightTaint，并在各种污点sink(例如，函数返回值)上检查污点tag。在所有情况下，StraightTaint都能成功地检测到攻击，而不会出现漏报。同时，我们在污点分析结束时计算污点(或符号)字节的数量。我们将StraightTaint与Log-all和Pure SE进行了比较。Log-all是在在线日志记录期间记录完整了的运行时数据(例如，每个内存地址和控制传输目标)，然后使用这些数据进行离线污点分析。Log-all表示普通解耦离线污点分析，但其结果是准确的。Pure SE做了符号污点分析，但没有具体的执行状态初始化(参见4.2节)和内存引用地址解析(参见4.3节)。如表1所示，通过StraightTaint添加的污点字节非常接近于Log-all，StraightTaint在后6种情况下，加入了额外的污点字节，但是没有一个超过5%。最可能的情况是，我们处理符号内存索引的保守方法导致了额外的少量污染字节。相反，完全无约束初始状态(纯SE)的符号污点分析会导致污点变量爆炸。由于快速达到内存容量，Pure SE在最后5个测试用例中失败。请注意，我们还确定了14个代码段，这些代码段在不完全污点传播策略的情况下会导致DTA工具失败。图6中显示了一个这样的例子（即不能判断多个污点来源）。相比之下，StraightTaint的全功能离线污染分析在所有情况下都是成功的。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gdza2cji90j30se0m0782.jpg)

最后，我们证明了StraightTaint可以很自然地支持多tag污点分析。我们测试了一个轻量级web服务器，[thttpd](http://acme.com/software/thttpd/)，使用一个400字节大小的HTTP请求作为输入。图11中的x轴数字表示我们分配的不同的污点tag：1个污点tag表示整个400字节被标记为单个污点tag；2个污点tag意味着前200个字节被标记为一个污点tag，后200个字节被标记为另一个污点tag；400个污点tag意味着每个输入字节都与一个不同的污点tag相关联。按照类似的风格，我们每轮改变污点tag的数量。同时，我们比较了两种支持多tag污点分析的DTA工具(Temu[52]和Dytan[14])。每个工具的基线是它们的单标签版本。如图11所示，很明显，随着污点tag数量的增加，Temu和Dytan都会增加高额的额外开销；而在最坏的情况下，StraightTaint只引入1.48X slowdown。请注意，这个评估演示了StraightTaint的另一个值得注意的特性：一旦捕获了日志，就可以对其进行多次分析。在我们的多轮测试中，只需记录一次所需的数据，并在直线代码上执行不同的多tag传播轮。相比之下，Temu和Dytan在每一轮都必须重新运行。

### 6 案例研究：攻击来源分析

由于具有离线分析特性，所以对于事后安全应用程序来说，StraightTaint是一个理想的选择。在本节中，我们将通过对攻击来源调查的案例研究来说明这种方法的优点。其目的是揭示入侵或可疑事件(如信息泄露)的来源。之前的工作[22,24]通过生成连接根本原因和可疑事件的因果图来实现这一点。当然，DTA可以用来精确地生成污点source和污点sink之间的因果关系。我们证明，StraightTaint能够获得与多标签反向传播的DTA类似的精度水平。测试用例是[wget](http://www.gnu.org/software/wget)，一个用于从web检索文件的开源工具。我们使用“wget www.google.com www.bing.com”命令执行wget。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gdzc4g0z0jj30no0mo76e.jpg)

如图12所示，wget接收两个url作为命令行参数，然后下载它们各自的index.html文件(index1.html来自www.google.com, index2.html来自www.bing.com)。假设我们已经下载了这两个文件，一个有趣的问题是“它们究竟来自哪个URL ?”“谷歌，bing还是两者都有?”显然，DTA可以通过使用多个tag进行前向跟踪来精确地识别这种映射。请注意图12中的伪代码：在循环展开时将生成两个文件。因此，静态污染分析没有运行时信息，无法确定source和sink之间的因果关系。

fwrite用于生成HTML文件，我们使用fwrite的输入缓冲区作为符号污点sink。然后，我们应用StraightTaint沿直线跟踪反向污点传播。当然，在没有运行时值和输入的情况下，StraightTaint无法准确地将具体的URL与对应的文件关联起来。然而，与纯静态方法相比，StraightTaint捕获了两个sink和source之间的条件因果关系：第一个下载的文件来自第一个URL输入，第二个文件与第二个URL相关。StraightTaint的条件污染的另一个好处是，我们可以直接将以前的污点分析结果映射到新的输入和运行时值。例如，假设wget的新命令是“wget www.bing.com www.google.com”，利用先前的条件因果关系，我们可以立即得到准确的映射，而不需要再次运行DTA。（静态，具体还要再回顾一下）

### 7 相关工作

**解耦动态污点分析。**为了解决动态污染分析(DTA)的性能瓶颈，提出了两种主要的方法来将污点分析与程序执行解耦。第一类是通过将所需的运行时值交付给另一个运行污点分析的核心来并行化动态污染分析[18、19、31、40、27]。DECAF[18]扩展了Temu[52]来支持异步重量级污点传播。然而，DECAF并没有表现出异步污染带来的性能提升。TaintPipe[27]以管道方式并行化DTA。由于严格的同步要求，第一类中的一些工具采用不完全污点传播策略来跟踪应用程序的执行。第二个方向，如StraightTaint，首先记录应用程序执行，然后在不同的CPU上重播污点分析[15、42、45、48]。与StraightTaint最相关的工作是FlowWalker[15]，它也使用Pin来记录CPU上下文，然后离线执行多tag汇编级污点传播。然而，StraightTaint有两个明显的优点。首先（online），我们设计了一个更简洁的概要文件结构和多线程快速缓冲方案来并行化运行时数据日志。其次（offline），我们的离线污点分析是在一个无副作用的中间语言上执行的，而不是繁琐的x86指令。在我们的评估中，StraightTaint的性能和精度都优于FlowWalker。

正如我们所指出的，由于交换的数据量很大，上述两种方法可能无法实现预期的性能改进。最近，ShadowReplica[19]通过执行一个高级的静态分析来去除冗余的污点逻辑代码，减轻了这种通信开销。在评价中取得了良好的效果。我们的工作不同于ShadowReplica，因为StraightTaint不依赖于对二进制代码的细粒度静态分析。因此，StraightTaint可以应用于逆向工程任务，如恶意软件分析[7,51]和代码反混淆[49]。

**动态符号执行。**与StraightTaint的脱机污染分析相关的另一个领域是动态符号执行，即混合测试concolic testing[4,10,9,17]，这是一种将具体执行与符号执行相结合的方法。StraightTaint与concolic testing类似，我们将符号映射到污染种子，然后沿着记录的执行轨迹执行符号污点分析。此外，StraightTaint还可以从符号执行优化工作中受益，从而加快污点分析，例如记忆符号执行[50]。然而，我们有不同的目标。动态符号执行主要用于自动生成输入，以探索更多的路径，而我们的主要兴趣在于对直线代码进行准确的污点分析。此外，混合测试依赖于完整的运行时信息，而StraightTaint只依赖于有限的运行时信息。最近的工作，Hercules[34]，也提到了使用符号执行来精确跟踪污点的想法。然而，StraightTaint与Hercules有着截然不同的目的。Hercules用于在良性的应用程序二进制中重新生成崩溃；而StraightTaint的设计目的是加速二进制代码上的逆向工程任务。

### 8 讨论和结论

StraightTaint是一个原型，以证明完全解耦动态污点分析是可行的。在线日志和离线污点分析的性能可以进一步提高。目前，我们能够实现的在线日志记录性能的上限受到Pin环境运行时开销的限制。我们未来的工作之一是利用先进的二进制重新组装开发工具包，如Uroboros[43]，这样我们就可以将污点跟踪代码直接插入到被分解的代码中，然后再次将其编译成二进制代码。通过这种方式，我们可以删除DBI的环境开销。由于在StraightTaint中，污点操作的语义是模拟的，所以StraightTaint的离线污点分析平均与DTA一样快，但并不比DTA快。加快脱机污点分析的一个未来工作是，从执行跟踪构造一个可重新编译的直线程序。因此，我们可以直接在直线程序上应用另一轮DTA。目前，StraightTaint适用于顺序程序。为了支持多线程程序的污点分析，我们必须小心处理复杂的线程间污染传播，比如对共享位置的并发访问和相应的污点tag更新。我们计划在未来探索这些方向。

提出了一种完全解耦动态污染分析的新方法——StraightTaint法，用于离线符号污点分析。与以前的方法不同，StraightTaint不依赖于完整的运行时值或输入，这支持非常轻量级的日志记录和更低的在线执行slowdown。StraightTaint还可以支持全功能，多tag，bit级污染分析与低额外的开销。我们已经在一组应用程序上对StraightTaint进行了评估，如实用程序、SPEC2006和现实生活中的软件漏洞。结果表明，StraightTaint可以与动态污点分析在相同的精度水平，但具有更低的在线执行slowdown和更灵活的功能。实验结果表明，利用离线污点分析技术，StraightTaint可以加速各种事后安全应用。

