---
layout:     post
title:      Scalability, Fidelity and Stealth in the DRAKVUF Dynamic Malware Analysis System
subtitle:   ACSAC 2014
date:       2020-03-23
author:     qzwerty
header-img: img/blog-bj-1.png
catalog: true
tags:
    - security analysis



---

## Scalability, Fidelity and Stealth in the DRAKVUF Dynamic Malware Analysis System

DRAKVUF一个新的动态恶意软件分析系统，通过构建最新的硬件虚拟化扩展和Xen hypervisor来解决这些挑战。提出了一种提高隐蔽性的技术，在执行恶意软件样本时不会在分析机器中留下痕迹。还提供了一些新技术来消除内核rootkit创建的盲点，方法是扩大监控范围，包括内核内部函数，并通过内核堆分配来监控文件系统访问。通过对最近的恶意软件样本进行大量测试，我们发现DRAKVUF在保存硬件资源方面取得了显著改进，同时提供了对现代恶意软件行为的隐秘的、更深层次的观察。

### 1 INTRODUCTION

在过去的几十年里，恶意软件已经成为犯罪组织在互联网上进行犯罪活动的主要工具。基于广泛发生的安全漏洞的财务影响，深入了解恶意软件的内部是设计和部署有效的防御解决方案的关键。然而，恶意软件样本的绝对数量构成了一个挑战，这是手工反向工程所无法做到的。使用静态分析来创建快速检测的签名已经被现代恶意软件日益增加的变形特性所有效地削弱了，这种变形特性使得能够在感染之间重组二进制代码。结合反调试技术，制定有效解决方案所花费的时间进一步增加。

随着恶意软件变体的广泛传播，动态恶意软件分析成为一种有效的方法，它通过观察恶意软件样本在隔离环境中的执行情况，来理解和分类恶意软件。正在执行的恶意软件样本和宿主OS之间的交互允许动态恶意软件分析系统收集有助于制定防御步骤的行为特征。因此，动态恶意软件分析依赖于收集数据的广度和保真度。

然而随着动态恶意软件分析系统的广泛部署，恶意软件开始检测和逃避此类系统，通过拒绝在沙箱环境中执行，或者通过修改其运行时行为来导致分析系统偏离。因此，对于动态恶意软件分析系统来说，提供一个隐蔽的环境来隐藏对执行样本的数据收集是很重要的。然而，即使是最近的满足隐蔽需求的分析系统，都具有相当大的资源需求，并需要与恶意软件样本手动交互。这对可伸缩的，自动动态恶意软件分析造成了阻碍。

本文介绍了DRAKVUF动态恶意软件分析系统，旨在利用最新的硬件虚拟化扩展来提供一个透明的可伸缩的环境，并且支持对恶意样本的深入（in-depth）分析。通过构建有效的虚拟化扩展来隐藏监控环境，DRAKVUF深入了解了用户和内核环境中恶意软件的执行情况。此外，DRAKVUF还旨在尽量减少资源需求，主要通过在内存和磁盘上使用写时复制技术，支持快速部署用于分析的虚拟机。

#### Contributions:

* 我们提供了我们的隐形防篡改检测引擎，它提供对用户模式和内核模式恶意软件和rootkit执行的深入研究。[源代码在GPL下](http://drakvuf.com.)。

* 我们引入了一种新的技术来直接监控内核堆分配，从而检测由rootkit创建的隐藏结构。DRAKVUF还可以完全通过内存内省来观察文件系统访问。
* 我们展示了一种新技术，使用主动虚拟机内省来启动恶意软件样本的执行，而不会在分析环境中留下任何痕迹。
* 我们使用共享硬件资源来评估系统，共享硬件资源通过对内存和磁盘写时复制进行大规模的恶意软件分析。
* 我们展示了一组in-the-wild恶意软件样本的详细实验，突出了系统的功能。

论文的其余部分组织如下。在Section 2中，我们建立了我们的需求并概述了我们的系统设计。在Section 3中，我们将提供关于实现的详细信息。Section 4描述了使用最近的、在外传播的恶意软件样本进行的实验，以及系统的性能评估。第5节介绍了相关工作。第6节介绍了今后的工作，最后第7节提供了简短的结语。

### 2 系统设计

DRAKVUF的目标是为自动动态恶意软件分析提供一个平台。分析必须以透明和有效的方式进行，可以深入观察分析虚拟机中的系统组件的运行时行为。DRAKVUF通过虚拟化技术实现，在本文中不考虑对hypervisor（VMM）和更底层系统组件的攻击。在基于虚拟化的恶意软件研究中，标准假设就是认为VMM是可信的，因此在DRAKVUF中我们也考虑了VMM向非特权用户提供的针对不受控制的恶意软件传播的合理屏障。

**系统需要满足以下要求：**

**R1 可伸缩性**：分析一个样本的性能开销应该保持到最小，同时分析大量样本的能力应该最大化。

**R2 保真度**：数据收集方面，必须广泛捕获运行时信息，同时还要提供应对篡改的抵抗力，以便能够准确检查分析系统状态。

**R3 隐蔽性**：被监视的环境不能探测到DRAKVUF的存在。

**R4 隔离**：DRAKVUF需要与分析VM隔离，以免被篡改。

DRAKVUF是使用虚拟化技术实现的，虚拟化对于动态恶意软件分析有以下优点：与直接处理物理虚拟机相比，创建和恢复分析容器可以更快完成。虚拟化还提供了一种观察恶意执行的方法，即虚拟机内省（VMI，virtual machine introspection，从外部访问虚拟化硬件组件的方法）。

![](https://tva1.sinaimg.cn/large/00831rSTgy1gd7mqq4zmzj30xw0noah6.jpg)

DRAKVUF构建在开源的Xen VMM上。系统组件的高级结构如图。为了允许分析VM的快速部署，DRAKVUF通过Xen的本地写时拷贝（CoW）内存接口和Linux逻辑卷管理器（LVM）的写时拷贝磁盘功能创建了完全VM克隆。通过CoW和完全clone VM可以优化硬件的使用，只有在需要时才会分配额外的资源，这满足R1。虽然分析VM的内存和磁盘的静态组件是共享的，CoW可以防止clone VM之间相互交互，因为他们不能访问分配给其他clone VM的独占资源，R4满足。

DRAKVUF运行在控制域dom0，以便能够通过libVMI库使用直接内存访问DMA。在控制域内，DRAKVUF还可以访问hypervisor特征来控制CPU提供的虚拟化扩展，比如扩展页表（Extended Page Tables ，EPT）。为了方便访问与执行vm相关的事件，DRAKVUF使用多种分析技术，在需要时触发将控制转移到hypervisor（VMEXIT）。采用的核心技术是断点注入（breakpoint injection），将一条#BP指令(INT3, 操作码 0xCC)写入VM的内存中需要的代码位置。自动定位这些位置的方法在Section 3.2中进一步说明。通过配置CPU在执行断点时发出VMEXIT并配置Xen将这些事件转发到控制域，DRAKVUF能够捕获分析VM中的任何代码的执行。目前为止#BP注入技术只用于隐蔽调试，在DRAKVUF中，我们首次将它应用于整个操作系统的自动执行跟踪，并展示了他是如何成为激活VMI的关键的。通过这种技术，DRAKVUF可以深入了解内核和用户代码的执行，符合R2。

在以前的研究中，VMEXIT导致的时间偏差已经通过更改guest的时间戳计数寄存器（TSC）而解决了。虽然其他的时间来源也可以使用，尤其是如果允许网络访问，但是在本文中不考虑。在DRAKVUF中我们解决了之前被忽视的问题：在不留下任何痕迹的前提下启动恶意样本的执行：到目前为止，这项任务必须手动执行（这降低了可伸缩性），或者使用in-guest代理（会被检测到）。DRAKVUF克服了这个缺点，支持样本自动执行，不需要使用内部代理。DRAKVUF通过#BP注入，使用活跃的VMI劫持VM中的任意进程来启动恶意软件样本，Section 3.3中详述。通过使用VM中运行的现有进程，DRAKVUF不需要在分析VM中添加新的代码或者组件，实现了R3。

由于恶意软件使用外部输入和资源来运行，还需要给分析VM提供网络访问功能。为了保持DRAKVUF和分析VM之间的隔离，如R4所述，网络流量通过一个运行Open vSwitch的域，从包含使用Intel VT-d传递的物理网卡的VLAN NAT域处退出。clone VM被放置在单独的VLAN上，因此他们唯一的网络访问是通过NAT引擎进行的，NAT主动阻止分析VM在本地网络中发现彼此。这种设计的目的是尽量减少dom0中暴露给被感染的clone VM的接口的组件的数量，因为我们认为与VMM暴露的最小接口相比，仿真设备后端更可能是攻击面。

总结和反思我们的设计需求：通过使用CoW内存和磁盘，以及#BP注入，满足了R1，通过在os代码的关键位置使用#BP注入实现R2，该位置直接显示了运行时环境的状态。通过保护带有EPT权限的断点，并且使用任何in-guest代理，满足R3。从控制域移除网络栈，在Clone vm中使用VLAN隔离，提供了更好的隔离，如R4。

### 3 实现

下面提供DRAKVUF使用的技术的详细实现细节。

#### 3.1 伸缩性

防御解决方案的构建需要对恶意软件样本进行快速分析，但是，需要处理的大量数据带来了挑战。AV vendor？因此在DRAKVUF中我们的重点是将用于分析的物理机器的吞吐量最大化。虽然单个恶意软件样本的执行性能开销也很重要，必须保持在最小，但是在我们看来这种开销只在它主动干扰分析时才需要考虑。在本系统中，我们利用了Xen的CoW内存特性来减少内存需求，使用LVM CoW disk capability来减少宿主机上的硬盘空间需求。通过结合使用这些CoW技术，我们可以大大增加在给定物理机器上并发执行的分析会话的数量。

DRAKVUF使用的CoW技术要求存在一个静态域，这个域的磁盘和内存可以被作为参考点。这样的域称为初始域（origin domain）。初始域一开始是一个普通的域，然后当它被克隆后，初始域就会保持静态冻结状态。当克隆过程开始之后，首先LVM CoW磁盘被设置，然后Xen创建clone VM的域。初始域的内存内容被pipe传递到新创建的克隆域，然后立刻通过共享内存进行内存重复数据删除。内存共享之后，唯一的内存开销是分配给QEMU的内存，用于为克隆vm提供磁盘和网络I/O，以及注入断点的页面。在我们的测试中，使用2GB的CoW内存和CoW磁盘创建一个完整的clone VM在不到10s时间内就完成了。

虽然这种完全的VM克隆具有执行所需硬件资源最少的优势，但是提供对网络的并发访问是一个挑战，因为克隆VM的IP和MAC地址是相同的。当多个这样的clone VM接在同一个交换机上时，就会发生MAC地址冲突，共享IP地址会阻断上层流量的NAT。然而，在VM中重新配置IP栈通常需要使用in-agent代理，这个是要避免使用的。为了克服这个问题，我们使用Open vSwitch来提供VLAN隔离，为每一个clone VM分配一个唯一的VLAN ID。

VLAN NAT使用pcap库构建，pcap库直接从主干接口和uplink读取原始数据包，绕过Linux网络堆栈获得对Layer 2网络信息的访问。有了这个设置，VLAN NAT引擎就能获取clone VM的唯一的VLAN ID。通过使用唯一ID执行NAT，避免了MAC和IP冲突。此外，由于我们不需要使用Linux网络栈，当发出请求预设默认网关时，我们也会将ARP应答注入到每个分析VM的VLAN中。通过动态注入ARP应答，我们不需要在分析VM中设置静态ARP条目。这样消除了静态ARP条目暴露分析环境的可能性，同时为新的分析场景提供了可能性，Section 6会讨论。

#### 3.2 监控

动态恶意软件分析依赖于观察恶意软件的实时执行，所以收集到的数据的保真度（fidelity）是至关重要的。并且，由于rootkit使用各种技术在系统中隐藏自己，所以收集的数据集范围越广，分析就更能发现有用的特征。下面我们讨论在32和64位版本的Windows 7 sp1上实现的一组数据集收集机制。在我们目前的原型系统中主要关注Windows，但是我们的系统可以很容易扩展到Linux和其他系统，因为底层监控和OS无关。

##### 3.2.1 执行跟踪

现有的动态恶意软件分析系统的一个关键特性是通过监控系统调用能够跟踪进程执行。然而，只监控系统调用的话，执行跟踪就会被局限在用户空间程序和内核之间的交互，这并不包括内核模式rootkit的执行。为了解决这个问题，在DRAKVUF中我们采用了另一种方法，通过#BP注入直接跟踪内部内核函数。通过直接捕获，DRAKVUF能够监控恶意驱动和rootkit。

内核函数的位置取决于从内核提供的调试数据中提取的信息。调试信息的使用已经成为取证界的一种既定方法，是了解操作系统状态的最方便的方法。在DRUKVUF中，我们使用Rekall取证工具来解析微软提供的调试数据，以建立内部内核函数的映射。

在运行时，DRAKVUF无需执行基于签名的扫描就可以在内存中自动定位内核，这与现有的取证工具相比提高了弹性。为了自动定位内核在内存中的位置，我们观察到Win7使用FS和GS寄存器来存储一个指向_KPCR结构的内核虚拟地址，这个结构总是加载到内核中的一个固定的相对虚拟地址RVA中，用KiInitialPCR符号标识。由于我们获取了所有内核符号的RVA，只需要从vCPU寄存器中找到的地址减去这个符号的已知RVA，就可以得到内核的基地址。

一旦确定了内核基地址，DRAKVUF就可以通过#BP注入捕获所有的内核函数。内部内核函数被捕获后，生成的日志会提供一个从恶意样本执行开始的os执行的完整跟踪。

##### 3.2.2 处理DKOM攻击

rootkit通过修改内部内核结构来隐藏它们在系统中的存在，即直接内核对象操作（direct kernel object manipulation ，DKOM)。标准的DKOM攻击是通过从内核链表（如正在运行的进程链表）中unhook结构来执行的，有效防止某些工具使用内核链表来依照发现的额外元素枚举结构。取证工具早就发现，在创建windows内核堆中的对象时，附加了一个header(_POOL_HEADER)。这个header包括一个4字符的描述，描述了可以被用于检测被unhook的结构的结构，只需要在物理内存中对这些tag执行强力字符串搜索。

pooltag扫描已经成为取证的标准方法。众所周知，恶意软件会尝试重写header，防止扫描工具随后发现这些结构。其他的rootkit技术隐藏结构的方法是通过将请求的对象大小更改为大于4096KB，从而将分配的对象从header处断开，这样分配请求的结果会被放进big page pool，因为这个header没有被附加给对象。这个技术有效防止了根据指纹扫描基本池tag的方法。

然而，访问这些内部内核结构对于理解系统运行时状态非常重要，因此在DRAKVUF中，我们采用了一种新的方法来处理DKOM攻击。正如我们在攻击方法的描述中看到的，DKOM攻击问题的根本原因是结构的位置在内核堆中未知。如果能够准确地确定位置，DKOM就可以被控制。在DRAKVUF中我们在Windows内核内部函数中通过#BP注入来直接跟踪内核堆分配。这些内核内部函数负责为windows使用的结构分配内存：ExAllocatePoolWithTag和ObCreateObject。DRAKVUF从函数入口的调用线程的堆栈中动态提取返回地址，并且在分配例程返回时捕捉事件。监视堆分配使得我们能够探测所有内核结构的位置，而不会发生恶意软件篡改我们在系统中的视图的情况。

在当前的实现中，DRAKVUF跟踪内核堆上的所有对象的分配，并基于结构的相关tag生成日志。如果结构的tag是已知的2254个tag中的一个，那么日志将包含关于对象类型的详细信息，帮助分析人员识别需要进一步研究的分配。如，为了检测一个隐藏的进程，分析人员可以应用一个交叉视图检查来确定分配的结构是否也可以通过标准列表进行访问。DRAKVUF会进一步捕获释放这些结构的例程，从而全面了解这些结构的生命周期。在下一节中，进一步说明这个方法如何使我们能够跟踪_FILE_OBJECTs的使用情况。

##### 3.2.3 通过内存事件监控文件系统访问

监控文件系统访问是任何动态恶意软件分析系统的核心特征之一，然而，之前的无代理VMI方法试图通过修改磁盘模拟器来拦截事件，这样来监控文件系统访问。虽然这种方法是有效的，但是从低级磁盘模拟的角度重新构造高级文件系统访问（如路径和权限）本身就是一种语义鸿沟问题，需要大量文件系统内部知识。但是，DRAKVUF跟踪的内部内核结构揭示了关于系统执行状态的非常有价值的信息，例如完整的运行进程集、内核模块、线程，甚至OS为文件系统分配的对象。

捕获文件系统访问的过程如图：

![](https://tva1.sinaimg.cn/large/00831rSTgy1gd8vz0kn8gj30oc0tyq9c.jpg)



当操作系统或用户进程访问文件时，在内核堆中分配一个 _FILE_OBJECT ，附带tag"Fil\xe5"。当分配地址被捕获时，我们在EPT中将被分配的页面标记为不可写。由于 _FILE_OBJECT 的前面是一组可选对象header（灰色部分），我们通过从堆分配的末端减去 _FILE_OBJECT 的已知大小来获得访问标志和文件名的确切位置。这样我们就能够决定文件的完整路径以及文件被访问的访问权限，即读、写、删除权限，而不需要对文件本身有更深入的了解。

##### 3.2.4 从内存中删除文件

恶意软件dropper（删除程序）的一个共同特征是在感染过程中快速创建和删除临时文件。这些临时文件可能保存未加壳的恶意二进制文件，这些二进制文件之后会被加载到内存中，或者其他相关的信息。然而，恶意软件的作者很清楚这个事实，在dropper完成下载恶意软件之后，标准的流程是清除这些临时文件。

现有的恶意软件分析系统使用in-guest代理实现，可以在启动文件删除操作时轻松的检索这些文件。从VMI角度来看，检索这些临时文件非常复杂，因为所有硬盘驱动上都启用了windows默认的写缓存。当文件被快速创建和销毁时，文件根本不会被写到磁盘上，这是恶意软件从系统中删除时经常发生的情况。因此简单的将分析VM的磁盘挂载到控制域不会被允许访问这些文件，唯一可能的方案是直接从内存中分割（carve）文件。

#### 3.3 隐蔽

基于虚拟化的分析系统的隐藏通常是在探测监控环境本身的上下文中考虑的，而不是在一般情况下检测虚拟化。这种方法的理由是在商用系统中已经广泛部署了虚拟化， 这从经济上使得恶意软件不排除虚拟化系统。基于这些假设，DRAKVUF扩展了先前的研究，即断点注入和EPT保护的结合使用是一种有效的技术，即使是最先进的反调试技术也不能发现。在先前的实验中，通过改变guest os对硬件时间源的访问，有效解决了VMExit导致的时间偏差问题，但是如果允许网络访问，恶意软件还是可以获取外部时间源。

在DRAKVUF中，我们把注意力转向了一个目前为止在自动动态恶意软件分析中被忽略的关键步骤：我们在不留下监控系统痕迹的前提下启动恶意软件样本。对于使用in-guest组件的系统，可以通过监控代理启动执行，但是这个in-guest组件可以作为探测监控的依据，即使它只是一个自动启动脚本。另一方面，如果没有in-guest代理，样本就必须手动启动。因此，为了避免在分析VM中作修改，并且要允许自动执行，我们实现了一种注入机制，劫持正在VM中积极运行的任意进程，代替我们启动样本。

在Windows中，任何用户空间应用都可以通过CreateProcessA函数创建一个新进程，这是操作系统提供的kernel32.dll库公开的标准Windows API的一部分。虽然不是Windows上的每一个程序都加载了kernel32.dll，但是通常只有很少一部分系统进程例外，因此在实践中DRAKVUF可以劫持任何正常的应用程序。

![](https://tva1.sinaimg.cn/large/00831rSTgy1gdb62lztsij30oa0oiwis.jpg)

如图3，注入机制依赖于一组事件来成功劫持一个线程，而不会导致系统不稳定或者改变系统的状态暴露监控环境。在分析VM创建之后的第一步，DRAKVUF捕获发生在控制寄存器CR3的事件写入，以便捕获上下文切换的发生。当一个事件被捕获，我们通过遍历进程中加载的模块列表，来检查正在运行的进程的地址空间中加载了哪些库。如果进程在地址空间中加载了kernel32.dll，VM的执行就会切换为单步模式，直到进程开始执行用户级代码。

劫持机制劫持用户级执行的第一条指令的执行，并且在kernel32.dll的导出表中定位CreateProcessA例程。更新进程栈，放进调用函数所需的输入参数，以及x86_64上的RCX、RDX、R8和R9寄存器，而RIP的原始内容作为返回地址push到堆栈上。在返回地址处注入一个断点，以便在例程完成之后通知我们。将CreateProcessA的地址放入RIP后，分析VM的执行被恢复。

当返回断点命中时，我们可以通过检查RAX寄存器来确定进程是否成功创建。如果成功，我们还可以获得进程的PID和句柄信息，这些信息将被正在执行的恶意软件样本使用。由于在执行CreateProcessA时可能会发生上下文切换，因此返回陷阱检查位于返回陷阱的进程是否是被劫持的进程。在恢复劫持进程的原始执行之前，堆栈和vCPU寄存器将被恢复，从而无缝的恢复进程的执行。

在我们的实现中，我们使用这个机制在干净的虚拟机中启动恶意软件样本。通过使用劫持例程，不会在系统中添加会被探测到作为监控环境的组件。如果恶意软件样本在已经被感染的机器中启动，这个定律不适用，本实现不考虑。

### 4 实验结果

接下来讨论一组广泛的实验，这些实验用于建立性能指标和评估系统的有效性和吞吐量。实验是在Intel 2代i7-2600 3.4GHz CPU上进行。

除非另有说明，这些示例是在运行时间为60秒的Windows SP1 x64分析平台上执行的。在这些测试中，DRAKVUF被设置为监视每个Nt或Zw开头的每个内部内核函数的执行。Nt开头的函数是用户空间程序可以通过SSDT中列出的常规系统调用获得的函数，监控这些函数的Zw版本可以发现内核级代码的执行。我们还捕获了另外两个内核内部函数，ExAllocatePoolWithTag和ObCreateObject，他们负责内核堆的分配，如Section 3.3.2所述。虽然在这些测试期间监视所有的内部函数是可能的，但是我们减少了跟踪的范围，以在不影响对系统执行进行深入了解的前提下，防止收集数据过于冗长。

#### 4.1 TDL4

我们测试的第一个样本是TDL4。之所以选择这个样本，是因为一个反病毒公司已经对样本进行逆向工程，并创建了一个深入的技术报告，可以与我们的自动分析形成对比。dropper本身在VirusTotal (VT)上的检测率是45/46。在Windows 7 SP1 x64分析VM中执行样本后，我们得到了两个由dropper在C: \ Windows \ System32 \ sysrep创建的两个临时文件：cryptbase.dll和syssetup.dll。

这些临时文件被从内存中分割出来，因为他们是由dropper创建的，直到被删除都没有被flush到磁盘。向VT提交文件后，检出率分别为19/50和22/50.在最初的分析报告中没有提到这些临时文件的性质，但进一步调查发现，它们是通过绕过Windows7和8上的用户访问控制（UAC）来提高权限的一种已知方法的一部分。在该漏洞安装了payload后，系统开始关闭，此时分配给VM的2GB内存中有1.1GB仍然是共享的。

#### 4.2 Zeus

Zeus的VM检测率是44/50。在我们的分析中没有文件被删除。然而在我们的日志中，我们看到样本和一个临时文件夹中的文件交互，GoogleUpdate.exe的VT检测率为43/50，FlashPlayer.exe没有被VT探测到，被识别为一个真正的Adobe installer。DLL也位于临时文件夹msimg32.dll中，VT检测率25/47，这是之前从来没被提交过的。我们的日志显示，在此之后正在执行的flash player installer 将DLL放入\ Windows \ System32中。样本的安装行为与ZeroAccess中的非常接近，HP也分析过。执行样本60秒后，分析VM有1.4GB内存处于共享状态。

#### 4.3 ShadowServer的样本

为了大规模测试DRAKVUF，我们从ShadowServer获取了1000个最近的恶意样本。这些样本具有AlienVault YARA签名，即使用了虚拟化技术。

在1000个样本中，24个未能通过CreateProcessA注入执行。执行失败的原因不是因为恶意软件自己关闭了，而是因为Windows不能执行样本。平均的说，在60秒的执行时间里，有159222个断点被命中，平均有67950个pool分配请求。

![](https://tva1.sinaimg.cn/large/00831rSTgy1gddg25alb6j30zy0tujxi.jpg)

图4显示了在所有样本中命中的前10个API调用，以及前3个样本中用于堆分配的内部函数（这句实在没看懂）。从这个图中我们可以看到，一些内部内核函数被执行的概率要高得多，因此允许分析人员依照分析目标选择所需要的函数，如我们的实验中所示。

通过在删除之前分割他们，从分析VM中一共提取了8797个不同的文件。为了更好地理解分析VM中被删除文件的性质，我们根据文件的类型对他们进行了整理，如图5。1412个PE文件也提交给了VT。有561个新提交的（39%），几乎所有的文件都至少有一个AV检测（反病毒检测）。平均只有20.4%的AV把他们归类为恶意软件。

![](https://tva1.sinaimg.cn/large/00831rSTgy1gdemaiwhp3j30o60gywhm.jpg)

#### 4.4 测量开销和吞吐量

在本节中，我们将注意力转移到测量系统开销上，系统开销是为任何监视引擎计算的标准度量，另外还测量了我们实现的有效吞吐量。

为了说明系统开销的来源，我们测量了在捕获所有的内部内核函数时，由我们的监视触发的VMExit的数量。通过使用Windows 7 SP1的调试符号，x86的所有内部函数10853个，以及x86_64的11011个函数被捕获。捕获的内容通过EPT的execute-only权限进行保护，x86上捕获了727页，x86_64捕获了915页。VM运行了60s，正在空闲运行，只有默认的Windows系统进程处于活动状态。如图6，断点是我们两个版本的Windows触发VM中VMExit的主要原因。

![](https://tva1.sinaimg.cn/large/00831rSTgy1gdedg474w9j31060s443k.jpg)

为了测量#BP注入引起的VMExit所带来的CPU循环的开销，我们使用了一个与SPIDER类似的测试标记。测试包括监控域在一个循环内调用一个函数，函数带有计数器。循环从 10^4 迭代到 10^6 ，步长为 10^4。通过在循环前后读取TSC寄存器来收集时间信息。benchmark是执行时是否在函数入口点捕获，以确定开销。这样测量的平均开销为10502，与SPIDER中的开销相当。开销的差异可能来源于不同的hypervisor，DRAKVUF的Xen和SPIDER中的KVM，因为按照设计，Xen需要为每个转发到控制域的trap提供额外的VMEntry/VMExit。

这两个实验都表明，我们的方法在单个样本的分析上增加了可接受的开销。在我们看来，基于单个样本的开销是动态恶意软件分析存在的一个隐蔽性问题。开销不应该暴露监控环境。

从伸缩性的角度看，系统的吞吐量是特别重要的，我们将根据Section 4.3中描述的实验数据对其进行进一步评估。我们系统中的主要硬件限制是可用RAM的数量：16GB。考虑到运行Windows 7推荐的标准是2GB，使用现有开源工具并发会话的最大数量将被限制在8个会话（不包括分配给控制域的内存）。在我们的实验中，我们通过CoW内存平均实现了62.4%的有效内存节约，标准偏差为7.3%。将节省的内存用作并发会话，如图7，我们可以看到通过CoW内存可以实现的即时内存节约（黑色区域）。在我们的例子中，并发分析会话的数量提高了两倍，显著提高了吞吐量。

![](https://tva1.sinaimg.cn/large/00831rSTgy1gdedee38znj30wb0u0ah6.jpg)

### 5 相关工作

![](https://tva1.sinaimg.cn/large/00831rSTgy1gdedmka0wej30v20u0k6o.jpg)

![](https://tva1.sinaimg.cn/large/00831rSTgy1gdedk4frefj30wk06macq.jpg)

![](https://tva1.sinaimg.cn/large/00831rSTgy1gdedln3e67j30wa0do44x.jpg)

### 6 Future Work

尽管动态恶意软件分析系统可以减轻分析不断增加的样本数量的负担，但是该方法的固有限制是，样本的执行是不确定的。恶意软件样本是否在给定的时间内显示出真正的恶意本质（即脱壳还是只是延迟），这件事是不能确定的。尽管近期的工作提出了这样的希望：如果考虑到时间和空间的限制，这个问题可能有一天会变成可解决的。未来可以集成到DRAKVUF的可能解决方案是，通过对VM的频繁快照进行多路径探索，以及通过基于VMI的流量控制改变进行延迟（stall）预防。（stall到底是不是install？？）

在VLAN NAT引擎中访问第二层网络信息为新的恶意软件评估场景打开了大门。虽然在我们当前的设置中，路由引擎只在请求为默认网关时注入ARP应答，但我们也可以将ARP应答注入到请求的任何本地IP。通过进一步集成路由引擎和DRAKVUF，我们可以部署一个新的分析VM来构建动态局域网环境，提供一个简单的设置，来测试恶意软件如何在局域网中传播。

分析VM的内存共享当前是在恶意软件样本执行之前进行的，因此随着分析VM的执行，内存剩余将会逐渐减少。但是，可以通过捕获对guest页表的更新并且评估哪些物理页可以安全地进行重复数据的删除来执行更积极的内存共享。这种方法还可以让我们能够重新启动分析VM，在某些情况下这是触发感染执行所必须的，而不会放弃内存共享的优点。

我们的流程注入机制侧重于在克隆VM创建之前将样本放在磁盘上来启动恶意样本执行。虽然这种方法在我们的原型中是实用的，但是在将来的工作中我们计划通过使用process hollowing techniques将恶意二进制代码直接放入内存中。

DRAKVUF目前遵循的是恶意软件执行的单一路径。由于恶意软件可能正在寻找某些条件来执行或展现恶意行为，因此通过监视样本执行的检查可以用于潜在地探索多个执行路径。

### 7 结论

本文介绍了一种新型的动态恶意软件分析系统——DRAKVUF。在DRAKVUF中我们引进了一些新的技术来提高恶意软件分析的可伸缩性、保真度和隐蔽性，通过构建最新的hypervisor技术和硬件虚拟化扩展。通过监控内核内部的功能，DRAKVUF可以全面的了解用户和内核空间的恶意软件行为。使用活跃的VMI来劫持分析VM中的任意进程，可以在不留下任何痕迹的情况下启动恶意软件样本的执行。DRAKVUF还展示了「通过内存自省跟踪文件系统访问」和「从不会flush到磁盘的临时文件中提取」的独特功能。在我们的实验中，我们使用了广泛的现实环境中的恶意软件样本来评估DRAKVUF。这些实验表明，该系统不仅能够有效分析现代恶意软件，而且能够通过最大化在共享物理硬件上运行的并发分析会话的数量来提高硬件利用率。