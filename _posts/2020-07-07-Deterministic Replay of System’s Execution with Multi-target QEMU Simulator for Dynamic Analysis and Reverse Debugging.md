---
layout:     post
title:      Deterministic Replay of System’s Execution with Multi-target QEMU Simulator for Dynamic Analysis and Reverse Debugging
subtitle:   (CSMR'12)
date:       2020-07-07
author:     qzwerty
header-img: img/blog-bj-1.png
catalog: true
tags:
    - RR security


---

## Deterministic Replay of System’s Execution with Multi-target QEMU Simulator for Dynamic Analysis and Reverse Debugging

### 1 INTRODUCTION

确定性重放是一种技术，它允许捕获正在运行的虚拟机的执行情况，以便稍后重放。它对于调试不容易再次产生的故障、捕获执行跟踪、软件的动态分析等等都很有用。

以下是难以再次产生的bug的例子:

-非确定性bug，例如，由不同线程或应用程序的竞争引起。当bug被记录下来时，它可以一次又一次地重播，因此，它不再是非确定性的。

-伪不确定性bug，即再次产生bug的过程不明确。可使用记录日志代替错误描述再现过程。

-在复杂环境中出现的bug。如。远程进程通信中的bug。复杂的环境不需要在每次调试会话之前重新准备，因为所有的交互都记录在事件日志中。

——Heisenbugs。这些错误无法在调试器中找到，但可以记录并回放，以便在不影响被检查机器行为的情况下进行检查。

-内存损坏bug。确定性重放可以帮助调试这些错误，因为损坏的内存不会在每次运行中改变它的位置，并且可以检查程序以找到损坏内存的代码。

这些例子说明了确定性重放如何在软件开发中使用。但是这种技术在软件分析中也很有用，例如，为应用程序的动态分析生成执行跟踪。

本文介绍了针对多个目标平台的QEMU模拟器中全系统日志记录和确定性重放机制的设计与实现。

### 2 RELATED WORK

VMWare[9]和ExecRecorder[6]已经实现了对整个系统执行过程确定性重放的软件日志。但是它们只对32位x86系统支持确定性重放。VMWare也不提供任何在其基础上实现动态分析工具的机制。ExecRecorder基于慢Bochs模拟器，不支持保存重播日志供以后使用。

[4]中描述的时间旅行虚拟机还使用非确定性事件的日志记录和检查点虚拟机状态来进行确定性重放和反向调试。但是这个系统只支持x86上的Linux作为目标系统。

大多数其他现有的软件解决方案支持对单个应用程序的确定性重放，而不是对整个系统的确定性重放。这导致了不同的限制:支持特定平台、弱多线程支持、支持的系统调用数量有限、只记录用户级代码，等等[2]、[3]、[5]、[7]、[8]、[11]。

我们的方法不同于现有的方法。它通过使用被执行软件的确定性记录/回放支持非侵入式的整个系统动态分析。确定性记录/回放实现了几个目标平台——x86、x64和ARM。我们的解决方案保存重放日志，允许不同的人在不同的计算机上重放它。

### 3 EXPECTED BENEFITS

在全系统模拟器QEMU中实现确定性重放有以下好处:

QEMU是开源的。用户需要的任何机制都可以添加到模拟器中(例如为动态分析收集执行跟踪)

QEMU支持许多平台(不仅仅是x86)。要为任何受支持的平台实现确定性重放机制，都需要进行较小的更改，因为大多数确定性重放代码都是与目标无关的。

全系统的确定性重放允许调试系统级代码(如内部操作系统例程)和多线程应用程序。

-通过模拟器调试是非侵入性的。这意味着在模拟器中重放执行日志的同时调试程序不会影响程序的行为。

-确定性重放的所有其他好处。执行日志可以记录在一台机器上(由一个人，例如测试人员)并在另一台机器上(由其他人，例如开发人员)回放，执行场景可以记录一次并多次调试，非确定性输入，如网络包可以确定地回放等等。

### 4 DESCRIPTION OF THE METHOD

我们的确定性重放方法是基于现有的开源模拟器QEMU[1]，[10]。在本章中，我们介绍了模拟器的结构和确定性记录/重放机制的设计与实现。

#### A.模拟器结构

QEMU是一个模拟器，它使用模拟代码的jit转换。QEMU将guest二进制代码转换为主机二进制代码，然后执行它。每个客户机器指令都被转换为一系列主机指令，这些主机指令模拟客户机器的行为。

模拟器将已翻译的指令连接成翻译块。翻译块是一个连续的指令序列。它意味着块的执行总是从第一个指令开始，到最后一个指令结束。翻译块的大小有上限，因为固定大小的内存区域用于存储翻译块。

模拟器本身由几个逻辑块组成，包括主循环（main loop）、转换块（translation block）、执行块（execution block）、外设驱动程序（drivers for peripheral devices）和中断处理块（blocks for interrupts handling）。

主循环调用执行块，如果模拟代码之前没有转换，执行块将调用转换函数，或者从缓存中获取转换结果。

翻译完成时(或在缓存中找到翻译块)，控制被传递给翻译后的代码。有时中断块会停止执行，并调用仿真(如HDD)和外部(如键盘)设备的驱动程序。在处理来自设备的事件之后，主循环继续执行。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggjspg9aklj30x40ruaci.jpg)

在这个方案中，只有一个平台相关的部分——执行二进制转换的组件。它是针对x86、x64、PowerPC、ARM等处理器实现的，以支持对这些平台的模拟。

#### B .确定性重放
我们的记录/回放系统是基于保存和回放非确定性事件(如键盘输入)和模拟确定性事件(如从硬盘驱动器或VM内存读取)。只保存非确定性事件可以使日志文件更小，模拟速度更快，甚至允许对网络应用程序使用反向调试。

以下来自外围设备的非确定性数据被保存到日志中:鼠标和键盘输入、网络包、音频控制器输入和硬件时钟(它们也是非确定性的，因为它们的值取自主机)。来自模拟硬件、VM内存、软件中断和指令执行的输入不会保存到日志中，因为它们是确定性的，可以通过模拟虚拟机从初始状态开始的行为来回放。

我们必须解决三个任务来实现确定性重放:记录非确定性事件，重放非确定性事件，检查记录和重放模式之间没有差异。

为了记录和回放事件日志，我们修改了QEMU的几个部分:独立于平台的执行循环、独立于平台的硬件驱动程序和依赖于平台的转换机制。

具有外部设备非确定性输入的设备驱动程序被更改为立即将每个外部事件写入执行日志。例如，当网络数据包到达虚拟网络适配器时，它们被写入日志。

所有的非确定性事件都来自于这些驱动。但要重现它们，我们需要知道它们是在什么时候发生的。我们通过计算每对连续事件之间执行的指令数量来指定这些时刻。我们为x86、x64和ARM平台更改了二进制转换程序，以进行这样的计数。

更换翻译器是一个挑战。在记录和回放模式中，二进制转换器生成的代码是不同的，因为在这些模式中需要不同的附加操作。为这段代码分配的内存块的大小在两种模式下是相同的，这就是为什么在记录和回放模式下转换块的大小(在客户指令中测量)是不同的。在QEMU中进行更改之前，中断处理只在转换块的边界上进行，我们可以看到虚拟机在记录和回放模式下存在行为差异。

为了解决这个问题，我们增加了一个事件中断处理。重播模式下的转换器添加控制此事件发生的特殊检查。如果事件发生在块的中间，则执行中断，并执行中断处理。这段代码使重放完全具有确定性，但增加了记录和重放过程的一些slowdown。

在我们的模型中，磁盘I/O事件是完全确定的，因为在记录和重放模式中，我们从相同的磁盘状态启动虚拟机。

为了确保重放过程是确定的，我们的实现检查QEMU执行的预期事件(例如读取计时器、软件中断)是否以正确的顺序来自日志。如果模拟器的当前状态中不期望发生这些事件，那么它将立即停止。

#### C.逆向调试实现

逆向调试是指在执行过程中反向执行的能力。有了逆向调试，程序员可以停止在一个选定的执行点(例如，无效指针解引用异常发生的地方)，检查寄存器和内存，并继续向后执行程序(例如，到最后一个位置，指针被写入的地方)。

QEMU原生支持通过远程接口与gdb进行调试。它支持断点、观察点、单步执行和其他常见的调试命令。

我们在QEMU中添加了对逆向调试命令(逆向步骤、逆向继续)(reverse step, reverse continue)的支持，在确定性重放模式下工作。reverse step执行后退一步(继续执行之前执行的指令)。reverse continue查找当前步骤之前命中的最新断点。

这两个命令都使用加载以前保存的虚拟机状态。我们改进了QEMU的检查点:它在执行开始时保存一个状态，然后每N秒(其中N是参数)设置一个检查点。可以禁用定期状态保存，但初始状态是必须的。这些检查点用于返回执行过程。

加载上一个状态后，模拟器向前运行以查找所需的点(对于Reverse step)或检查命中的所有断点(对于Reverse continue)。Reverse step命令不需要更多的操作，但是Reverse continue执行额外的操作。在到达用户停止执行的位置后，reverse continue再次重新运行执行，以到达所命中的最新断点。

要进行反向调试，用户必须向调试器发出命令。我们对QEMU进行了修改，以自动执行所有需要的操作(例如，加载之前保存的状态和两次执行以反向继续)。

### 5 DEBUGGING WITH DETERMINISTIC REPLAY

使用确定性重放，我们可以多次调试单个错误重现场景，因为导致此错误发生的外部事件的确定性发生。

具有确定性重放的调试包括两个阶段:

1. 捕获应该调试的执行日志(例如，可以看到bug的用例)。这个步骤由测试人员执行。虚拟机记录的执行日志描述了错误再现的过程。

2. 回放执行日志并揭示错误。开发人员从测试人员那里接收执行日志，并在自己的计算机上回放。他不需要bug重现过程的详细描述，因为执行日志包含了它的所有步骤。

我们的实现支持系统执行的完全确定性重放，在任何步骤，断点停止/启动客户系统，通过gdb远程接口向前和反向调试。

虚拟机可以连接到主机的网络或其他虚拟机来调试网络应用程序。所有收到的网络数据包将以记录模式写入事件日志。当回放事件日志时，虚拟机将实际接收记录的网络数据。

### VI. DYNAMIC ANALYSIS WITH DETERMINISTIC REPLAY

确定性重放可以用作不同动态分析工具的基础。我们已经实现了在重放日志时从虚拟机收集指令级执行跟踪的工具。此跟踪包含为每个执行指令保存的处理器状态。这种捕获模式下的虚拟机比正常执行模式下慢120倍。因此，我们无法在“live”虚拟机上获得网络和其他时间关键型应用程序的跟踪。

但是，当我们将所有网络(和其他非确定性)事件记录到日志中时，我们可以通过在重播模式下运行来保存此场景的执行跟踪。重放模式中的减速并不重要，因为所有非确定性事件(包括计时器、与用户和网络的交互)都已经保存到日志中，可以准确地重放。

### VII. RESULTS

取得了以下成果:

-对x86、x64和ARM目标平台实现了确定性记录/回放。

-在网络环境下测试Windows和Linux作为客户操作系统进行确定性重放。

-在重播模式可以调试和分析实时网络应用程序，因为在记录模式保存了所有传入的网络数据包到事件日志。

-与虚拟机的正常执行相比，日志记录进程提供了合理的减速(3-8倍，取决于应用程序运行和虚拟机配置)。这样的减速不会影响到大多数的应用程序，包括网络应用程序(例如，记录/回放机制与Skype即时消息服务测试)。

-日志回放速度几乎与日志记录相同。但此过程的减速不会影响任何内容，因为所有非确定性事件都已保存在日志中。虚拟机中的代码甚至可以在单步模式下执行。

-事件日志需要大约30 kb/秒的磁盘空间(在加载Windows XP时测量)，这与其他确定性重放[4]、[6]的实现相当。

-确定性重放允许在QEMU中使用time travel和反向调试。执行过程可以向前或向后运行，代码执行可以撤消，gdb反向调试可以与修改的QEMU一起使用。

### VIII. CONCLUSIONS AND FUTURE WORK

我们在多平台模拟器QEMU中实现了确定性重放机制。该机制在x86、x64和ARM目标平台上进行了测试。为了进行时间旅行调试、动态分析和反向调试，它允许确定性地重放已记录的应用程序执行场景。

有些应用程序对虚拟机的性能很敏感。这就是为什么我们不能捕获正常执行模式下的执行轨迹。这就是为什么我们使用确定性重放来捕获这类应用程序的执行轨迹。

由于QEMU支持其他平台(如PowerPC和MIPS)，我们计划修改确定性重放以支持它们。我们希望为每个平台实现确定性重放不会花费超过1人月的时间，因为我们在QEMU中所做的大部分更改都应用于平台独立的部分。

我们还实现了时间旅行调试和完全反向调试支持。我们在QEMU中添加了对所有gdb的反向调试命令的支持，包括反向观察点和断点。这些命令自动重用记录的执行日志。

减少保存的日志大小是我们的目标之一。我们计划减少所需的磁盘空间，从而使日志从一台机器迁移到另一台机器更方便，因为它的大小更小。

提高仿真速度也是一个挑战。当前的日志保存/回放的实现导致虚拟机的速度降低3-8倍。大多数应用程序不会受到这种减速的影响，但是更快的执行对用户来说更方便。

我们还计划研究通过修改事件日志中保存的数据包来fuzz网络协议。