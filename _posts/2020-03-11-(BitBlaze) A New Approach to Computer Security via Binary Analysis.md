---
layout:     post
title:      (BitBlaze) A New Approach to Computer Security via Binary Analysis
subtitle:   ICISS 2008
date:       2020-03-11
author:     qzwerty
header-img: img/blog-bj-1.png
catalog: true
tags:
    - security analysis


---

## (BitBlaze) A New Approach to Computer Security via Binary Analysis

> BitBlaze是一个通过二进制分析来实现计算机安全的新方法。特别关注于构建一个统一的二进制分析平台，并使用它来为各种不同的安全问题提供新的解决方案。二进制分析平台的设计目的是支持准确的分析，提供可扩展的体系结构，并结合静态和动态分析以及程序验证技术，以满足安全应用程序的常见需求。通过直接从二进制程序中提取出与安全相关的属性，BitBlaze提供了一种原则性的、基于root-cause的方法，保护计算机安全，提供了新颖而有效的解决方案。

> keywords：二进制分析，恶意软件分析与防御，漏洞分析与防御，逆向工程

### 1 INTRODUCTION

对于许多安全问题，他们的根本原因和解决方案的关键直接在于相关的程序（如脆弱性程序和恶意代码）。通过设计开发技术和工具，从程序和解决方案中自动提取与安全相关的属性，我们可以启用一种原则性的方法处理很多安全问题，关注根本原因，提供比先前的方法（依赖于启发式或者攻击症状）更有效的方法。

要实现上述方法的一个技术挑战是对于安全应用程序，通常需要直接处理二进制代码。对于许多程序，如off-the-shelf（COTS）程序，用户不能访问它们的源代码。对于恶意代码攻击，攻击者可以不将源代码附加到攻击中，只执行二进制代码。所以说分析二进制代码将为安全应用程序提供重要事实，而分析员代码可能由于编译器错误和优化而分析错误。但是由于二进制代码的复杂性和缺乏高级语义信息，二进制代码分析极具挑战。对于通用安全应用程序的二进制分析工具很少。这是不能使用root-cause based方法的阻碍。

BitBlaze建立了一个统一的二进制分析平台，并使用它来为各种不同的安全问题提供新的解决方案。

本文描述BitBlaze的两个主要研究方向：

* 针对安全应用程序的统一、可扩展的二进制分析基础架构设计与开发

* 采用原则性的，root-cause based approach（由我们的二进制分析框架支持），能够解决不同安全问题的创新方法

本文剩下的部分描述了BitBlaze二进制分析平台的挑战和设计原理，然后描述了它的总体架构，三个主要的组件，Vine，TEMU，Rudder。最后概述使用BitBlaze二进制分析平台启用的不同的安全应用程序，讨论了相关工作。

### 2 BitBlaze Binary Analysis Platform的结构

首先描述了二进制分析安全应用程序的挑战，然后描述了满足安全应用程序的二进制分析平台的期望属性，最后描述了BitBlaze的体系结构。

#### 2.1 挑战

二进制代码分析面临的挑战。其中一些是特定于安全应用程序的。

1. **complexity**。二进制代码很复杂。为了分析准确，二进制分析需要精准地对复杂性进行建模。然而，现代体系结构中指令的绝对数量和复杂性使得精确建模成为重大挑战。流行的现代体系结构通常有数百个不同的指令，每个处理器版本都添加了新的指令。此外，每条指令都可能具有复杂的语义，比如单个指令循环，根据操作数值有不同行为的指令，以及隐式的副作用，如设置处理器标志。比如说，描述x86语义的IA-32手册重量超过11磅。（？

考虑下面的x86汇编程序的确定控制流的问题：
![](https://tva1.sinaimg.cn/large/00831rSTgy1gcq70732yqj30qg052q3i.jpg)
先计算a := a + b，然后计算a := a << x。如果设置了处理器 zero flag，会跳转到地址a。

一个问题是，add和shl都有隐式的副作用。这两个指令都额外计算最多6 bit的信息，作为处理器状态标志保存。特别的，它们计算结果是否为0，结果的奇偶性，是否有辅助进位，是否对结果签名，是否发生溢出。

条件控制流，如jz指令，是由隐式计算的处理器flag决定的。因此，要么是add指令计算zero标志，要么是shl计算。然而，到底是add还是shl来决定分支呢？这个问题很难。根据操作数不同，shl指令行为也不同：他只在x不为0的时候更新zero标志。

2. **Lack of Higher-Level Sementics**。二进制代码与源代码不同，尤其是缺乏源代码中的高级语义。因此需要开发适合二进制代码设置（通常调试信息是不可用的）的程序分析技术和工具。尤其是，二进制代码缺乏抽象概念（abstractions），而这些是源代码和源代码分析的基础。

**abstractions：**

* **没有函数（functions）**。二进制程序中的控制流是通过跳转来执行的。例如，x86指令 `call x`只是「将当前指令指针（寄存器`eip`）存储在寄存器`esp`指定的地址上，根据体系结构字长递减`esp`，然后把数字x放入`eip`」的一种简写。实际上，它在汇编中是完全有效的，在实际中也会发生这种情况，代码可能调用一个“函数”的中间部分，或者将单个“函数”分隔成不相邻的部分。
* **内存 vs 缓冲区**。二进制代码没有缓冲区，它有内存。虽然操作系统可能判定某个特定内存页无效，但内存没有「用户指定的类型和大小」的语义。缓冲区和内存之间的区别意味着，二进制代码中不存在缓冲区溢出。虽然我们可以说一个特定的存储违反了源代码提供的高级语义，但这是高级语义层面的事，不是二进制代码本身的一部分。
* **没有类型**。不能创建或使用新类型，因为二进制代码中没有类型构造函数。唯一可用的类型是硬件提供的，寄存器和内存。然而寄存器类型不一定能提供有用的信息，因为通常会把值存储在一种寄存器类型（如32bit寄存器）中，然后从另一种寄存器类型（如8bit寄存器）中读。

总的来说，特定于汇编的方法（assembly-speciﬁc approach）不好，因为在现代复杂指令上编写分析往往是冗长和容易出错的。在如此庞大而复杂的指令集中验证程序分析是否正确更困难。另外，assembly-speciﬁc approach是特定于单个架构的。每次想要考虑新的架构时，所有的分析必须移植。因此，无法利用不同汇编语言的公共语义。（没看懂- =）

3. **全系统视图**。许多安全应用程序需要能够分析操作系统内核中的操作和多个进程之间的交互。需要一个完整的系统视图，比传统单程序分析面临更大挑战。

4. **代码混淆**。一些安全应用程序需要分析恶意代码。恶意代码可能使用诸如packing，加密，混淆等反分析技术增加分析难度。

#### 2.2 设计原理

BitBlaze二进制分析平台的目标是设计开发技术和核心实用程序，以满足安全应用程序的共同需求，并使其他人能够更容易、更有效地构建和开发安全问题的新解决方案。

**设计准则：**

* **准确性**。希望能够进行准确的分析，从而激励我们构建精确的、正式的指令模型，从而允许工具对程序执行行为符号化的精确建模。
* **可扩展性**。考虑到二进制分析的复杂性，希望开发核心实用程序（core utilities）。这些实用程序可以被重用，并且容易扩展，以支持对二进制更复杂的分析，或者很容易针对不同体系结构重新定位。
* **静态和动态分析的融合**。静态分析和动态分析各有利弊。静态分析可以提供更完整的结果，因为它涵盖了不同的执行路径。但是，由于指针别名的复杂性、间接跳转的普遍性、二进制文件中缺少类型（type）和高级抽象概念，这可能比较困难。即便是静态区分代码和数据都是一个无法确定的问题。此外，对于静态分析来说，处理动态生成的代码和恶意代码中使用的反静态技术也很具有挑战性。还有，某些指令（如内核指令和浮动指令）可能很难精准建模。另一方面，动态分析很自然地避免了静态分析需要面对的很多困难，代价是一次只能分析一条路线。希望将静态和动态分析结合起来。

#### 2.3 架构

![](https://tva1.sinaimg.cn/large/00831rSTgy1gcsh8uwaw8j30lk080aaj.jpg)
BitBlaze二进制分析平台由三个部分组成：Vine，静态分析部分；TEMU，动态分析部分；Rudder，动静结合的混合具体分析和符号分析部分。

* Vine将汇编语言翻译成一种简单的、正式指定的中间语言（IL），并提供一组用于IL上常见静态分析的核心实用程序，如控制流，数据流，优化，符号执行和最弱前置条件计算。
* TEMU执行全系统动态分析，支持全系统细粒度监视和动态二进制检测。它提供了一组核心实用程序，用于提取os级语义、用户定义的动态污染分析和用户定义活动的干净的插件接口。
* Rudder使用Vine和TEMU提供的核心功能来实现二进制级别的混合具体执行和符号执行。对于给定的程序执行路径，它标识符号路径谓词，符号输入需要满足这些谓词才能跟随程序路径。通过查询诸如决策过程之类的求解程序，它可以确定路径是否可行，以及什么输入可以导致程序执行遵循给定的路径。因此，Rudder可以自动生成输入，引导程序沿着不同的路径执行，探索程序执行空间的不同部分。Rudder提供了一组核心实用程序和接口，使用户能够进行快照和重新加载探索状态，并提供用户指定的路径选择状态。

### 3 Vine：静态分析组件

本节概述Vine组件的中间语言（Intermediate Language ，IL）、前端和后端组件，以及实现。

#### 3.1 Vine概述

![](https://tva1.sinaimg.cn/large/00831rSTgy1gcsiiyxm5qj30kw07eq44.jpg)
Vine静态分析组件分为特定于平台的前端和独立于平台的后端。Vine的核心是一个独立于平台的汇编中间语言（IL）。IL被设计成一种小而正式的指定语言（small and formally speciﬁed language），忠实地表示汇编语言。底层架构中的汇编指令通过Vine前端提升到Vine IL。所有后端分析都在平台无关的IL上执行。因此，程序分析可以以独立于体系结构的方式编写，并且不需要直接处理x86等指令集的复杂性。这种设计还提供了可扩展性——通过构建Vine中的核心实用程序，用户可以轻松在IL上编写自己的分析。

Vine前端分析目前支持x86和ARMv4到IL的转换。它使用一组第三方库来解析不同的二进制格式并生成程序集。然后以语法指导（syntax-directed manner）的方式将汇编语言翻译成Vine IL。

Vine的后端支持各种核心程序分析实用程序。后端有用于创建各种不同图形的实用程序，例如控制流图和程序依赖图。后端还提供了一个优化框架。这个优化框架通常用于简化一组特定的指令。还提供了程序验证功能，例如符号执行、计算最弱前置条件以及与决策过程交互。Vine还可以通过代码生成器后端把提取的Vine指令写成有效的C代码。

为了将静态分析和动态分析结合起来，我们还为Vine提供了一个接口来读取由动态分析组件（如TEMU）生成的执行跟踪。执行跟踪可以提升到IL进行各种进一步分析。

#### 3.2 Vine IL

Vine IL是lifting（升级？）过程中的目标语言，也是后端程序分析的分析语言。IL的语义被设计成忠实于汇编语言。
![](https://tva1.sinaimg.cn/large/00831rSTgy1gcskdd65fqj30yw0rcjvy.jpg)
Vine IL中的基本类型是1、8、16、32位寄存器（即n bit向量）和内存。内存类型由它的字节序决定，可以是little（用于如x86这样的小端架构），big（用于如PowerPC这样的大段结构），或者norm，用于规范化内存（normalized memory）（后面讲）。内存类型也由索引类型限定，索引类型必须是寄存器类型。

```
如mem_t（little，reg32_t）表示内存类型是小端字节，并且由32位数字寻址。
```

Vine有三种类型的值。首先，在类型 τ<sub>reg</sub> 中有数字n。其次，Vine有内存值{n<sub>a1</sub>  $\rightarrow$ n<sub>v1</sub>，n~a2~ $\rightarrow$ n<sub>v2</sub>，...}，其中，n~ai~表示用作地址的数字，n~vi~表示存储在该地址的值。最后，Vine有一个特殊值⊥。⊥值不会暴露给用户，不能用于表示语言的构造。⊥ 用于在内部指示执行失败。

Vine有三种类型的值。首先，在类型 τ<sub>reg</sub> 中有数字n。其次，Vine有内存值{n<sub>a1</sub>  $\rightarrow$ n<sub>v1</sub>，n~a2~ $\rightarrow$ n<sub>v2</sub>，...}，其中，n~ai~表示用作地址的数字，n~vi~表示存储在该地址的值。最后，Vine有一个特殊值⊥。⊥值不会暴露给用户，不能用于表示语言的构造。⊥ 用于在内部指示执行失败。

Vine中的表达式是没有副作用的。Vine IL有二元操作$\diamondsuit_b$(“&” 和 “ | ” 是按位的)、一元操作$\diamondsuit_u$、常量、let绑定和强制类型转换（casting）。

```Casting：当语义需要改变值的宽度时使用。如，x86中`eax`较低的8位称为`al`，在提升x86指令时，当访问到`al`时，我们使用强制类型转换将相应`eax`寄存器变量的低位投射到`al`寄存器变量。```

在Vine中，`load`和`store`操作都是pure的。`load`通常都是pure的，但`store`的语义通常不是。每个`store`表达式必须指定要从哪个内存加载或存储。结果的内存作为返回值。如，一个Vine存储操作写作`mem1 = store(mem0,a,y)`，除了地址`a`有值`y`以外，`mem1`和`mem0`相同。Vine标记法的pure内存操作的优点是，可以从语法上分析哪些内存被修改或读取。我们在计算SSA（Single Static Assignment）时利用了这一点，其中标量和内存都有唯一的SSA位置。

Vine中的程序是一组变量声明，后面跟着一组指令。有7种不同的指令。语言有赋值，跳转，条件跳转和标签。所有的跳转和条件跳转的目标必须在我们的操作语义中是一个有效的标签，否则程序会发生⊥停止。注意，跳转到一个未定义的位置（如，没有被反汇编成动态生成代码的位置），会导致Vine发生⊥停止。通过使用`halt`语句，程序可以在任何时候发生停止。我们也提供`assert`，类似于C assert，断言表达必须是真的，否则机器会发生⊥停止。

Vine中的特殊调用`special`对应于对外部定义的过程或函数的调用。特殊调用的`id`指明特殊调用的种类，如，它是什么系统调用。`special`的语义是由分析决定的，没有定义操作语义。我们把`special`作为一种指令类型，显式的区分什么时候会发生这样的调用，从而增强分析的可靠性。一个典型的处理`special`的方法是用一个写在Vine IL中的适合分析的特定于分析的摘要函数来替换`special`。

##### **规范化内存**

机器的字节序通常取决于硬件的字节顺序。

```
大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。
小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。
```

![image-20200314201759548](/Users/quze/Library/Application Support/typora-user-images/image-20200314201759548.png)

在分析内存访问时，必须注意字节序。考虑图3a中的汇编代码。第1行上的mov操作按小端序向内存写入4个字节(因为x86是小端序)。在执行第1行之后，`eax`给出的地址包含字节`0xdd`, `eax+1`包含字节`0xcc`，等等，如图3b所示。第2行和第3行设置`ebx = eax+3`。第4行和第5行将16位值`0x1122`写入`ebx`。对这几行代码的分析需要考虑第4行的写操作会覆盖第1行的最后一个字节，如图3c所示。考虑这些情况需要在每个分析中添加额外的逻辑。例如，第7行加载的值将包含来自两个存储的每个字节。[x86汇编快速入门](https://www.cnblogs.com/jiftle/p/8453106.html)。

如果所有的加载和存储都恰好是b字节和b字节对齐的，那么内存就被规范化为b字节可寻址内存。如，x86中，内存是字节可寻址的，那么x86规范化内存会让所有的加载和存储在字节级别上处理。图3a中第1行的写操作的规范化形式如图4。注意，第7行的后续负载是相对于当前内存`mem6`的。（图啥意思没看懂。。。。）

![image-20200314211528623](/Users/quze/Library/Application Support/typora-user-images/image-20200314211528623.png)

规范化内存使编写涉及内存的程序分析变得更容易。因为规范化的内存语法暴露内存更新，而这些更新是被endianness隐式定义的。Vine后端提供用于规范化所有内存操作的实用程序。

#### 3.3 Vine前端

Vine前端负责将二进制代码翻译成Vine IL。此外，前端提供GNU二进制文件描述符（libbfd）库之类的库，用于解析二进制文件的底层细节。

将二进制代码翻译成IL包括三个步骤：

* 第一步，首先对二进制文件进行分解。Vine目前支持三个反汇编程序接口：IDA Pro，一个商业反汇编程序。Kruegel等的研究反汇编程序，以及我们自己的基于GNU libocodes的线性扫描反汇编器。添加其他反汇编器也很简单。

* 第二步。反汇编器被传递给VEX。VEX是一个第三方库，把汇编指令转换成VEX中间语言。VEX IL是Valgrind动态测量工具的一部分。VEX IL也类似于一种基于RISC的语言。因此，得到的IL只有几种指令类型，类似于Vine。然而，VEX IL本身对于执行程序分析是不方便的，因为它没有处理指令副作用的问题（如x86指令设置了什么样的`EFLAGS`）。这一步主要是为了简化Vine的开发：我们让现有的工具进行处理，在这一步只生成了基础的IL，然后在第三步中处理所有的副作用问题。

* 把VEX IL翻译成Vine。结果的Vine IL必须有可靠的反汇编指令语义。

汇编指令中的副作用在翻译完后都会在Vine IL中显示的表示出来。最后，一条汇编指令会被翻译为一系列Vine指令。

例如x86指令`add eax，0x2`会被翻译成下面的Vine指令：

```
tmp1 = EAX; EAX = EAX + 2; 
//eflags calculation 
CF:reg1_t = (EAX<tmp1); 
tmp2 = cast(low, EAX, reg8_t); 
PF =(!cast(low,      		((((tmp2>>7)ˆ(tmp2>>6))ˆ((tmp2>>5)ˆ(tmp2>>4)))ˆ (((tmp2>>3)ˆ(tmp2>>2))ˆ((tmp2>>1)ˆtmp2)))), reg1_t);
AF = (1==(16&(EAXˆ(tmp1ˆ2)))); 
ZF = (EAX==0); 
SF = (1==(1&(EAX>>31))); 
OF = (1==(1&(((tmp1ˆ(2ˆ0xFFFFFFFF))&(tmp1ˆEAX))>>31)));
```

翻译后的指令会显式表达`add`指令所有的副作用，包括这个操作可能更新的6个`eflags`。另外的例子，一条有`rep`前缀的指令被翻译为形成loop循环的一系列指令。

除二进制文件外，Vine也可以把指令跟踪（instruction trace）翻译为IL。跟踪中的条件分支被转化成`assert`语句。这是为了防止被执行到跟踪以外的未知指令。Vine和TEMU是共同设计的，这样TEMU生成的trace文件可以被Vine读。

#### Vine 后端

在Vine后端中，分析工具都是基于Vine IL开发的。Vine提供了一个公共分析库，和可以作为更高级分析的基础的实用程序。下面概述Vine后端提供的分析工具和组件。

* **Evaluator**。Vine有一个实现了Vine IL操作语义的鉴定机Evaluator。通过它我们可以执行程序，而不需要把IL重新编译为汇编。例如，我们可以测试由输入产生的指令跟踪的Vine IL，评估这个输入的IL，验证我们以相同的状态结束。

* **图表**。Vine可以构建和操作控制流图（CFG），包括a pretty-printer for the graphviz DOT graph language [2].Vine还可以构建数据依赖图和程序依赖图。

  构建汇编程序的CFG的一个问题是确定间接跳转（indirect jumps，跳转到一个计算得到的地址）的后继指令。解决间接跳转问题通常需要基于CFG的程序分析工具，如VSA（Value Set Analysis）。因此会出现循环依赖。注意间接跳转可能会跳转到任何地方，包括堆或没有被反汇编的代码。

  解决方法是在CFG中指定一个特殊节点作为未解决的间接跳转的后继节点。这样基于CFG分析的工具就会知道我们不知道后续状态。如，数据流分析可以将所有的事实都扩展到格底。多数常规分析先运行间接跳转解析分析，来构建更准确的CFG，这个CFG会将间接跳转解析为一个可能的跳转目标列表。Vine提供了一个这样的分析，VSA。

* **单一静态赋值（Single Static Assignment，SSA）**。Vine支持与SSA形式之间的转化。SSA形式使得分析更简单，因为每个变量只能静态定义一次。我们将内存和标量都转换为SSA形式。把内存转换为SSA形式，这样就可以从语法上区分写操作执行前后的内存了，而不需要分析工具本身做类似的记录。如，在图3.2的内存规范化实例中，分析工具可以从语法上区分第1、5行写之前和第7行读之前的内存状态。

* **截断（chopping）**。给定源（source）和sink节点，程序截断是一个展示了「导致源的定义影响sink的使用」的语句的图。例如，截断可以用于将后续分析限定在一部分相关代码中（即限定在给定的source和sink，而不是整个程序）。

* **数据流和优化**。Vine提供了一个通用的基于用户自定义结构（lattices）的数据流引擎。Vine还实现了几个数据流分析。Vine目前实现了Simpson的全局数值编号，常数传播和合并，不可大代码删除，动态变量分析，整数范围分析和值集分析（VSA）。VSA是一种数据流分析，在任何一个程序点逼近每个变量。可以用来解决间接跳转。也可以用作别名分析，如果两个内存访问的值集的交集非空，可能一个是另一个的别名。

  优化对于简化或加速后续分析非常有用。如，我们发现，通过使用程序优化来先对查询进行简化，可以使决策过程STP返回一个查询的满意结果的时间减少一半。

* **C 代码生成器**。Vine可以从IL中生成C代码。例如，Vine可以被用作基本的反编译器，先把汇编语言翻译成IL，在生成C代码。这也提供了一种编译Vine程序的方法：把IL转化成C代码，再用C编译器编译。

  C代码生成器在IL中以数组的形式实现内存。`store`操作是对数组的存储操作，`load`操作是从数组加载。由此，C生成的代码模拟真实的内存。例如，假设一个容易受到缓冲区溢出的程序被提交给Vine，然后生成C代码并重新编译，原始程序上的越界写将在相应的C数组中进行模拟，但不会导致真正的缓冲区溢出。

* 程序验证分析。Vine当前以两种方式支持正式的程序校验。第一，Vine可以把IL转换成Dijkstra’s Guarded Command Language (GCL），计算出GCL中的最弱前置条件。对于一个程序来说，关于谓词q的最弱的前置条件是保证对任意满足该条件的输入都会得到一个满足q的状态，这是一个最普遍条件。目前只支持无循环的程序，如，不支持GCL的`while`。

  第二，Vine包含与决策过程的接口。在决策过程的支持下，Vine可以用CVC Lite syntax生成表达式（如最弱前置条件）。另外，通过直接调用STP库，Vine直接支持与STP决策过程相关联。

#### 3.5 Vine的实现

Vine的基础结构是由C++和OCaml实现的。前端主要由C++实现，代码大约17200行。后端由OCaml实现，大约40000行代码。OCaml通过IDL生成的存根实现前端和后端的衔接。

前段接口通过Valgrind’s VEX来转换指令，使用GNU BFD来解析可执行对象，使用GNU libopcodes来打印反汇编后的程序。

除了图1中的指令，Vine IL还有几个构造器：

* 注释构造器。可以打印每一条反汇编的指令和用户自定义的注释。
* 支持跨块的变量辖域。
* 具有用于限定「语句和具有用户定义属性的类型」的构造器。有助于促进某些分析，如基于污点的分析。

### 4 TEMU：动态分析组件

本节介绍TEMU，描述其用于OS级语义的组件，展示全系统动态污点分析，它的插件和实现。

#### 4.1 TEMU概述

TEMU是一个我们在全系统仿真器QEMU上开发的全系统动态二进制分析平台。我们在QEMU上运行整个系统（包括os和应用程序）然后细粒度（in a ﬁne-grained manner）地观察感兴趣的二进制代码是怎么执行的。TEMU基于以下考量而采用全系统方法：

* 许多分析需要对二进制代码进行细粒度的分析（如指令级别）。通过动态翻译仿真代码，全系统仿真器保证了分析的细粒度。
* 全系统仿真器给我们提供了一个全系统的视图。使得我们能够分析操作系统内核和多个进程之间的交互。相比之下，很多其他二进制分析工具（如Valgrind,DynamoRIO, Pin）只提供一个本地视图（即单用户模式进程的视图）。这对于分析恶意代码是很重要的，因为很多攻击都与多进程相关，诸如rootkits的内核攻击越来越普遍。
* 全系统仿真器在分析部分和被分析代码之间提供了良好的隔离。被分析的代码不会影响分析过程。

TEMU的设计基于以下几个方面的挑战和考虑：

* 全系统仿真器只提供硬件级仿真系统视图，然而我们希望得到软件级视图以得到有意义的分析结果。因此，我们需要一个从仿真系统中提取os级语义的机制。例如，我们需要知道哪个进程正在运行，某条指令来自于哪个模块。

* 另外，许多分析过程需要推理特定的数据对其数据源的依赖性，以及特定数据如何在系统中传播。全系统的动态污点分析可以提供这项功能。

* 我们需要提供一个设计良好的编程接口（如API），以使用户能在TEMU上实现自己的插件来进行定制的分析。这样的接口可以向用户隐藏不必要的细节，还可以重用公共功能。

  基于这些考量，我们设计的TEMU架构如图5。

  ![image-20200317235130473](/Users/quze/Library/Application Support/typora-user-images/image-20200317235130473.png)

semantics extractor用于从emulated system中提取OS级语义信息。taint analysis engine用于执行动态污点分析。设计实现了接口TEMU API以便用户开发自己的分析模块（即TEMU插件）。这些模块可以在进行时装载或者卸载，

来执行指定的分析。TEMU是在Linux上实现的。TEMU可用于分析Win2000，WinXP和Linux系统中的二进制代码。下面分别描述这三个组件。

#### 4.2 Semantics Extractor语义提取器

语义提取器用于提取仿真系统的os级语义信息，包括进程，模块，线程，以及符号信息。

**进程和模块信息。**对于当前执行的指令，需要知道该指令来自哪个进程、线程和模块。在某些情况下，指令可能是在堆上动态生成和执行的。

维护内存地址和模块之间的映射需要来自客户操作系统的信息。我们使用两种不同的方法来提取Windows和Linux的进程和模块信息。

对于Windows，我们开发了一个名为module notiﬁer的内核模块。通过把这个模块加载到guest os中来收集内存映射信息。module notiﬁer注册了两个回调例程。第一个回调例程在每次进程创建和删除的时候被调用。第二个回调例程在一个新的模块被加载时被调用，它会收集新模块在虚拟内存中占用的地址范围。另外，module notiﬁer获得每个进程的CR3寄存器的值。由于CR3寄存器保存着当前进程页表的物理地址，因而它们是各不相同的。上述所用信息都通过一个预定义的I/O端口传递给TEMU。

对于Linux系统，我们可以直接从外部读取进程和模块信息，因为我们知道相关的内核数据结构，而且相关符号的地址也被导出到`system.map`文件中。为了在执行时保存进程和模块信息，我们hook了几个内核函数，如`do_fork`和`do_exec`。

**线程信息。**在Windows系统中，需要获取当前线程信息以支持对多线程应用程序和操作系统内核的分析。Windows中当前线程的数据结构映射到了一个众所周知的虚拟地址处，因而这比较直观。目前，还没有支持Linux的版本，可能后续版本会实现这一功能。

**符号信息。**对于PE（Windows）格式的二进制文件，也要分析它们的PE头并提取导出符号和偏移。确定了所有模块的位置后，我们就可以通过基址加偏移计算出每个符号的绝对地址。这一特征是非常有用的，因为所有的windows API和内核API都是由其宿主模块导出的。符号信息传递了重要的语义信息，因为从一个函数名，我们可以得知它的用途，输入参数，输出参数以及返回值。符号信息也使hook一个函数变得更加方便——只需要给出模块名和函数名，而不用指明其实际地址。TEMU会自动映射到函数的实际地址。

目前，此功能只支持PE文件。后续版本会支持ELF（Linux）二进制文件。

#### 4.3 污点分析引擎

我们的动态污点分析在本质上与先前的一些系统是相似的。但是我们的目的是支持多种不同的应用，因而我们的设计和实现是最完整的。例如，以往的方案要么只支持单进程，要么不支持内存交换和磁盘。

**影子内存。**影子内存用来存储物理内存、CPU寄存器、硬盘和网络接口缓冲区每个字节的污点状态。每个标记的字节都与一个存储污点源和其他TEMU插件用到的信息的小型数据结构相关联。影子内存组织成一个类似页表的结构以提高内存利用率。通过对硬盘使用影子内存，系统可以在标记数据被换出后继续跟踪它，也可以跟踪存入文件后又被读入的标记数据。

**污点源。**一个TEMU插件负责把污点源导入系统。TEMU支持来自硬件的污点输入，比如键盘，网络接口，硬盘。TEMU也可以标记高级抽象的数据对象（如，函数调用的输出，特定应用程序或操作系统内核的数据结构）。

**污点传播。**当数据源被标记后，污点分析引擎会监控操作这个数据的每条CPU指令和DMA操作以判定污点的传播过程。污点分析引擎通过数据转移指令、DMA操作、算术操作和查表来传播污点。有些指令（如，`xor eax,eax`）产生的结果与操作数无关，污点分析引擎并不传播这些指令中的污点。

注意，TEMU插件可能根据其需求遵守不同的策略。例如，对某些程序，不需要传播查表产生的污点。对于某些应用程序，如果所占用的代码区域有污点，我们希望通过立即数来传播污点。因此，在污点传播期间，污点分析引擎让TEMU插件决定采用何种策略将污点传播到目的地。

这种设计使TEMU更加灵活。TEMU插件可以指定不同的污点源，为每个标记的字节保存任意的记录，跟踪多个污点源，采用多种策略。

#### 4.4 TEMU API和插件

为了便于用户使用TEMU提供的功能，我们定义了一系列函数和回调。利用这些接口，用户可以开发自己的插件并在运行时加载到TEMU来进行分析。目前，TEMU提供以下功能：

-查询和设置内存区和CPU寄存器的值。

-查询和设置内存或寄存器的污点信息。

-在一个函数进入和退出时设置一个钩子，删除钩子。TEMU插件可以使用此接口监控用户和内核函数。

-查询操作系统级语义信息，如当前进程，模块，线程。

-保存和加载仿真系统状态。这个接口用于实现不同机器状态间的转换以实现更高效的分析。例如，此接口使多路搜索更加高效，因为我们可以保存分支点的状态，然后搜索一条路径，之后可以加载先前保存的分支点再执行另一条分支，而不必重新执行程序。

TEMU为多种事件定义了回调，包括（1）基本块地进入和退出；（2）一条指令的进入和退出；（3）污点传播时；（4）内存被读或写时；（5）寄存器读或写时；（6）诸如网络和磁盘输入输出的硬件事件。

下列TEMU插件是使用这些接口和回调实现的：

-Panorama：执行os感知全系统污点分析的插件，探测和分析恶意代码的信息处理行为。

-HookFinder：执行细粒度的影响分析（污点分析的变体），探测和分析恶意软件的hook行为。

-Renovo：从加壳的可执行文件中提取未加壳的代码的插件。

-Polyglot：利用动态污点分析提取协议消息格式的插件。

-Tracecap：记录进程或OS内核污点信息的指令跟踪的插件。

-MineSweeper：通过在线符号执行，识别和发现恶意软件中基于触发的行为的插件。

-BitScope：一个更通用的插件，利用符号执行来进行对恶意软件的更深入的分析。

-HookScout：一个推断内核数据结构的插件。

#### 4.5 TEMU的实现

TEMU由C和C++实现。由于C的高效性，性能要求高的代码由C实现，而面向分析的代码由C++编写，这样能很好的利用C++ STL中的抽象数据类型和类型检查。例如，污点分析引擎把代码片段插入到QEMU微操作中以检查和传播污点信息。由于污点分析对性能要求很高，因此它用C语言实现。另一方面，我们用C++ STL中的`string`，`list`，`map`等抽象数据类型实现语义提取器（semantics extractor），使映射保持在操作系统级视图和硬件视图之间。TEMU API由C定义。这使得用户可以在开发自己的插件时既可以使用C，也可以使用C++。TEMU内核由约37000行代码组成，不包括QEMU的代码（约306000行）。TEMU插件包含约134000行代码。

### 5 Rudder：具体执行和符号执行混合的模块

概述Rudder。主要描述执行混合执行，探索进程执行空间的组件，以及Rudder的实现。

#### 5.1 系统概述

Rudder用于进行二进制级别的具体+符号混合执行。给定二进制程序和符号输入规范，Rudder可以进行具体+符号混合执行，在路径条件依赖于符号输入的情况下探索多条执行路径。这样，Rudder可以自动发现只在某些情况下出现的隐藏行为。

![image-20200319232312922](/Users/quze/Library/Application Support/typora-user-images/image-20200319232312922.png)

图6展示了Rudder的结构。Rudder由以下部分组成：mixed execution engine负责执行具体+符号混合执行。path selector负责执行路径的优先级和选择哪一条。solver负责判断符号路径谓词，决定路径是否可行。输入是一个二进制程序和符号输入规范。在TEMU中执行和监控二进制程序。Rudder作为TEMU的插件运行，用来测量二进制程序的执行。在执行过程中，Rudder根据符号输入规范把部分输入标记为符号。然后mixed execution engine对「符号输入的操作和从符号输入计算出的数据」进行符号执行。当在分支指令中执行某个符号值时，path selector会在solver的辅助下，确定哪些分支是可行的，并选择要探索的分支。

#### 5.2 Mixed Execution Engine

**决定是否符号执行某条指令。**对于每条指令，mixed execution engine执行以下步骤：首先，检查指令的原操作数，判断他们是具体的还是符号的。如果原操作数都是具体的，指令就在仿真CPU上具体执行。否则，mixed execution engine将目标操作数标记为符号，并计算目标操作数的符号表达式。mixed execution engine依靠TEMU提供的动态污点分析来标记和传播符号数据。

**生成符号程序。**理想情况下，我们希望动态计算符号表达式。然而，这种方法会在运行时造成巨大的性能开销。考虑到很多表达式都不会在路径谓词中使用，我们采用一种懒方法。主要想法是在符号执行期间收集必要信息存放在符号机器（symbolic machine）中。然后，当路径谓词中用到某些符号变量时，可以从符号机器中提取相应的符号表达式。

具体地说，我们把这条指令，以及它的相关寄存器和内存状态存放到我们的符号机器中。也就是说，如果需要进行符号执行的指令中具有任何具体操作数，我们必须在符号机器中更新这些具体值。对于寄存器，我们只需要在符号机器中更新具体值。然而我们还必须处理内存地址是符号化的内存访问，如下。

符号内存地址意味着指定读或者写哪个内存的数据是符号的。如果这个地址是符号地址，我们就不知道要访问哪个内存位置，因为符号地址可能是任何具体的值。为了解决这个问题，我们使用solver来确定这个地址可能的取值范围。在某些情况下，solver返回的范围会很大。在本例中，我们在系统中添加了一个约束来限制这个范围的大小。在实践中，我们发现多数的符号内存地址已经限制到很小的范围内，所以其实没必要。例如，考虑遍历一个数组的代码。每个对数组的访问都受到遍历本身的约束。注意这是一种保险的方法，所有的解决方案都是正确的。一旦选定了一个范围，我们就在符号机器中更新必要的信息。

我们利用Vine的功能来执行符号执行。也就是说，当符号化地执行一个指令时，我们把它翻译成Vine IL，生成Vine IL形式的符号程序。

**提取符号表达式。**给定符号程序和一个感兴趣的符号变量，就可以提取出它的符号表达式。提取符号表达式需要的步骤：首先我们对符号程序执行动态切片。这一步删除了符号没有依赖的指令。在这一步之后，产生的符号程序被大大减少。然后，我们使用中间符号替换他们右边的表达式？？，生成一个表达式。最后，我们执行常数折叠和其他优化来进一步简化表达式。

#### 5.3 Path Selector

当分支条件变为符号时，我们用Path Selector来确定要探索哪个分支。有一个接口供用户提供自己的优先路径选择功能。由于我们通常需要探索尽可能多的依赖符号输入的路径，默认搜索方法是宽度优先的。

为了使路径搜索更加有效，我们利用了TEMU提供的状态保存和恢复功能。即，当第一次遇到符号条件分支时，Path Selector保存当前执行状态，确定哪个方向是可行的。之后，当它决定从这个分支探索不同的方向时，Path Selector将恢复这个分支上的执行状态，探索另一个分支。

#### 5.4 Solver

Solver是一个对符号表达式进行推理的定理证明或决策过程。在Rudder中，Solver用于确定是否满足路径谓词，以及确定带有符号地址的内存区域的范围。我们可以利用任何可用的决策过程（decision procedures）。当前在我们的实现中，使用STP作为Solver。

#### 5.5 Rudder的实现

Rudder是用C、C++和Ocaml实现的。该实现由大约3600行C/ C++代码和2600行Ocaml代码组成。C/ C++代码主要用于实现一个TEMU插件，并标记和跟踪符号值，Ocaml代码用于与Vine接口并执行符号分析。我们还为Rudder提供了一个离线模式，在该模式中，我们获取一个执行跟踪，然后在跟踪上执行符号执行，以获得路径谓词，作为不同的分支的输入。

### 6 安全应用

本节将介绍BitBlaze平台支持的各种不同安全应用，包括自动的漏洞检测，分析和防范，自动的恶意软件分析和防范，自动的模型提取和逆向工程。对于每种应用，我们基于相关程序的本质原因给出了一个新的阐释。进而我们将说明这种阐释将引导我们从本质上找到解决安全问题的新方法。最终我们将看到BitBlaze平台的高效性以及它的前景—在BitBlaze平台上建立不同的应用更加简便而且其效率更高。

#### 6.1 漏洞检测、分析及防范

**Sting：一种针对0day攻击的自动防御系统。**诸如CodeRed和SQL Slammer之类的蠕虫利用软件漏洞进行传播。它们可以在数小时甚至数分钟之内感染数百万台主机并造成数十亿美元损失。我们如何才能设计和开发一种应对这种快速且影响范围很广的蠕虫攻击的高效防御机制？

我们已经设计和开发了Sting，一种新式的端到端的自动防御系统，该系统的目的是防范漏洞利用（甚至是0day漏洞），并保护含有漏洞的主机和网络免受快速的蠕虫攻击。Sting利用动态污点分析技术来检测对未知漏洞的利用，并自动生成过滤器来保护有漏洞的主机。

**自动生成漏洞签名。**基于输入的过滤器（a.k.a.签名）在漏洞主机打上补丁之前对其提供了重要的保护。因此，及时自动生成高效的基于输入的过滤器是一项重要的任务。我们已经设计和开发了基于漏洞而非漏洞利用代码自动生成基于输入的过滤器的新技术，因此它可以0误报，高效的防范各种漏洞利用程序的变体。

**自动的基于补丁的漏洞利用程序生成。**补丁不仅修复了安全漏洞，它们可能同时也携带了能被攻击者利用的相关敏感信息并造成严重后果。我们已经证实了这个观点是正确的—我们已经开发出了通过给出打补丁后的程序和含有漏洞的程序生成相应漏洞利用程序的新技术（通常几分钟内完成）。这也开启了一个新的研究方向,即怎样发布补丁以使攻击者无法从中获取敏感信息。

#### 6.2 恶意软件分析与防御

**Panorama：捕获整个系统的信息流以进行恶意软件检测和分析。**大量的诸如键盘记录器、浏览器辅助对象（BHO）、间谍软件、rootkits、后门等恶意软件访问和泄露用户的敏感信息并违背用户隐私。我们是否能找到一种解决这种隐私泄露恶意软件的通用方法而不必关心各种不同恶意软件的外在区别？我们为此设计和开发了Panorama，它利用了全系统动态污点分析技术。

**Renovo：从加壳的可执行文件中进行隐藏代码抽取。**代码加壳是阻碍逆向工程代码分析的常用方法。尽管这个问题之前已被研究过，但是现有的解决方案要么无法处理新壳，要么对众多的隐藏技术无能为力。因此，设计和开发了Renovo作为一种动态的隐藏代码抽取方法，它能够捕获隐藏代码执行的内在特征。

**HookFinder：分析恶意软件钩子的行为。**恶意软件攻击的一个重要导向是它们的钩子机制。恶意程序注入钩子以实现多种目的。间谍软件注入钩子以获知新的敏感数据的到达。Rootkits通过注入钩子来和篡改相关系统信息以达到隐藏自身的目的。一个隐藏的后门可能在网络栈中设置钩子以建立一个隐藏的通信通道与远程攻击者通信。HookFinder自动检测和分析恶意软件的钩子行为。由于这项技术捕获钩子行为的内在本质，因此它能适应新的钩子机制。

**BitScope：自动分析恶意软件。**自动分析恶意软件的二进制文件并从中提取信息的能力是系统安全分析和系统防御的重要基石。恶意软件，包括拒绝服务攻击工具，垃圾邮件，蠕虫和僵尸程序。通过广泛部署的蜜罐，我们每天都能发现新的恶意软件样本。鉴于恶意软件的快速发展，自动的恶意程序分析对于高效的防御是必需的。

我们设计和开发了BitScope—一个系统的查询恶意软件可能隐藏的功能的系统。BitScope以恶意软件为输入，输出其执行路径的相关信息。这些信息可用于解决具体的问题，例如，恶意软件的行为，什么输入产生了特定行为，输入输出之间的依赖。

#### 6.4 自动模型抽取和分析

**Polyglot：协议信息格式的自动抽取。**协议逆向工程对于许多网络安全应用是很重要的。目前，协议逆向工程大都是手动的。例如，Samba开源项目耗时10年逆向分析SMB—微软Windows系统用于共享文件和打印机的协议。

我们认为二进制程序分析有助于自动的协议逆向工程。直觉是二进制代码编码了协议，因此二进制代码分析在从二进制文件中提取协议方面应该是有很大帮助的。

**自动偏差检测。**许多网络协议和服务有多种实现。由于编码错误和协议说明书的歧义，这些实现可能存在偏差，如，检查和处理输入的差异。自动识别偏差可以支持自动检测实现错误，自动生成用于区别相同网络服务的实现指纹。这个项目的难点在于自动发现偏差（不依靠源代码）。我们已经实现了用于自动生成造成相同协议的两种二进制实现产生偏差的输入的技术。

**Replayer：应用程序对话的重演。**精确地重演应用程序协议对话在许多面向安全的应用中是很有用的，例如，重演漏洞利用已进行分析或向第三方演示漏洞利用。应用程序对话重演的难点在于对话不太会被无修改的接收到。例如，对话可能包含或依靠原始主机的相关信息，如主机名或一个已知的cookie。这样，直接在另一台不同状态（如，不同的主机名）的主机上逐个字节的重演很可能失败。这些状态相关的协议域必须更新为不同主机的不同状态以保证成功重演。

### 7 相关工作

本节，我们将简要介绍其他静态和动态二进制分析平台的一些相关工作。

**静态二进制分析平台。**现有多个静态二进制分析平台，但它们不满足我们的目的，这主要是因为它们是基于不同的应用开发的，因而不不需要满足相同的需求。

Phoenix是Microsoft开发的一款编译器程序分析环境。一款Phoenix工具可以使代码转换为一种寄存器转换语言（RTL）。RTL是一种低级的中间语言，类似一种架构无关的汇编语言。Phoenix与Vine存在以下几点不同。第一，Phoenix只能处理Microsoft编译器产生的代码。第二，Phoenix需要调试信息，因而它不是一个真正的二进制分析平台。第三，Phoenix把汇编语言转换为一种不剖析复杂指令语义的低级中间语言。第四，中间语言的语义是不确定的，因而不适合我们的研究。

CodeSurfer/x86平台只能用于分析x86程序。然而，它主要是为其他应用目的开发的，并不能提供我们所需要的一些功能。

**动态二进制分析平台。**DynamoRIO，Pin和Valgrind等工具支持对用户级程序的细粒度分析。它们都为用户实现自己的插件提供了良好的接口。然而，它们都只能分析单用户级进程，不适合分析操作系统内核和涉及多进程的应用。另外，这些工具与待分析程序驻留在相同的执行环境中。其中有一些甚至共享相同的内存空间，并改变了程序的内存布局。结果是分析结果可能受到影响。相比之下，TEMU提供了整个系统的视图，支持操作系统内核和多个进程的分析。而且，TEMU驻留在分析的执行环境之外，TEMU能产生更真实的分析结果。

### 8 总结

本篇论文介绍了BitBlaze项目，包括它的二进制分析平台和在多种不同安全问题中的应用。通过这篇论文，我们论证了我们的二进制分析平台提供了一个强大的工具集以支持我们采取一种强原则性的、基于根源的方法来解决多种安全问题。我们希望BitBlaze架构使大家更易于开发自己的插件并为其他应用提供新的解决方案。