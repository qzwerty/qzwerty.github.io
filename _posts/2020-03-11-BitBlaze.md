---
layout:     post
title:      BitBlaze: A New Approach to Computer Security via Binary Analysis
subtitle:   ICISS 2008
date:       2020-03-11
author:     qzwerty
header-img: img/blog-bj-1.png
catalog: true
tags:
    - security analysis
---

## BitBlaze: A New Approach to Computer Security via Binary Analysis

> BitBlaze是一个通过二进制分析来实现计算机安全的新方法。特别关注于构建一个统一的二进制分析平台，并使用它来为各种不同的安全问题提供新的解决方案。二进制分析平台的设计目的是支持准确的分析，提供可扩展的体系结构，并结合静态和动态分析以及程序验证技术，以满足安全应用程序的常见需求。通过直接从二进制程序中提取出与安全相关的属性，BitBlaze提供了一种原则性的、基于root-cause的方法，保护计算机安全，提供了新颖而有效的解决方案。

> keywords：二进制分析，恶意软件分析与防御，漏洞分析与防御，逆向工程

### 1 INTRODUCTION
对于许多安全问题，他们的根本原因和解决方案的关键直接在于相关的程序（如脆弱性程序和恶意代码）。通过设计开发技术和工具，从程序和解决方案中自动提取与安全相关的属性，我们可以启用一种原则性的方法处理很多安全问题，关注根本原因，提供比先前的方法（依赖于启发式或者攻击症状）更有效的方法。

要实现上述方法的一个技术挑战是对于安全应用程序，通常需要直接处理二进制代码。对于许多程序，如off-the-shelf（COTS）程序，用户不能访问它们的源代码。对于恶意代码攻击，攻击者可以不将源代码附加到攻击中，只执行二进制代码。所以说分析二进制代码将为安全应用程序提供重要事实，而分析员代码可能由于编译器错误和优化而分析错误。但是由于二进制代码的复杂性和缺乏高级语义信息，二进制代码分析极具挑战。对于通用安全应用程序的二进制分析工具很少。这是不能使用root-cause based方法的阻碍。

BitBlaze建立了一个统一的二进制分析平台，并使用它来为各种不同的安全问题提供新的解决方案。

本文描述BitBlaze的两个主要研究方向：

* 针对安全应用程序的统一、可扩展的二进制分析基础架构设计与开发

* 采用原则性的，root-cause based approach（由我们的二进制分析框架支持），能够解决不同安全问题的创新方法

本文剩下的部分描述了BitBlaze二进制分析平台的挑战和设计原理，然后描述了它的总体架构，三个主要的组件，Vine，TEMU，Rudder。最后概述使用BitBlaze二进制分析平台启用的不同的安全应用程序，讨论了相关工作。

### 2 BitBlaze Binary Analysis Platform的结构
首先描述了二进制分析安全应用程序的挑战，然后描述了满足安全应用程序的二进制分析平台的期望属性，最后描述了BitBlaze的体系结构。
#### 2.1 挑战
二进制代码分析面临的挑战。其中一些是特定于安全应用程序的。

1. **complexity**。二进制代码很复杂。为了分析准确，二进制分析需要精准地对复杂性进行建模。然而，现代体系结构中指令的绝对数量和复杂性使得精确建模成为重大挑战。流行的现代体系结构通常有数百个不同的指令，每个处理器版本都添加了新的指令。此外，每条指令都可能具有复杂的语义，比如单个指令循环，根据操作数值有不同行为的指令，以及隐式的副作用，如设置处理器标志。比如说，描述x86语义的IA-32手册重量超过11磅。（？

考虑下面的x86汇编程序的确定控制流的问题：
![](https://tva1.sinaimg.cn/large/00831rSTgy1gcq70732yqj30qg052q3i.jpg)
先计算a := a + b，然后计算a := a << x。如果设置了处理器 zero flag，会跳转到地址a。

一个问题是，add和shl都有隐式的副作用。这两个指令都额外计算最多6 bit的信息，作为处理器状态标志保存。特别的，它们计算结果是否为0，结果的奇偶性，是否有辅助进位，是否对结果签名，是否发生溢出。

条件控制流，如jz指令，是由隐式计算的处理器flag决定的。因此，要么是add指令计算zero标志，要么是shl计算。然而，到底是add还是shl来决定分支呢？这个问题很难。根据操作数不同，shl指令行为也不同：他只在x不为0的时候更新zero标志。

2. **Lack of Higher-Level Sementics**。二进制代码与源代码不同，尤其是缺乏源代码中的高级语义。因此需要开发适合二进制代码设置（通常调试信息是不可用的）的程序分析技术和工具。尤其是，二进制代码缺乏抽象概念（abstractions），而这些是源代码和源代码分析的基础。

**abstractions：**

* **没有函数（functions）**。二进制程序中的控制流是通过跳转来执行的。例如，x86指令 `call x`只是「将当前指令指针（寄存器`eip`）存储在寄存器`esp`指定的地址上，根据体系结构字长递减`esp`，然后把数字x放入`eip`」的一种简写。实际上，它在汇编中是完全有效的，在实际中也会发生这种情况，代码可能调用一个“函数”的中间部分，或者将单个“函数”分隔成不相邻的部分。
* **内存 vs 缓冲区**。二进制代码没有缓冲区，它有内存。虽然操作系统可能判定某个特定内存页无效，但内存没有「用户指定的类型和大小」的语义。缓冲区和内存之间的区别意味着，二进制代码中不存在缓冲区溢出。虽然我们可以说一个特定的存储违反了源代码提供的高级语义，但这是高级语义层面的事，不是二进制代码本身的一部分。
* **没有类型**。不能创建或使用新类型，因为二进制代码中没有类型构造函数。唯一可用的类型是硬件提供的，寄存器和内存。然而寄存器类型不一定能提供有用的信息，因为通常会把值存储在一种寄存器类型（如32bit寄存器）中，然后从另一种寄存器类型（如8bit寄存器）中读。

总的来说，特定于汇编的方法（assembly-speciﬁc approach）不好，因为在现代复杂指令上编写分析往往是冗长和容易出错的。在如此庞大而复杂的指令集中验证程序分析是否正确更困难。另外，assembly-speciﬁc approach是特定于单个架构的。每次想要考虑新的架构时，所有的分析必须移植。因此，无法利用不同汇编语言的公共语义。（没看懂- =）

3. **全系统视图**。许多安全应用程序需要能够分析操作系统内核中的操作和多个进程之间的交互。需要一个完整的系统视图，比传统单程序分析面临更大挑战。

4. **代码混淆**。一些安全应用程序需要分析恶意代码。恶意代码可能使用诸如packing，加密，混淆等反分析技术增加分析难度。

#### 2.2 设计原理
BitBlaze二进制分析平台的目标是设计开发技术和核心实用程序，以满足安全应用程序的共同需求，并使其他人能够更容易、更有效地构建和开发安全问题的新解决方案。

**设计准则：**

* **准确性**。希望能够进行准确的分析，从而激励我们构建精确的、正式的指令模型，从而允许工具对程序执行行为符号化的精确建模。
* **可扩展性**。考虑到二进制分析的复杂性，希望开发核心实用程序（core utilities）。这些实用程序可以被重用，并且容易扩展，以支持对二进制更复杂的分析，或者很容易针对不同体系结构重新定位。
* **静态和动态分析的融合**。静态分析和动态分析各有利弊。静态分析可以提供更完整的结果，因为它涵盖了不同的执行路径。但是，由于指针别名的复杂性、间接跳转的普遍性、二进制文件中缺少类型（type）和高级抽象概念，这可能比较困难。即便是静态区分代码和数据都是一个无法确定的问题。此外，对于静态分析来说，处理动态生成的代码和恶意代码中使用的反静态技术也很具有挑战性。还有，某些指令（如内核指令和浮动指令）可能很难精准建模。另一方面，动态分析很自然地避免了静态分析需要面对的很多困难，代价是一次只能分析一条路线。希望将静态和动态分析结合起来。

#### 2.3 架构
![](https://tva1.sinaimg.cn/large/00831rSTgy1gcsh8uwaw8j30lk080aaj.jpg)
BitBlaze二进制分析平台由三个部分组成：Vine，静态分析部分；TEMU，动态分析部分；Rudder，动静结合的混合具体分析和符号分析部分。

* Vine将汇编语言翻译成一种简单的、正式指定的中间语言（IL），并提供一组用于IL上常见静态分析的核心实用程序，如控制流，数据流，优化，符号执行和最弱前置条件计算。
* TEMU执行全系统动态分析，支持全系统细粒度监视和动态二进制检测。它提供了一组核心实用程序，用于提取os级语义、用户定义的动态污染分析和用户定义活动的干净的插件接口。
* Rudder使用Vine和TEMU提供的核心功能来实现二进制级别的混合具体执行和符号执行。对于给定的程序执行路径，它标识符号路径谓词，符号输入需要满足这些谓词才能跟随程序路径。通过查询诸如决策过程之类的求解程序，它可以确定路径是否可行，以及什么输入可以导致程序执行遵循给定的路径。因此，Rudder可以自动生成输入，引导程序沿着不同的路径执行，探索程序执行空间的不同部分。Rudder提供了一组核心实用程序和接口，使用户能够进行快照和重新加载探索状态，并提供用户指定的路径选择状态。

### 3 Vine：静态分析组件
本节概述Vine组件的中间语言（Intermediate Language ，IL）、前端和后端组件，以及实现。
#### 3.1 Vine概述
![](https://tva1.sinaimg.cn/large/00831rSTgy1gcsiiyxm5qj30kw07eq44.jpg)
Vine静态分析组件分为特定于平台的前端和独立于平台的后端。Vine的核心是一个独立于平台的汇编中间语言（IL）。IL被设计成一种小而正式的指定语言（small and formally speciﬁed language），忠实地表示汇编语言。底层架构中的汇编指令通过Vine前端提升到Vine IL。所有后端分析都在平台无关的IL上执行。因此，程序分析可以以独立于体系结构的方式编写，并且不需要直接处理x86等指令集的复杂性。这种设计还提供了可扩展性——通过构建Vine中的核心实用程序，用户可以轻松在IL上编写自己的分析。

Vine前端分析目前支持x86和ARMv4到IL的转换。它使用一组第三方库来解析不同的二进制格式并生成程序集。然后以语法指导（syntax-directed manner）的方式将汇编语言翻译成Vine IL。

Vine的后端支持各种核心程序分析实用程序。后端有用于创建各种不同图形的实用程序，例如控制流图和程序依赖图。后端还提供了一个优化框架。这个优化框架通常用于简化一组特定的指令。还提供了程序验证功能，例如符号执行、计算最弱前置条件以及与决策过程交互。Vine还可以通过代码生成器后端把提取的Vine指令写成有效的C代码。

为了将静态分析和动态分析结合起来，我们还为Vine提供了一个接口来读取由动态分析组件（如TEMU）生成的执行跟踪。执行跟踪可以提升到IL进行各种进一步分析。

#### 3.2 Vine IL
Vine IL是lifting（升级？）过程中的目标语言，也是后端程序分析的分析语言。IL的语义被设计成忠实于汇编语言。
![](https://tva1.sinaimg.cn/large/00831rSTgy1gcskdd65fqj30yw0rcjvy.jpg)
Vine IL中的基本类型是1、8、16、32位寄存器（即n bit向量）和内存。内存类型由它的字节序决定，可以是little（用于如x86这样的小端架构），big（用于如PowerPC这样的大段结构），或者norm，用于规范化内存（normalized memory）（后面讲）。内存类型也由索引类型限定，索引类型必须是寄存器类型。
`如mem_t（little，reg32_t）表示内存类型是小端字节，并且由32位数字寻址。`
Vine有三种类型的值。首先，在类型 τ<sub>reg</sub> 中有数字n。其次，Vine有内存值{n<sub>a1</sub> n~v1~ $\rightarrow$ n<sub>v1</sub>，n~a2~ $\rightarrow$ n<sub>v2</sub>，...}，其中，n~ai~表示用作地址的数字，n~vi~表示存储在该地址的值。最后，Vine有一个特殊值⊥。⊥值不会暴露给用户，不能用于表示语言的构造。⊥ 用于在内部指示执行失败。











