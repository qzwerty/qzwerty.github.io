---
layout:     post
title:      Nitro Hardware-based System Call Tracing for Virtual Machines
subtitle:   VMI
date:       2020-10-09
author:     qzwerty
header-img: img/blog-bj-1.png
catalog: true
tags:
    - else

---

## Nitro Hardware-based System Call Tracing for Virtual Machines

虚拟机自省(VMI)描述了从hypervisor级别监视和分析虚拟机状态的方法。尽管来自Intel和AMD的硬件虚拟化支持在设计时并没有考虑到VMI，但这很适合于安全应用程序。这给硬件支持的VMI系统的开发人员带来了许多挑战。本文介绍了用于系统调用跟踪与监控的原型框架Nitro的设计与实现。由于Nitro是一个纯基于vm的系统，因此它与客户机操作系统内部的攻击保持隔离，并且不能直接从客户机内部看到它。Nitro非常灵活，因为它支持Intel x86体系结构提供的所有三种系统调用机制，并已被证明可以在Windows、Linux、32位和64位环境中工作。我们系统的高性能允许在不妨碍可用性的情况下实时捕获和传播数据。这是通过对各种客户操作系统的广泛测试来支持的。此外，由于hardware rooting这种结构，nitro能够抵抗绕过。最后，Nitro在性能和功能上都超过了同类系统。

###  1 Introduction

虚拟机内省(VMI)非常适合于安全应用程序[5]。这在一定程度上是因为在hypervisor中运行的安全机制与发生在虚拟机(VM)中的攻击是隔离的，并且hypervisor维护虚拟机系统状态的完整、无污染的视图。

为了充分利用VMI提供的潜力，识别和隔离相关的客户操作系统(OS)状态信息变得至关重要。这个过程需要一些guest相关的语义知识，称为语义差距问题[3]。为了弥补这一语义上的差距，我们将其分为三种基本视图生成模式[12]。其中一种模式依赖于硬件体系结构的知识来派生关于来宾操作系统的语义信息。利用硬件架构，人们可以通过hardware rooting[13]方法构建抵抗vm逃逸的机制。这使得基于硬件的信息提取对于旨在检测VM中的恶意活动的安全方法特别有意义。

检测这种恶意活动的一种有前途的方法是监视系统调用。系统调用促进了操作系统中内核和用户空间之间的通信，并且从安全角度来看很有趣。系统调用跟踪可以用机器学习方法将进程的行为分类为良性或恶意[9,6,14]。此外，流行的沙箱环境，如CWSandbox[7]、Anubis[2]或Norman Sandbox产品线，都包含了系统调用或API监视来创建它们的报告。最后，在实时取证应用程序(如在蜜罐环境中发现的那些应用程序)中监视感兴趣的特定系统调用。

在本文中，我们描述了我们的原型VMI框架Nitro的实现，用于基于硬件的系统调用跟踪和监控。由于VMI的特性，它可以与虚拟机中的恶意活动隔离，并且对来宾操作系统保持隐藏。据我们所知，Nitro是第一个支持Intel x86体系结构提供的所有三种系统调用机制的基于vm的系统，并且已经被证明可以在Windows、Linux、32位和64位客户机上工作。此外，这个框架足够灵活，可以支持几乎任何构建在x86体系结构上的操作系统。捕获和传播数据是实时完成的，不会影响来宾的可用性，正如我们的性能测试所显示的那样。最后，由于硬件原因，Nitro可以抵抗逃逸。我们将讨论这个方法的基础，它的实施，以及它在整个工作中的特性。

因此本文的其余部分组织如下:我们从第2节中介绍一些相关工作开始。我们将在第3节中继续介绍VMI系统的理想属性的需求。Nitro的实现将在第4节中详细说明，然后讨论它如何满足上述第5节的要求。在第6节中，我们将解释我们的性能评估并给出结果，我们将其与第7节中名为Ether[4]的类似系统进行比较。最后，我们在第8节中得出结论。

### 2 related work

在撰写本文时，据我们所知，还有三种其他系统使用虚拟化扩展来实现能够为安全应用程序生成系统调用跟踪的系统。第一个系统Lares[11]是这方面的先驱，它引入了在Windows客户操作系统中创建任意钩子的机制。Lares是在Xen系统管理程序上开发的，需要在Windows客户端中安装驱动程序，以方便挂钩。因为我们的系统根本不需要任何客户操作系统支持，它实现了更高级别的可移植性和健壮性，正如我们将展示的那样。因此，对Lares和Nitro进行详细的比较是没有意义的，本文不提供。

除了Lares之外，Ether系统[4]还提供了生成系统调用跟踪的功能。该系统也构建在Xen hypervisor之上，并采用了与Nitro类似的方法。详细比较请参考第7节。


最后，HyperSleuth[10]还提供了跟踪系统调用的能力，尽管作者指出“我们用于跟踪系统调用的方法因此受到了Ether的启发”。由于这个原因，我们不做详细的比较，而是把读者的注意力转移到我们对Nitro和ether的比较上。

### 3 属性

在第一节中，我们概述了Nitro的主要性质。这些属性、描述以及实现每个属性的需求将在本节中以一般的方式进行讨论。Nitro如何确切地满足这些要求将在后面的第5节。

**来宾操作系统的可移植性。**来宾操作系统可移植性指的是一种属性，它允许相同的VMI机制在不进行重大更改的情况下为各种来宾操作系统工作。理想情况下，客户机OS可移植的VMI机制可以在任何客户机OS上工作，而无需进行任何更改，但是我们允许对VMI机制进行一些小的配置更改，只要该方法的基本机制在所有客户机之间共享即可。

为了实现客户OS的可移植性，底层VMI机制可能不依赖于客户OS本身的知识，而是依赖于虚拟硬件规范的知识。例如，Jones等人利用CR3寄存器来跟踪进程[8]。这个寄存器如何在内存管理单元(MMU)中使用是由x86架构指定的，所有运行在这个硬件上并使用MMU的OSs都必须符合这些规范。因此，只要OSs支持虚拟内存，这个基本方法就可以在不改变的情况下跟踪各种来宾OSs中的进程。

**Evasion-resistance。**规避机制是指当在理想的系统中正确实现和部署时，攻击者无法绕过的机制。我们定义了一种正确实现的机制，它可以完美地执行策略，没有缺陷或错误。以同样的方式，我们将理想系统定义为完美地实现其设计并且不包含缺陷或错误的系统。由于我们知道这些理想的属性是不切实际的，所以当且仅当这样的缺陷被恶意实体发现并利用时，才有可能绕过这个机制。我们通过描述一种机制如何植根于硬件来开始讨论。

为了解释虚拟机的低级二进制状态信息，hypervisor必须结合硬件体系结构和来宾操作系统的知识来跨越语义鸿沟。正如Pfoh等人所说的[12]，一种仅依赖客户操作系统知识的方法可能会被改变客户操作系统架构本身的攻击所绕过。例如，客户操作系统使用特定数据结构的方式可能被恶意的实体操纵。这源于这样一个事实，即客户操作系统的这种知识并没有绑定到正在运行的操作系统内核。事实上，这种针对VMI机制的攻击已经成功实现，最近[1]表明，这种威胁不是纯粹的理论性质。

相反，如果VMI机制将其知识建立在关于虚拟硬件架构的信息上，那么这些攻击就不能被应用。来宾操作系统和在其上运行的所有软件，包括任何恶意软件，都必须遵守虚拟硬件的规则。攻击者无法更改这些规则。因此，这种硬件规范的知识是与硬件架构绑定在一起的。例如，如果硬件体系结构指定控制寄存器保存数据结构的地址，那么恶意实体就无法规避这一点，因为硬件会期望这是正确运行的情况。

这个观点也可以进一步扩大到包括其他部分状态信息如下:如果我们能从虚拟硬件规范的一个特征(eg。一个寄存器)开始,从那里,跟着引用在内存中,建立一个链到一个关键的数据结构,一个恶意实体不能不被发现地修改数据结构。图1描述了这样一个链。因此，如果这样一个链可以被构建[13]，我们将把一部分状态信息称为rooted in hardware。

![](https://tva1.sinaimg.cn/large/0081Kckwgy1gkrze77exuj30jk0m4wi7.jpg)

在介绍了hardware rooting之后，我们现在描述抵抗evasion的VMI机制的两个需求。首先，VM状态的受监视或受保护部分必须植根于虚拟硬件，如上所述。其次，必须保护所描述的引用链上的每个涉及的VM状态片段，以保证它不会违反策略被操纵，或者对此类VM状态的任何更改都会被来宾操作系统忽略。如果这两个要求都得到满足，该机制就是抗逃避的。

### 4 实现

本节描述我们在实现原型时所采取的步骤。Nitro基于Linux内核虚拟机(KVM)。KVM被分为两部分，即构建在QEMU上的用户应用程序和一组Linux内核模块。

KVM的用户应用程序部分提供QEMU监视器，它是管理程序的一个类似于shell的接口。它提供对VM的一般控制。例如，可以暂停和恢复VM，也可以使用监视器读出CPU寄存器。我们通过向监视器添加新命令来修改KVM，以控制Nitro的特性。也就是说，所有的Nitro命令都通过这个监视器输入。

然后通过I/O控制接口将这些命令发送到KVM的内核模块部分。Nitro的大部分功能都是在这些内核模块中实现的。最后，利用proc文件系统实现输出。也就是说，Nitro在proc文件系统中创建一个节点，获得它的输出就像从文件中读取一样简单。

#### 4.1 VMI Mechanisms for Trapping System Calls

在某些情况下，硬件制造商提供的虚拟化扩展支持捕获感兴趣的特定事件，这使得工作变得简单。然而，硬件扩展通常不支持捕获所需的事件，特别是对于安全机制而言。在这些情况下，我们必须间接地为hypervisor诱导一个陷阱。找到这些用于捕获所需事件的间接方法通常是一项挑战。

结果是，流行的Intel IA-32(即x86)和Intel 64(以前的EM64T)体系结构不支持将系统调用事件捕获到hypervisor。在这种情况下，我们必须找到一种方法，来进行间接捕获。我们通过强制执行由Intel虚拟化扩展(VT-x)支持的系统中断(例如，页面错误、一般保护错误等)来做到这一点。因此，我们有效地创建了一种机制来捕获系统调用，即使硬件扩展本身并不支持这种机制。所产生的控制流如图2所示。由于这三种系统调用机制在性质上有很大的不同，因此必须为每种机制设计一种独特的捕获机制。下面将描述这些捕获机制及其实现。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gjj4t7acdrj30g20ik77w.jpg)

**基于中断系统调用。**系统调用可以实现为用户定义的中断。x86体系结构通过一个中断描述符表(IDT)处理中断。这个IDT可以有多达256个条目，每个条目的长度为8字节。IDT的精确大小和系统内存中IDT所在的地址一起存储在IDTR中。当一个中断发生时，硬件通过IDTR查询IDT以确定适当处理程序的位置，并在那里继续执行，如图1所示。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gjj4w1ygcej30m00p2dk6.jpg)

Intel的VT-x扩展允许将系统中断(中断0到31)捕获到hypervisor，但它们没有提供捕获用户中断(中断32及以上)的机制，而系统调用可能会用到。这意味着我们必须设计一种方法来导致这个用户中断产生一个系统中断。

我们可以通过虚拟化IDT来实现这一点，即将来宾的IDT复制到管理程序中。然后我们必须操作IDTR并捕获对它的所有写访问，从而禁止任何进一步的操作。当IDTR中存储的IDT大小值被添加到基址以获得IDT最后一个有效字节的偏移量时，我们可以将这个大小设置为32·8−1 = 255。这使得所有的系统中断不受影响，然而，调用一个用户中断的所有尝试(即，中断大于31)将导致一个通用的保护故障，因为IDT的边界将被超过。这种方法的优点是IDT不受内存的影响，但是对于用户中断，它会被有效地忽略。

下一步是将所有一般保护错误捕获到虚拟机监控程序，虚拟化扩展本身就支持该系统。然而，我们仍然必须确定我们产生的一般保护故障和那些自然发生的故障之间的区别2。这可以通过检查当前指令并确定它是否是int指令以及中断数是否大于31来完成。

如果我们确定异常是自然的，我们就将此异常注入到客户机并允许其继续。但是，如果我们认识到异常是由用户中断引起的，我们就会查看中断编号，以确定是否捕获了一个系统调用。如果是这种情况，我们依照Nitro数据收集引擎的规则收集数据(见第4.3节)。在任何一种情况下，都必须使用从来宾操作系统中复制出来的IDT来模拟int指令，并将控制交还给来宾操作系统。

**SYSCALL-based系统调用**。系统调用也可以使用SYSCALL指令及其对应的模拟指令SYSRET来实现。它们都依赖于一组MSR（Model Specific Register，是x86架构中的概念，指的是在x86架构处理器中，一系列用于控制CPU运行、功能开关、调试、跟踪程序执行、监测CPU性能等方面的寄存器。），即STAR MSR、CSTAR MSR和LSTAR MSR。准确地使用这些寄存器中的哪一个取决于来宾操作系统是在旧模式、长模式还是兼容模式下运行。此外，通过在扩展特性Enable寄存器(EFER)中设置和取消设置SCE标志，可以有效地打开和关闭这种机制。使用未设置SCE标志的SYSCALL或SYSRET都会导致无效的操作码异常。

然后，强制这种机制导致系统中断需要取消SCE标志并设置hypervisor来捕获所有无效的操作码异常，虚拟化扩展本身就支持这种操作码异常。一旦将控制权传递给虚拟机监控程序，我们必须再次区分自然异常和内省引起的异常。这是通过查看违反的指令来实现的，如果该指令不是SYSCALL或SYSRET，我们将一个无效的操作码异常注入到来宾操作系统中，并将控制权返回给它。但是，如果违反的指令实际上是SYSCALL，那么Nitro将收集所需的信息，模拟该指令，并将控制权返回给来宾操作系统。

除了模拟SYSCALL指令之外，Nitro还必须能够处理SYSRET指令引起的异常，并模拟该指令。这是由于对EFER所做的更改影响SYSRET指令的方式与影响SYSCALL指令的方式相同。因此，使用SYSRET指令也会导致无效的操作码异常，必须进行相应的处理。在此过程中，如果应用程序需要这些信息，Nitro还能够收集被调用的系统调用的返回值。

**SYSENTER-based系统调用。**与SYSCALL和SYSRET类似，SYSENTER和SYSEXIT指令对也依赖于一组MSR，即SYSENTER CS MSR、SYSENTER ESP MSR和SYSENTER EIP MSR。在调用SYSENTER时，每个msr中的值都被复制到特定的系统寄存器中。对于Nitro的开发来说，尤其有趣的是，当执行SYSENTER时，SYSENTER CS MSR的值会被复制到CS寄存器中，尝试用空值加载CS寄存器会导致一般的保护异常。因此，要引起系统中断，需要在系统管理程序中保存SYSENTER CS MSR寄存器的当前值，并用空值加载它。这将导致每个SYSENTER操作尝试将一个空值加载到CS寄存器中，从而导致系统管理程序可以捕获的系统中断。

一旦虚拟机监控程序捕获了一般的保护异常，区分自然异常和强制异常就再次需要在异常发生时检查当前指令。如果遇到自然异常，就像前面的系统调用机制一样，我们将异常注入到来宾操作系统并允许它继续运行。在遇到一般保护异常且当前指令为SYSENTER的情况下，我们收集相关数据，使用SYSENTER CS MSR的保存值模拟指令，并将控制权返回给客户操作系统。

与基于SYSCALL/ sysret的系统调用机制一样，我们为引起系统中断而对来宾进行的更改也会影响SYSEXIT指令。因此，我们还必须模拟此指令，从而有机会轻松地提取被调用的系统调用的返回值。

#### 4.2 Process Identiﬁcation

能够确定哪个进程产生了系统调用总是很重要的。这要求我们收集每次系统调用中断时进程所特有的信息。Nitro收集CR3寄存器的值以及对应顶级页面目录中的第一个有效条目的值。由于CR3寄存器中的值(即顶级页目录的地址)对于单个进程是惟一的，因此这允许我们识别进程。为了处理这个案子的新创建的进程收到一个顶级页面目录位于相同的位置以前破坏过程的顶级页面的目录,我们还要考虑第一个有效的进入相应的顶级页面目录,以创造一个真正独特的标识符。



#### 4.3 Collection of System Call Data

根据我们的经验，用于系统调用跟踪的不同应用程序依赖于不同数量的信息。在某些情况下，不带参数的简单系统调用号序列可能就足够了，而其他场景可能需要详细的信息，包括寄存器值、基于堆栈的参数和来自一小部分系统调用的返回值。由于我们不能预见每一个客户操作系统类型和系统调用跟踪的可能应用，Nitro不提供每个系统调用的固定数据集。相反，它允许用户定义灵活的规则，以细粒度的方式控制系统调用跟踪期间的数据收集。

例如，用户可以指定来宾操作系统存储系统调用号的确切位置(通常在EAX寄存器中)。Nitro可以然后提取这个系统调用号码连同过程标识符，如第4.2节所述。对于某些机器学习技术来说，这些信息通常足够用于检测进程中的恶意软件或恶意行为[9,6]。

在其他情况下，系统调用参数甚至参数指向的解引用内存变量是至关重要的。为了满足这些要求，除了直接打印寄存器值或取消引用外，Nitro的规则具有足够的表现力，可以同时传递基于堆栈和基于寄存器的参数。这种规则的语法采用以下格式:

add_scmon_rule CONDITION_REG CONDITION_VAL ACTION_REG OFFSET ACTION,

CONDITION_REG包含要测试以确定是否应该输出进一步信息的寄存器的名称。CONDITION_VAL包含CONDITION REG应该包含的值，以便进一步输出信息,ACTION_REG包含寄存器的名称，包含我们感兴趣的基础值,OFFSET包含我们感兴趣的数据相对ACTION REG的偏移(正面或负面),ACTION定义输出应该采取的格式，这包括导致将数据打印或取消引用为十六进制、整数、无符号整数或字符串的操作。我们在附录a中以Backus-Naur格式提供了对规则的描述。比如，可以很容易地指定一个规则，该规则可以取消引用并输出每次用户进程在Linux客户中使用write系统调用时写入的字符串。这条规则看起来如下:

`add_scmon_rule rax 4 rcx 0 derefstr`

这种基于规则的信息请求方法使Nitro非常灵活，并有助于其操作系统不可知的特性。

牢记Nitro的设计目标，我们只收集其位置和格式由硬件规范定义或为其指定规则的信息。然而，Nitro的灵活设计允许轻松地结合客户操作系统的特定知识，以便收集关于调用过程的额外信息。我们已经成功地将Nitro与我们研究小组内的其他项目结合在一起，将过程和用户id等信息包含到输出中。然而，我们保持这些项目分开，以保持Nitro尽可能简单和灵活。这使得Nitro可以应用于更广泛的应用领域。当与我们称为InSight的内存分析工具结合使用时，我们能够产生如图3所示的输出。这提供了额外的来宾操作系统特定信息，比如写入的描述符类型，同时允许Nitro仍然适用于广泛的来宾操作系统。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gjjbdsfwr9j31240r0jwm.jpg)

#### 5 Discussion and Evaluation

在大多数基于vm的机制中，性能开销成为一个问题。因此，务必将对hypervisor不必要的陷阱保持在10个绝对最小值。在第4节中描述的所有机制中，我们使用系统中断来促进对hypervisor的陷阱，因为系统调用本身是不能被跟踪的。

在我们的实现中，我们查看了各个系统调用机制，并确定了每个系统调用机制可以生成的所有系统中断，以及如何诱导它们。然后我们检查了所有可行的解决方案，并考虑了它们对性能的影响。例如，所有三种系统调用机制都可以产生页面错误，但是我们传递它有两个原因。首先，在常规系统活动中经常发生页面错误(相对于其他系统中断)。这意味着每个页面错误都会给hypervisor带来一个昂贵的陷阱，以区分强制的和“自然的”页面错误，其中大多数是自然的。其次，这将从本质上抵消任何通过使用扩展页表或嵌套页表而获得的性能改进。通常，我们努力使得这些不经常发生的系统中断发生在正常操作期间，并且这种中断的使用不会影响系统其他部分的性能改进。这就是我们如何实现的，并使我们的系统能够进行实时收集。

重新审视:客户操作系统的可移植性。Nitro是guest OS可移植的，因为在第4节中描述的所有三种机制都只使用硬件知识。这使得这些机制可以在任何兼容x86或Intel 64架构的来宾操作系统上工作。IDTR和IDT以及所有涉及的msr和它们的用途都是由硬件体系结构指定的，必须按照指定的方式使用。也就是说，无论客户OS是什么，任何客户OS都必须根据规范使用这些硬件机制

guest OS可移植性的一个潜在障碍是，如何在内核和用户空间之间传递信息是留给OS设计者的。例如，一些OSs被设计成系统调用参数在寄存器中传递，而另一些则在堆栈中传递参数。Nitro通过提供在4.3节中描述的灵活规则集来解决这个问题。也就是说，用户可以通过在运行时指定规则来控制收集哪些数据。这允许Nitro通过简单地更改规则集在所有来宾操作系统上使用。在我们的实验中，我们通过每次更改规则集来收集Windows XP(32位)和Ubuntu Linux(32位和64位)的系统调用跟踪。

重新审视:Evasion-resistance。我们合理地假设hypervisor本身是安全的。此外，由于虚拟机监控程序的隔离属性，驻留在虚拟机监控程序中的任何组件都可以免受来自来宾操作系统的攻击。
虽然我们有上述关于hypervisor本身的假设，但仅这一点是不够的。这是因为我们的VMI机制更改了来宾VM的状态。这些状态更改显然不受隔离属性的保护，因为它们发生在来宾操作系统本身中。恶意实体可能只是恢复我们对系统状态所做的更改，以绕过我们的安全机制。由于这个原因，我们采取了特别注意，以确保Nitro是抗躲避。

如第3节所述，规避要求VMI机制植根于硬件，并保护每个涉及的VM状态不受操纵。由于用于快速系统调用机制的VMI机制和基于中断的机制在这方面略有不同，因此下面将分别对它们进行讨论。

为了实现用于快速系统调用的抗evasion的VMI机制，如第3节所述，它植根于SYSENTER CS MSR(基于SYSENTER)或EFER(基于syscape)。此外，VMI机制可以保护每个寄存器不受操纵，而提供的虚拟化扩展直接支持操纵。这足以实现避遁性，因为Nitro对系统调用机制的操作被限制在这些寄存器上。也就是说，由于我们对系统所做的更改，所有快速系统调用都被困在系统管理程序中，如果不对Nitro保护的系统的那些部分进行更改，恶意实体就无法绕过这个问题。因此，这种方法既植根于硬件，又保护了所有涉及的VM状态，从而产生了一种规避机制。

使基于中断的系统调用陷阱具有规避能力类似于描述的快速系统调用的方法，只不过增加了一个步骤。该机制植根于IDTR，并且该寄存器受到保护，不受hypervisor恶意操作的影响。此外，在引导时在系统管理程序中创建原始IDT的影子副本。这已经足以实现规避，因为对来宾操作系统的更改仅限于此寄存器。此外，对于每个用户中断，只有影子IDT被引用。也就是说，对来宾操作系统中IDT的任何更改都不会影响捕捉用户中断的能力。为了阻止这种情况发生，恶意实体将不得不直接操作IDTR或管理程序中的影子IDT，这两者都在虚拟化扩展的帮助下受到保护。

### 6 Performance Testing

在本节中，我们将展示所有来宾操作系统测试的一般性能测试结果，包括:Windows XP SP2(32位)、Ubuntu Linux 9.04服务器(32位)和Ubuntu Linux 9.04服务器(64位)。测试在Intel Core 2 Duo处理器上进行，处理器为2.4 GHz，内存为2g。我们使用Debian Lenny(5.0.6 64位)主机系统进行所有测试。最后，我们使用KVM 0.12.4作为管理程序。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gjk1lh1o6kj31300la0yn.jpg)

这些测试是通过在guest OSs上运行一次禁用Nitro的基准测试，然后在启用Nitro的情况下运行一次基准测试，并比较这些结果。虽然结果本身很有趣，但我们主要关注观察到的退化量，因为退化是系统调用跟踪引起的开销的一个强有力的指示器。

在这些测试中，我们确保测试了每个机制。也就是说，我们提供了一些测试，这些测试测量基于SYSENTER、基于SYSCALL和基于中断的系统调用的机制的性能。需要注意的是，在测试基于中断的系统时实现的机制通过将中断重定向到IDT中的一个新的gate描述符来调用函数，而不是模拟int指令。下面的小节展示了我们的结果。所有的分数和时间都是超过三分或分的平均值。

Windows XP。在测试Windows XP客户操作系统时，我们使用了两款商业基准测试产品，即Futuremark的PCMark05和PassMark的PerformanceTest。这些工具执行各种CPU、内存、磁盘驱动器和图形测试。每个系统都大量使用系统调用，Nitro的输出就证明了这一点。PCMark05为每个执行的测试返回一个值，而PassMark则输出一个单独的组合分数。

所有测试的标准差都可以忽略不计，除了“HDD”和“病毒扫描”测试，我们观察到它们的标准差分别为6.3和61.0。我们假设这是由于这两个测试都是磁盘I/O密集型测试。在任何情况下，为了完整起见，我们给出这些结果，但是，由于它们与平均值的偏差很大，我们不会从这些值中得出任何结论。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gjk1xxvvjqj312y0ksjwv.jpg)

对于这些测试，我们可以修改虚拟硬件，让来宾操作系统确定SYSENTER和SYSEXIT指令不可用，从而使用基于中断的机制进行系统调用。这允许我们测试基于系统调用机制(表1)和基于中断的系统调用机制(表2)的性能。

值得注意的是，在这两组测试中，不同基准测试的性能下降差异很大，但是性能下降最低的基准测试(< 10%)都执行某种类型的压缩、解压缩、加密或解密。这些函数是高度算术的，并且执行的系统调用相对较少，因为这些算术操作不需要OS支持。我们认为，这就是在基准测试中出现退化变化的原因。虽然PCMark05测试(前9基准在表1和2)非常适合程度的识别系统调用的操作开销的影响机制,我们认为由性能测试结果给一个更好的性能下降的总体印象来宾操作系统。

Ubuntu Linux。为了测试所有的Linux来宾操作系统，我们创建了一个使用Linux中的“time”命令的脚本。使用这个实用程序，我们测量了Apache web服务器2.2.16的编译时间。时间工具使用硬件时钟，我们事先验证了VM内的硬件时钟与主机系统的硬件时钟是一致的。我们使用它作为基准测试，因为它的资源密集程度足以显示性能的下降，并且广泛使用了系统调用，如Nitro的输出所证明的那样。

表3给出了在Ubuntu Linux 9.04服务器(32位)客户操作系统上执行的测试结果。与对Windows XP SP2 guest的测试一样，我们操作虚拟硬件，以便能够报告基于中断和基于系统调用机制的结果。考虑到这些结果，我们注意到基于中断的来宾操作系统比基于系统的来宾操作系统带来的性能下降更小。这是因为捕获SYSENTER指令的机制需要模拟该指令，而捕获int指令的机制则不需要。

我们用于64位Linux客户操作系统的测试过程与我们用于32位Linux客户操作系统的测试过程完全相同，唯一明显的例外是我们使用的是Ubuntu Linux 9.04服务器(64位)。这个操作系统的32位版本和64位版本之间一个值得注意的区别是，64位版本使用了基于SYSCALL的系统调用机制，这使得它成为使用该指令的唯一测试用例。这些结果也显示在表3中。通过比较这个客户机和它的32位对等物的退化情况，可以发现这个操作系统在Linux客户机中退化得最厉害。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gjk2axvtayj30z40aotb0.jpg)

### 7 Comparison

我们选择了比较系统Ether[4]因为Ether系统是我们已知的唯一的其他系统(除了HyperSleuth[10],基地的系统调用跟踪Ether的方法),它支持某些形式的系统调用跟踪使用VMI，无需在来宾操作系统安装驱动程序或模块。在功能和性能方面，Nitro在系统调用跟踪和监控方面优于Ether。在本节中，我们将进一步详细讨论这些差异。

