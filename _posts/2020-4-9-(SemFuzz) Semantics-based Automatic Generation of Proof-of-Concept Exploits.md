---
layout:     post
title:      (SemFuzz) Semantics-based Automatic Generation of Proof-of-Concept Exploits
subtitle:   ccs17
date:       2020-04-09
author:     qzwerty
header-img: img/blog-bj-1.png
catalog: true
tags:
    - security analysis




---

## (SemFuzz) Semantics-based Automatic Generation of Proof-of-Concept Exploits

软件供应商经常向用户提供有关软件漏洞的补丁和相关信息，以便及时修复漏洞。不幸的是，系统更新过程缓慢，会给攻击者足够的时间来恢复隐藏的bug，攻击未打补丁的系统。更糟的是，通过逆向工程补丁，输入验证缺陷（input-validation ﬂaws）可能会自动生成漏洞，尽管此类漏洞较少（占过去几年所有Linux内核漏洞的5%）。然而，其他与bug相关的信息很少被关注（如CVE中的bug描述），尤其是利用这些信息是否可以促进漏洞利用生成，即使是在其他从未被自动攻击过的漏洞类型。

在这篇文章中我们利用这些信息来为不会自动攻击的漏洞类型产生proof-of-concept (PoC) exploits。输入验证缺陷通常通过添加清理检查（sanitization checks）来修补，而修复其他类的漏洞要复杂得多，通常涉及到替换整个代码块。如果不了解更改后的代码，很难进行自动漏洞利用。因此我们提出SemFuzz，利用漏洞相关文本（如CVE报告和Linux git报告）来指导PoC漏洞利用的自动生成。这种端到端的方法由基于NLP的信息提取和基于语义的fuzzing实现。SemFuzz运行了过去5年报告的112个Linux内核缺陷，成功触发了其中的18个，并进一步发现了一个0日漏洞和一个未公开漏洞。这些缺陷包括use-after-free，内存泄露，信息泄露等，这表明更复杂的缺陷也可实现自动攻击。这一发现对于当前脆弱点相关信息的共享方式提出了质疑。

KEYWORDS：exploit generation, vulnerability, patch, fuzzing, semantics

### 1 INSTRUCTIONS

如今，软件的漏洞信息和补丁，即便是那些安全关键的补丁，通常都是公开的，以便提高对这些问题的认识，并且促进它们的修复。不幸的是，即使存在安全缺陷，系统更新仍然很慢，如，最近的WannaCry勒索软件爆发，它利用的是永恒之蓝漏洞，永恒之蓝的补丁在几个月之前就发布了。因此，攻击者经常会有一段很长的时间，在此期间利用公开补丁暴露的信息来恢复隐藏的bug，攻击尚未补丁的系统。事实上，大约十年前的研究表明，自动逆向工程一个补丁来生成针对该漏洞的利用是可能的。然而，其他的信息的含义却不为人所知，比如CVE（common vulnerabilities and exposures）系统的报告，Linux的git日志以及论坛和博客上发布的bug描述。从攻击者角度来看，这些信息是否也可用于自动构建更复杂的攻击？从防御方角度看，如何控制这种信息泄露，使自动攻击更难成功？

**自动漏洞利用生成的挑战。**实际上自动漏洞利用的生成很难。先前的研究只针对输入验证缺陷进行攻击，这是一种相对容易发现和修补的bug，因为他们具有显著的特征（缺少清理检查）。基于这种缺陷的exploit可以这样构造，从一个补丁中寻找一个不能通过新添加的检查的输入。换句话说，要生成这样的漏洞，首先使用自动方法找到从程序的入口点到新检查的路径，然后恢复路径上到达检查的约束。这些通过符号执行建立的约束随后被解析，来获取一个导致检查失败的输入，因此很可能导致exploit。

与输入验证缺陷相比，其他类型的脆弱点（如不受控制的资源消耗，死锁，内存泄露等）更加复杂，不能通过简单的添加一个检查来修补。实际上，通常情况下，这些脆弱点相关的语句甚至是整个代码块都需要被补丁替换，这使得漏洞代码很难被检测到。据我们所知目前为止不能自动利用这些复杂的缺陷。

即使是利用输入验证的攻击，符号执行和约束求解也是很难的。对于真实世界中的程序，指向脆弱程序位置的路径约束往往是非线性的，通常呈现为当前的求解器（如，STP）很难找到合适的输入。更糟的是，目标程序中的全局变量，他们的值通常在一个线程中被赋值，但是在另一个线程中被使用。一旦发生这种情况，用于访问脆弱性代码的路径约束就会变得不完整（缺少赋值），在不查看其他线程的情况下无法正确实现。这对于当前的符号执行和约束求解系统来说太复杂了。比如说，CVE-2017-6347报告了一个Linux内核中的脆弱函数ip_cmsg_recv_checksum，被系统调用recvfrom调用。触发脆弱函数的关键条件是填充sk_buff buﬀer，这个缓冲区将在内核结构socket中引用。但是，从recvfrom到脆弱函数的路径上，不存在这样的代码，这个过程是在另一个系统调用sendto中完成的，这个调用应该发生在调用recvfrom之前。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gdq83w02jgj30rq0u8432.jpg)

**我们的方案。**在本文中，我们证明了即使不借助复杂的约束求解技术，也能自动利用复杂的漏洞。我们利用与漏洞相关的非代码文本，特别是CVE报告和Linux git 日志，来提取guidance指导信息，这些指导信息对于帮助发现和触发一组深层次的bug。我们的技术称为基于语义的fuzzing，semantics-based fuzzing (SemFuzz)，自动分析bug日志来利用Linux内核脆弱点创建端到端的PoC exploit，包括double free, use-aer-free 内存泄露等，如表1。与之前的针对输入验证缺陷的工作相比，SemFuzz能够处理内核代码中的各种漏洞。注意，在之前的研究中，只接收单个输入（如，一个文件），是相对简单的程序，而内核代码要复杂得多，它的脆弱组件只能通过一些特定的系统调用序列来访问（如sendto然后recvfrom）。

更具体地说，给定一个报告的漏洞，SemFuzz首先利用NLP来分析它的CVE和git日志报告。**CVE为公开已知的安全漏洞和曝光（exposure）提供了一种参考方法，发布受影响的版本、漏洞类型和脆弱函数等信息。Linux git 日志包括一个补丁和补丁是如何工作的描述。**这些信息对于exploit的生成是非常重要的。如，这些信息告诉我们脆弱程序的确切版本，用于设置正确的测试环境。更重要的是，他还可以解释漏洞的类型、命中目标时会发生什么（崩溃，挂起，内存泄露等）、脆弱函数的位置、甚至是引导程序执行到bug的关键变量和它的值。SemFuzz利用自动收集的信息创建一个到达脆弱函数的调用序列，然后迭代地修改各个调用的参数，使其向函数内部的补丁代码移动，直到触发目标漏洞为止。

这种基于语义的智能fuzzing技术是非常有效的。在我们的研究中运行了CVE在过去5年报告的112个Linux内核漏洞的实现。其中16%成功触发。对于剩下的CVE，虽然SemFuzz没能产生端到端的PoC exploit，但是它自动发现了将程序执行移向脆弱函数的输入，这样可以显著加快手动构建漏洞的过程。在fuzzing内核、触发已知缺陷的过程中，我们的方法甚至发现了一个零日漏洞和一个未公开的漏洞。这些新发现已经得到了Linux内核开发小组的证实。我们的研究表明，这些新的漏洞要么出现在已知缺陷的周围，要么是等价组件内部的类似问题（Section 6.5）。结果表明，公开bug描述确实泄露了关键信息，这些信息实际上可以被用来生成攻击实例，来exploit那些不能只通过补丁分析自动攻击的脆弱点。

**Contribution。**

* **新技术。**我们设计实现了SemFuzz，是第一款基于语义的智能Fuzzer，可以自动从文本报告中识别出脆弱度相关的知识，并利用这些信息来指导测试用例的系统构建，从而触发已知的或相关的未知缺陷。
* **新理解。**我们的研究表明，非代码文本的bug描述（如，CVE，Linux git日志）是重建针对已知漏洞的exploit的重要信息来源。本研究超越了简单的输入验证缺陷，为「通过使用bug相关的公开信息，可以利用更复杂的缺陷来进行自动攻击」提供了证据。这一发现对今天与漏洞相关的信息的共享方式提出了质疑，并需要付出更多努力来控制这些来源的信息泄露。

### 2 背景

**脆弱点和补丁。**脆弱点是软件或硬件组件中的一个弱点，允许攻击者降低系统的信息安全级别。通过利用这些脆弱点，攻击者能够修改系统资源或者影响他们的操作，损害完整性或者可用性。攻击结果包括银行损失数百万美元，数十亿用户的隐私泄露等。补丁的设计是为了减轻这些脆弱点的影响。例如，一个包含输入验证缺陷的程序接受了不安全的输入，这可能会让程序以不正常的方式运行。他们的补丁通常以清除处理的方法区分不安全的输入，并将它们排除。补丁在修复脆弱点的同时，也暴露了脆弱点的信息。具有较强分析能力的攻击者可以对补丁进行逆向工程，甚至实现漏洞利用。注意到开发者端发布补丁到用户端安装补丁的时间间隔平均为30天，这给了攻击者足够的时间来影响大量的用户。如果能够自动生成漏洞利用就更惨了。幸运的是，最近的研究表明，只有输入验证缺陷会导致这个问题；而实际上，由于符号执行的限制，攻击者只能生成对这些脆弱点的一部分漏洞利用。然而，在本文中，我们很惊讶地发现，很多脆弱点类型都暴露了一些问题，包括不受控制的资源消耗，死锁，内存破坏等。

**CVE。**CVE是由US-CERT发起的一个参考系统，用于公开已知的信息安全脆弱点和exposure（暴露）。至今，维护了超过85000个脆弱点。每年，大约有10000个新脆弱点被添加到CVE系统中。每个用户都可以向CVE提交对未知脆弱点的描述（如，受影响的产品和版本，脆弱点类型等）。一旦该脆弱点被软件供应商验证，CVE将为该漏洞分配一个ID以供参考。为了最大限度保护受影响的供应商，在补丁制作完成后，CVE才会公开脆弱点的信息。有趣的是，在本文中，我们发现CVE中的描述可以用来帮助攻击者来快速生成PoC exploit。

**Fuzzing。**Fuzzing是一种自动测试技术，为软件程序提供操作输入，如随机数。通过观察程序执行，fuzzer在不正常运行（如崩溃）被捕获时报告一个脆弱点。由于fuzzing程序的所有输入几乎是不可能的，选择一个相对小的但仍然可以触发脆弱点的输入子集是很重要的。所以fuzzer必须收集各种有价值的信息来指导fuzz过程。一些最近的研究发现，程序的运行状态可以帮助选择输入，以避免重复运行。本文中，我们发现，除了运行状态，CVE和Linux git日志中的非代码描述也可以帮助fuzzer避免不必要的运行，在fuzzing过程中节省了大量的时间。特别是，我们使用基于语义的方法（例如，NLP）自动分析描述并提取必要的信息提供给fuzzer。

### 3 SemFuzz：设计概述

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gdsgs82ye8j31100j8n8b.jpg)

为了解决触发深层次脆弱点的挑战，我们的解决方案是利用从与漏洞相关的文本源收集的语义信息来fuzz目标程序。这样，我们可以避免产生复杂的输入约束，也可利用新发现的知识来指导exploit的构建。过程如图1，主要包括两个阶段：（1）语义信息检索（2）基于语义的fuzz。

