---
layout:     post
title:      Protecting Cloud Virtual Machines from Commodity Hypervisor and Host Operating System Exploits
subtitle:   操作
date:       2020-09-03
author:     qzwerty
header-img: img/blog-bj-1.png
catalog: true
tags:
    - security analysis





---

## Protecting Cloud Virtual Machines from Commodity Hypervisor and Host Operating System Exploits

云计算提供商广泛部署虚拟机监控程序来支持虚拟机，但它们日益增长的复杂性带来了安全风险，因为大型代码库包含许多漏洞。我们创建了一种新的虚拟机监控程序设计，用于使用微内核原则对现有的商品虚拟机监控程序进行改造，以减少其可信计算基础，同时保护虚拟机的机密性和完整性。hypSec把hypervisor分为一个不受信任的主机，在不访问虚拟机数据的情况下执行最复杂的虚拟机监控程序功能，以及一个受信任核心，提供对虚拟机数据的访问控制并执行基本的CPU和内存虚拟化。使用硬件虚拟化支持隔离和保护受信任的核心，并在更高的特权级别上执行它，以便它能够协调虚拟机异常并保护CPU和内存中的VM数据。随着应用程序越来越多地使用云中的安全网络连接，HypSec采用端到端的方法来保护I/O，从而简化其设计。我们使用了HypSec来改进KVM，展示了我们的方法如何支持与普通操作系统集成的广泛使用的全功能hypervisor。该实现有一个只有几千行代码的可信计算基础，比KVM少了许多数量级。我们展示了，在真正的应用程序工作负载下，在只带来适度的性能开销的情况下，hypSec保护了运行未修改的客户操作系统的虚拟机的机密性和完整性。

### 1 Introduction

成本效益高的商品云提供商的出现，促使越来越多的公司和用户将数据和计算转移到运行在云主机上的虚拟机(VMs)中。虚拟机监控程序提供VM抽象，并完全控制硬件资源。现代管理程序通常与主机操作系统(OS)内核集成，以利用现有内核功能来简化其实现和维护工作。例如KVM[44]与Linux集成，Hyper-V[56]与Windows集成。其结果是对CPU寄存器、内存、I/O数据和引导映像中的VM数据的访问造成了巨大的潜在攻击面。将计算资源外包到云以及远离私有数据中心的激增，进一步加剧了依赖复杂且潜在脆弱的hypervisor和主机OS基础设施的可信赖性的安全风险。成功利用虚拟机监控程序漏洞的攻击者可以不受限制地访问VM数据，并损害所有VM的隐私和完整性——这对于云提供商和用户来说都是不希望出现的结果。

应用程序设计和硬件虚拟化支持的最新趋势为重新审视hypervisor的设计需求提供了机会，以解决这个关键的安全问题。首先，现代硬件包括虚拟化支持，可以在比vm更高的特权级别保护和运行虚拟机监控程序，这可能为重新设计虚拟机监控程序以提高安全性提供了新的机会。其次，由于斯诺登泄密泄露了对大部分网络基础设施[49]的秘密监视，人们对安全意识的提高，越来越多的应用被设计为对I/O通道使用端到端加密，包括安全网络连接[29,50]和磁盘加密[14]。这减少了对管理程序自身安全I/O通道的需求，因为应用程序可以更好地提供端到端I/O安全解决方案[68]。

基于这些趋势，我们创建了HypSec,一个新的虚拟机监控程序设计，用于改进普通虚拟机监控程序，以在保持其完整功能的同时显著减少其可信计算基础(TCB)的代码大小。这种设计采用了微内核原则，但是不需要从头开始重新编写——这是一项困难的任务，会限制功能和部署——只需稍加修改就可以应用它们来重组现有的hypervisor。它将一个单片管理程序划分为一个小的受信任核心(corevisor)和一个大的不受信任主机(hostvisor)。利用硬件虚拟化支持隔离和保护协作者，并在比主机监控程序更高的特权级别上执行它。协同修改器强制执行访问控制以保护CPU和内存中的数据，但依赖于vm或应用程序使用端到端加密的I/O来保护I/O数据，从而简化了协同修改器的设计。
corevisor拥有对硬件资源的完全访问，支持基本的CPU和内存虚拟化，并协调所有异常和中断，确保只有VM和corevisor才能访问CPU和内存中的VM数据。更多的复杂操作(包括I/O和中断虚拟化)以及资源管理(如CPU调度、内存管理和设备管理)都委托给hostvisor，后者也可以利用主机操作系统。hostvisor可以通过导入或从系统导出加密的VM数据，以引导VM映像或支持hypervisor的特性，如快照和迁移，但除此之外不能访问VM数据。HypSec重新设计hypervisor以提高安全性，但并不剥夺它的功能。我们希望，可以使用HepSec来重构现有的虚拟机监控程序：通过将许多代码基封装在hostvisor中，并使用一个corevisor增强安全性。

通过对KVM的改造，我们实现了一个HypSec的原型。我们的方法利用了现有的ARM硬件虚拟化扩展，来在具有自己集成主机OS内核的功能齐全的商品管理程序中提供VM机密性和完整性。我们的实现只需要对Linux进行适当的修改，并且TCB只有几千行代码(LOC)，比KVM和其他商品管理程序要小很多个数量级。HypSec显著降低了现有广泛使用的hypervisor的TCB并提高了其安全性，同时保留了相同的hypervisor功能(包括多处理器、全设备I/O、多VM、VM管理和广泛的ARM硬件支持)的。我们还展示了，在真实的应用程序工作负载下，在运行未修改的客户操作系统时，HypSec为vm提供了强大的安全性，而只带来适度的性能开销。

### 2 Assumptions and Threat Model

**假设。**我们假设虚拟机使用端到端加密通道来保护它们的I/O数据。我们假设硬件虚拟化支持，IOMMU类似于云中的x86和ARM服务器。我们假设由安全模式架构(如ARM TrustZone[7])或可信平台模块(TPM)[38]提供的可信执行环境(TEE)可用于可信持久存储。我们假设硬件(包括硬件安全模块(如果适用))是无bug且值得信任的。我们假设HypSec TCB，corevisor，没有任何漏洞，因此可以信任。由于corevisor的大小适中，如6.3节所示，正式验证代码库是有可能的。我们假设对任何加密的VM数据执行暴力攻击在计算上是不可行的，并且假设任何加密的通信协议都是设计来防御重放攻击的。我们假设系统最初是良性的，允许在危及系统之前将签名和密钥密封在TEE中。

**威胁模型。**我们考虑能够远程访问系统管理程序及其vm的攻击者，包括对计算机没有物理访问权的管理员。攻击者的目标是,保证虚拟机数据的机密性和完整性,包括:包含客户内核二进制文件的VM引导映像、驻留在属于客户的内存地址中的数据、复制到硬件缓冲区的客户内存、VM磁盘或文件系统上的数据和存储在VM CPU寄存器中的数据。VM数据不包括通用虚拟硬件配置信息，比如CPU电源管理状态或正在提高的中断级别。攻击者可以利用主机监控程序中的bug或控制VM管理接口来访问VM数据。例如，攻击者可以利用主机监控程序中的bug执行任意代码或从VM或hypervisor主机访问VM内存。攻击者也可以通过直接内存访问(DMA)控制外围设备来执行恶意内存访问。如果提供VM基础设施的整个云提供商是恶意的，我们认为这就超出了范围。

远程攻击者没有对硬件的物理访问权限，因此以下攻击超出了范围:对硬件平台的物理入侵、冷启动攻击[31]、内存总线窥探和物理内存访问。使用现场保安及防窜改硬件，可较好地处理这些威胁;云计算提供商如谷歌竭尽全力确保其数据中心的物理安全性，甚至限制管理员[28]的物理访问。我们也不防御在虚拟环境[39,53,65,93,94]中或基于网络I/O的侧信道攻击，[10]。这不是HypSec唯一的，使这样的模式混淆与hypSec正交的防御是内核的责任。
我们假设虚拟机不会主动泄露自己的敏感数据，无论是有意还是无意。远程攻击者可以利用虚拟机中的漏洞破坏虚拟机。我们没有提供安全特性来防止或检测VM的漏洞，因此一个被破坏的VM不自觉地泄露自己的数据是超出了范围的。然而，攻击者可能试图从我们提供保护的被破坏的VM攻击其他托管的VM。

### 3 Design

HypSec引入了一种新的管理程序设计，减少了保护VM机密性和完整性所需的TCB，同时保留了成熟的管理程序功能。我们观察到，可以在不访问VM数据的情况下支持许多hypervisor函数。例如，对于CPU调度，VM CPU寄存器数据是不必要的。基于这一观察结果，hypsec利用微内核设计原则将单片虚拟机监控程序分成两部分，如图1所示:一个受信任且有特权的corevisor，可以完全访问VM数据;另一个不受信任且没有特权的hostvisor，可以代理大部分虚拟机监控程序功能。不同于以前的微内核方法[1,13,51]，需要进行全新的重新设计，HypSec专门设计了少量修改来重组现有的虚拟机监控程序。如第4节所述，以这种方式分割虚拟机监控程序可以显著减小TCB，它仍然足够灵活，可以实现现代虚拟机监控程序特性。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gii2gwyx00j30r80o0jva.jpg)

corevisor保持较小规模，仅执行VM数据访问控制和需要完全访问VM数据的hypervisor功能:安全VM引导、CPU虚拟化和页表管理。随着应用程序越来越多地使用安全通信通道来保护I/O数据，HypSec采取端到端的方法来简化其TCB，并允许hostvisor提供I/O和中断虚拟化。 hostvisor还处理其他不需要对VM数据进行交互的复杂功能，包括资源管理，如CPU调度和内存分配。 hostvisor甚至可以合并一个完整的现有操作系统内核来支持其特性。

HypSec以一种新的方式利用现代硬件虚拟化支持来强制管理程序分区。在专为运行管理程序而设计的更高特权CPU模式下运行corevisor，赋予它对硬件的完全控制，包括虚拟化硬件机制，如嵌套页表(NPTs)。corevisor通过在特权较少的CPU模式下运行主机监控程序和VM内核来取消它们的特权。例如，在使用图3所示的ARM虚拟化扩展(VE)实现的HypSec中，corevisor在hypervisor (EL2)模式下运行，而主机监控程序和VM内核则在特权较少的内核(EL1)模式下运行。corevisor插入所有异常和中断，使其能够提供访问控制机制，阻止主机监控程序访问VM CPU和内存数据。例如，corevisor拥有自己的内存，并使用NPTs强制主机监控程序、vm和自身之间的内存隔离。被破坏的主机监控程序或VM既不能控制硬件虚拟化机制，也不能访问协同修改或内存，因此不能禁用HypSec。

**HypSec Interface.**如图1所示，corevisor向hostvisor公开一个简单的API，并插入所有hostvisor与VM交互，以确保VM在整个VM生命周期中安全执行。当 hostvisor调用corevisor的VM CREATE和VM BOOT调用以使用经过验证的VM映像安全地引导它时，VM的生命周期就开始了。hostvisor被剥夺特权，不能执行vm。它必须调用VM ENTER来请求corevisor执行VM。当VM因为发生中断或异常而退出执行时，它将陷入到 corevisor，后者检查退出的原因，如果需要，将返回到hostvisor。 corevisor向 hostvisor中的设备驱动程序提供IOMMU OPS API，用于管理IOMMU，如3.3节所述。虽然hostvisor不能访问CPU或内存中的VM数据，但它可以通过GET VM STATE hypercall API请求corevisor提供一个加密的VM数据副本。hostvisor可以使用API来支持需要将VM数据导出到磁盘或跨网络的虚拟化特性，比如将VM内存交换到磁盘，或者VM快照和迁移等VM管理功能。corevisor仅使用加密来导出VM数据。它从不使用加密，只使用访问控制，以保护CPU或内存中的VM数据。

#### 3.1 Boot and Initialization

**Corevisor引导。**HypSec确保可信的corevisor二进制文件被引导并且引导代码本身是安全的。为了确保只有可信的corevisor二进制文件被引导，HypSec依赖于统一可扩展固件接口(UEFI)固件和具有信任硬件根的签名基础设施。hostvisor和corevisor作为一个由云提供商以加密方式(“数字”)签名的二进制文件链接在一起，类似于红帽或微软等供应商签署操作系统二进制文件的方式。使用TEE提供的安全存储中的密钥来验证HypSec二进制文件，从而保证只有经过签名的二进制文件才能被加载。

为了确保引导代码是安全的，HypSec可以在可信的corevisor中实现它，但是没有。裸机hypervisor实现了引导，但是这给实现和维护带来了很大的负担。代码必须手动移植到每个不同的设备上，这使得支持广泛的系统变得更加困难。相反，由于hostvisor最初是良性的，所以HypSec依赖于hostvisor的引导代码来在引导时安全地安装corevisor。在引导时，hostvisor最初拥有对系统的完全控制，以初始化硬件。hostvisor在进入用户空间之前安装corevisor;网络和串行输入服务还不可用，所以远程攻击者不能破坏corevisor的安装。安装后，corevisor获得对硬件的完全控制，并随后取消hostvisor的特权，确保hostvisor永远无法控制硬件或访问corevisor的内存来禁用HypSec。使用在引导时提供的信息，corevisor是自包含的，无需任何外部数据结构即可运行。

**VMBoot.**在VM引导和初始化期间，HypSec也保证了VM数据的机密性和完整性。HypSec通过将复杂的引导进程委托给untrusted hostvisor，并在运行任何loadedvm映像之前在corevsor中对它们进行验证，可以保持TCB较小。如图1所示，当创建一个新的VM时，hostvisor 与corevisor一起参与经过验证的引导过程。hostvisor调用VM CREATE来请求corevisor在corevisor内存中分配VM状态，包括一个NPT和VCPU状态、每个虚拟CPU (VCPU)数据结构。然后调用VM BOOT请求协作者对加载的VM映像进行身份验证。如果成功，那么hostvisor可以调用VM ENTER来执行VM。换句话说，hostvisor存储VM映像并将它们加载到内存中，从而避免在corevisor中实现此复杂过程。corevisor使用公钥加密验证VM映像的加密签名，避免了用户与HypSec之间的任何共享秘密。

在任何攻击之前，公钥和VM映像签名都存储在TEE安全存储中，如图1所示。如果VM内核二进制文件是分离的，并且可以单独映射到内存中，那么hostvisor将调用corevisor来验证映像。如果VM内核二进制文件位于VM磁盘映像的引导分区中，那么支持分层的虚拟固件将引导VM。固件像VM引导映像一样经过签名和验证。固件然后从明文VM磁盘分区加载签名内核二进制文件或签名引导加载程序，如GRUB。固件然后调用corevisor来验证VM内核二进制文件或引导加载程序。在后一种情况下，引导装载程序使用虚拟磁盘上的签名验证VM内核二进制文件;GRUB已经支持这一点。GRUB还可以在带签名的GRUB二进制文件中使用公钥。corevisor确保只有经过验证的映像(内核二进制文件、虚拟固件或引导加载程序二进制文件)才能映射到VM内存。最后，corevisor将VM程序计数器设置为VM映像的入口点，以安全地引导VM。

正如在3.5节中所讨论的，HypSec期望作为端到端加密方法的一部分对VM磁盘映像进行加密。用于解密VM磁盘的任何密码或秘密都不会暴露给hostvisor。常用加密磁盘格式[6,57]使用用户提供的密码来保护解密密钥。可以使用云提供商的密钥管理服务(KMS)在本地或远程存储加密的密钥文件[5,58]。KMS维护一个密钥，该密钥由管理员预加载到主机的TEE安全存储中。协同修订者使用密钥解密加密的密钥文件，并将生成的密码映射到VM内存中，从而允许VM获得密码而不将其暴露给hostvisor。VM迁移采用相同的密钥方案;HypSec使用来自kms的密钥对VM状态进行加密和解密。

#### 3.2 CPU

虚拟机监控程序通过执行四个主要功能来提供CPU虚拟化:处理来自VM的陷阱;模拟客户操作系统执行的特权CPU指令，以确保hypervisor保持对CPU硬件的控制;保存和恢复VM CPU状态，包括GPRs和系统寄存器，如页表基寄存器，在VM之间以及VM和hypervisor之间切换时需要;以及在物理cpu上调度vcpu。在执行这四种功能中的任何一种时，虚拟机监控程序通常对VM CPU状态具有完全访问权，如果虚拟机监控程序受到破坏，则可能对VM安全性造成问题。

通过将对VM CPU状态的访问限制为corevisor，在将不需要对VM CPU状态进行访问的复杂CPU功能委托给hostvisor时，该策略保护VM CPU状态不受主机监控的影响，同时保持其TCB较小。这是通过让corevisor处理来自VM的所有陷阱、指令模拟以及VM与主机监控程序之间的世界切换来实现的，所有这些都需要访问VM CPU状态。VCPU调度被委托给hostvisor，因为它可以在不访问VM CPU状态的情况下完成。

corevisor将硬件配置为将VM中的所有陷阱(以及3.4节中讨论的中断)路由至corevisor，确保其保留完整的硬件控制。它还取消了hostvisor的特权，以确保hostvisor无法访问corevisor状态。因为来自VM的所有陷阱都指向corevisor，所以corevisor可以代表VM捕获和模拟CPU指令。协同修改器在主机监控程序和硬件上的vm之间多路传输CPU执行上下文。corevisor在VM创建时分配的VCPU状态内存数据结构中维护VCPU执行上下文，并在类似的Host state数据结构中维护hostvisor的CPU上下文;这两种状态只能由corevisor访问。在VM退出时，corevisor首先将VM执行上下文从CPU硬件寄存器保存到VCPU状态，然后将hostvisor的执行上下文从主机状态恢复到CPU硬件寄存器。当hostvisor调用corevisor重新进入VM时，corevisor首先将其执行上下文保存为主机状态，然后将VM执行上下文从VCPU状态恢复到硬件。VM CPU状态的所有保存和恢复都是由corevisor完成的，只有corevisor才能运行VM。

hostvisor处理VCPU调度，这可能涉及复杂的调度机制，特别是对于多处理器。例如，仅Linux调度器代码就超过了20K LOC，这还不包括与内核其他部分共享的内核函数依赖关系和数据结构。VCPU调度不需要访问VM CPU状态，因为它只涉及将VCPU映射到物理CPU。hostvisor将一个VCPU调度到一个物理CPU，并调用corevisor来运行VCPU。然后，corevisor将VCPU状态加载到硬件上。

默认情况下，HypSec确保了hostvisor不能访问任何VM CPU状态，但有时VM可能会执行一些指令，这些指令要求与可能存储在通用寄存器(GPRs)中的hostvisor共享值。例如，如果VM执行一个包含一些参数的hypercall，并且hypercall由hostvisor处理，那么就有必要将这些参数传递给hostvisor，而这些参数会被存储在GPRs中。在这种情况下，指令将落入corevisor的手中。corevisor将识别需要传递给hostvisor的值，然后将这些值从GPRs复制到每个VCPU中间VM状态结构的内存中，该结构可访问到hostvisor。类似地，hostvisor对中间VM状态结构的更新可以由corevisor复制回GPRs，从而将值传递回VM。GPRs中只有由corevisor显式识别为参数传递的值会被复制到和从中间VM状态;hostvisor无法访问其他CPU寄存器中的值。

根据执行的特定CPU指令，corevisor决定是否及何时从GPRs复制值，以及从哪个GPRs复制值。指令集用于执行hypercall，以及体系结构提供的特殊指令，这些指令通过特定于模型的寄存器(MSRs)、x86指令集中的控制寄存器或内存映射I/O (MMIO)访问虚拟硬件。通常只有少数特定的CPU指令涉及通过GPRs向主机监控程序传递参数，但具体情况取决于体系结构。

例如，在ARM上，HypSec将选择的GPRs复制到虚拟固件接口，来进行电源管理超调用，并将选择的MMIO访问复制到虚拟硬件。对于电源管理hypercalls，客户内核在GPRs中传递输入参数，而corevisor仅将这些GPRs复制到中间VM状态，以使这些参数对hostvisor可用。在返回VM时，hostvisor将输出数据作为电源管理hypercall的返回值，corevisor将这些hypercall从中间VM状态复制回GPRs，使它们对VM可用。正如第3.4节和3.5节所讨论的，在虚拟中断控制器接口或I/O设备的MMIO访问上存储和加载在GPRs中的值也会在选定的GPRs和中间VM状态之间复制，以使它们对hostvisor可用。

#### 3.3 Memory

虚拟机监控程序通过执行三个主要功能来提供内存虚拟化:内存保护(确保vm不能访问未经授权的物理内存)、内存分配(为vm提供物理内存)和内存回收(从vm收回物理内存)。还可以在这些功能的基础上执行其他高级内存管理功能。所有这些函数都依赖于NPTs。客户操作系统管理传统的页表，将客户虚拟内存地址(gVA)映射到客户物理内存地址(gPA)。hypervisor管理NPTs，以便将其从gpa映射到主机物理内存地址(hPA)，从而可以虚拟化和限制VM对物理内存的访问。hypervisor拥有对物理内存的完全访问权，因此它可以直接管理VM内存[11]，或者通过主机OS内核的[23]内存管理api来管理VM内存。因此，受损的虚拟机监控程序或主机OS内核可以不受限制地访问VM内存，并可以读写VM在内存中存储的任何数据。

通过将对VM内存的访问限制为corevisor，可以保护VM内存不受hostvisor的干扰，同时将复杂的内存管理功能委托给hostvisor，无需访问内存中的实际VM数据即可完成。corevisor负责内存保护，包括配置NPT硬件，而内存分配和回收主要委托给hostvisor。HypSec内存保护强加了一个额外的要求，这也是为了保护corevisor和VM内存。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gijhqpu0wjj30rc0i6n0c.jpg)

**内存保护。**corevisor以与现代hypervisor相同的方式使用NPT硬件来虚拟化和严格虚拟机对物理内存的访问，此外还利用了NPTs来隔离hostvisor内存访问。corevisor配置NPT硬件，如图2所示。hostvisor只允许管理自己的页表(主机PT)，并且只能将主机虚拟内存地址(hVAs)转换为我们所说的虚拟主机物理内存地址(vhPAs)。然后，vhpa依次由编辑人员维护的主机嵌套页表(hNPT)转换为hpa。该corevisor采用平面地址空间映射;每个hPA都被绘制成一个相同的hPA。如果hostvisor被授予访问权限，则向其提供与corevisor基本相同的物理内存视图。corevisor阻止hostvisor访问corevisor和VM memory，通过从hNPT 取消内存映射实现。任何hostvisor访问corevisor或VM内存的操作都将被捕捉到corevisor，让corevisor得以拦截未授权访问。物理内存在hostvisor和corevisor之间静态分区，但在hostvisor和vm之间动态分配，如下所述。corevisor从它自己的内存池中分配NPTs，hostvisor无法访问该内存池。所有的VCPU状态也存储在corevisor内存中。

corevisor还通过保留对IOMMU的控制，保护corevisor和VM内存免受DMA攻击[75]。corevisor从内存中分配IOMMU页表，并将IOMMU OPS API导出到hostvisor中的设备驱动程序，以更新页表映射。corevisor验证请求并确保攻击者无法控制IOMMU访问自身或vm拥有的内存。

**Memory Allocation.**vm的内存分配主要是由hostvisor完成的，它可以重用集成的主机OS内核中可用的内存分配功能，以便从其内存池动态地将内存分配给vm。传统的管理程序只是为每个VM管理一个NPT。然而，HypSec的内存模型不允许hostvisor管理VM内存，因此也不允许管理NPTs。hostvisor为每个VM管理一个类似的虚拟NPT (vNPT)，而HypSec为每个VM引入了一个由corevisor管理的影子嵌套页表(sNPT)，如图2所示。sNPT通过隐藏vNPT来管理硬件。当在hostvisor和VM之间切换时，corevisor在hNPT和sNPT之间多路传输硬件NPT基础寄存器。

图2还描述了HypSec的内存虚拟化策略中的步骤。当客户操作系统尝试将gVA映射到未映射的gPA时，会出现嵌套的页面错误，该错误会被corevisor捕获(第1步)。如果corevisor发现错误的gPA位于一个有效的VM内存区域内，那么它将把NPT基寄存器指向hNPT(步骤2),切换到hostvisor来给gPA分配物理页(步骤3)。hostvisor分配一个虚拟物理页被其vNPT vhPA并更新条目对应的断层gPA vhPA分配。因为vhPA映射到相同的hPA，所以主机监控程序能够隐式地管理主机物理内存。然后，主机监控程序捕捉到协同修改者(步骤4)，后者确定故障gPA并识别主机监控程序对vNPT进行的更新。corevisor验证生成的vhPA不属于自身或其他VM(后者通过使用唯一VM标识符(VMID)跟踪物理内存的所有权)，并将这些更新复制到其sNPT中。协同修订器从hNPT中解映射vhPA，以便主机监控程序不再能够访问分配给VM的内存。corevisor更新NPT基寄存器以指向sNPT(步骤5)，并返回VM(步骤6)，以便VM能够访问由与vhPA相同的hPA标识的已分配内存。尽管可能，但它不会删除主机监控程序分配给vm的页面。出于安全原因，来宾操作系统在使用之前已经从空闲列表中删除分配的内存，因此主机监控程序无法将包含恶意内容的页面分配给虚拟机。

与以前的应用程序相比，使用阴影页表可以将多层页表折叠成硬件支持的内容[2,11,16,52,82]。相比之下，催眠使用阴影来保护硬件页表，而不是虚拟化它们。corevisor不会在其页表中隐藏访客OS更新;它只隐藏主机监控程序对vNPT的更新。对于页表同步，它没有从VM引入额外的陷阱。荫蔽[16]为一个给定的虚拟机维护多个影子页表，这些虚拟机提供物理内存的不同视图(纯文本/加密)，以保护应用程序免受不可信的来宾操作系统的攻击。与此相反，为每个VM管理一个影子页表，这些VM提供了gPA到hPA的明文视图。在催眠中的阴影机制也与最近的工作[19]正交，后者使用阴影页表来隔离内核空间内存和用户空间。

**内存回收。**在主机管理程序中支持VM内存回收的同时，在corevisor中保留VM数据在内存中的私密性和完整性。当VM主动释放内存页时(比如在VM终止时)，协同修改程序首先将这些页返回到主机监控程序，以确保回收的内存不会泄漏VM数据，然后将它们映射回hNPT，以便主机监控程序可以访问它们。为了允许主机监控程序在不访问内存中的VM数据的情况下回收VM内存页，催眠利用了膨胀[82]。膨胀在常见的管理程序中得到了广泛的支持，因此在催眠系统中只需要做很少的工作就可以支持这种方法。虚拟机中安装了一个虚拟的“气球”设备。当主机空闲内存不足时，主机监控程序请求气球设备膨胀。气球驱动程序通过从空闲列表中获取页面而膨胀，从而增加了VM的内存压力。因此，来宾操作系统可能开始回收页面或将其页面交换到虚拟磁盘。气球驱动程序通知协作者气球中准备被回收的页面。然后，corevisor将这些页面从VM的sNPT中解映射出来，过滤回收的页面以确保它们不会泄漏VM数据，并将这些页面分配给主机监控程序，后者随后可将其视为空闲内存。将气球放气可以释放客户机中的内存压力，从而允许客户机收回页面。

当主机监控程序感到内存压力时，它还可以安全地将VM内存交换到磁盘。主机监控程序使用GET VM状态来访问加密的VM页面，然后再将其交换出去。稍后，当交换VM页时，协同修改器将切换页从hNPT解映射出来，解密页，并将其映射回VM的sNPT。

**Advanced VM Memory Management.**默认情况下，催眠确保了主机监控程序不能访问任何VM内存，但有时VM可能希望在加密后与主机监控程序共享其内存。催眠提供GRANT_MEM和REVOKE_MEM超调用，来宾操作系统可以显式地使用它们与主机监控程序共享内存。如3.5节所述，这可以用于支持paravirtualizedI/Oofencrypteddatain，为了进行通信和有效的数据复制，必须在VM和主机监控程序之间共享VM拥有的paravirtualizedI/Oofencrypteddatain。VM通过两个超调用将客户物理帧号(GFN)的起始、内存区域的大小和指定的访问权限传递给协作修订者。协同修订器通过控制hNPT中的内存区域映射来强制执行访问控制策略。只有VM可以使用这两个超调用，所以主机监控程序不能使用它来请求访问任意VM页面。

通过将工作分解为简单的协同修改函数(需要直接访问VM数据)和更复杂的主机监控函数(不需要访问VM数据)，可以支持高级的内存虚拟化特性，比如合并类似的内存页面，在Linux中使用KSM[46]。例如，为了支持KSM，主机监控程序向协作者请求VM内存页的散列值，并在其地址空间中维护数据结构，以支持合并算法。corevisor验证主机监控对合并页面的决策，更新相应VM的sNPT，并在授予主机监控访问权限之前过滤释放的页面。尽管KSM不提供主机监控程序或其他VM对VM的内存页的直接访问，但可以使用它泄漏一些信息，比如不同VM之间的内存页内容是否相同。为了避免这种信息泄漏，在默认情况下，催眠禁用了KSM支持。

#### 3.4 Interrupts

管理程序捕获并处理物理中断，以在为vm虚拟化中断时保留对硬件的完全控制。对中断控制器接口的访问可以通过MSRs或MMIO完成。虚拟机监控程序提供一个虚拟中断控制器接口，并捕捉和模拟VM对接口的访问。管理程序中的虚拟设备也可以对接口发起中断。但是，如果虚拟机监控程序受到威胁，让虚拟机监控程序完全控制硬件会给虚拟机安全性带来问题。

为了保护主机监控程序不被破坏，协同修改者配置硬件以路由所有物理中断，并将中断控制器的所有访问捕获到协同修改者，以确保它保留完整的硬件控制。然而，为了简化它的TCB，HypSec委托几乎所有的中断功能到主机监控程序，包括处理物理中断和提供虚拟中断控制器接口。在进入主机监控程序处理中断之前，corevisor会保护所有VM CPU和内存状态，如3.2节和3.3节所述。

主机监控程序不能访问也不需要VM数据来处理物理中断。然而，VM访问虚拟中断控制器接口涉及在VM和主机监控程序之间传递参数，因为主机监控程序提供接口。在ARM上，通过第3.2节中讨论的中间状态结构，只使用MMIO完成此操作。在MMIO写入到中断控制器接口上，VM传递要存储在GPR中的值。写陷阱到编校，它识别指令和内存地址，作为相应的中断控制器接口。corevisor将从GPR写入的值复制到中间VM状态，使该值可用于主机监控程序。例如,当客人在VM操作系统发送一个IPI到目的地通过一个VCPU MMIO写入虚拟中断控制器接口,目的地的标识符个VCPU传递给hostvisor通过复制的价值各自的GPR中间VM状态。类似地，在一个MMIO从中断控制器接口读取，读陷阱到协作者，它识别指令和内存地址，作为相应的中断控制器接口。corevisor将由主机监控更新的中间VM状态中的值复制到VM用于检索值的GPR中，更新VM的PC以跳过错误指令，然后返回VM。

#### 3.5 Input/Output

为了减轻支持awiderangeofvirtualdevices的负担，现代虚拟机监控程序通常依赖于操作系统内核及其现有的设备驱动程序来支持I/O虚拟化，这极大地提高了hypervisorTCB。类似于之前的工作[16,33]，催眠采用端到端的I/O安全方法，依赖于vm进行I/O保护。vm可以利用安全通信通道(如TLS/SSL)进行网络通信，并利用全磁盘加密进行存储。这允许协同修改器放松其I/O保护要求，简化TCB。将I/O虚拟化的支持卸载到不受信任的主机监控程序。由于I/O数据已经被VM加密，一个被破坏的主机监控程序最多只能访问加密的I/O数据，而不会泄露VM数据。

与其他现代管理程序一样，催眠程序支持所有三种I/O设备:仿真的、半虚拟化的和直通的设备;后两者提供更好的I/O性能。虚拟机监控程序通常使用trap-and-仿真来支持仿真I/O设备，以处理端口映射I/O (PIO)和mmio操作。在这两种情况下，都将硬件配置为将操作捕获到协同修改器，后者隐藏除实际I/O数据之外的所有VM数据，然后允许主机监控程序模拟操作。例如，为了支持MMIO，协同修改器将VM的sNPT中对应于虚拟设备I/O区域的地址映射归零。来自VM的任何后续MMIO访问都会导致内存访问错误，该错误会捕捉到协作者。然后，corevisor安全支持MMIO访问，如3.4节所述。我们假设具有安全意识的用户禁用了模拟设备(如串行端口、键盘或鼠标)的使用，以避免将私有信息泄露给受损的主机监控程序。

准虚拟化设备要求VM中的前端驱动程序与hypervisor中的后端驱动程序协调;这两个驱动程序通过共享内存异步通信。后端驱动程序可以安装在不受信任的主机监控程序中。为了支持共享内存通信，前端驱动程序被修改为使用GRANT_MEM和REVOKE_MEM超调用来识别共享数据结构和I/O内存缓冲区，主机监控程序后端驱动程序可以访问它们。由于I/O数据是加密的，所以主机监控程序对I/O内存缓冲区的访问不会危及VM数据。

直通设备被分配给VM并由来宾操作系统管理。为了支持透入I/O，在BAR中配置硬件来捕获敏感操作，比如消息信号中断(MSI)配置，以便捕获到协作者以进行安全模拟，同时授予vm直接访问非敏感设备内存区域的权限。协作者控制IOMMU来强制设备间隔离，并确保传递设备只能访问VM自己的I/O缓冲区。因为我们假设硬件不是恶意的，直通I/O可以安全地在催眠上完成。

#### 4 Implementation

考虑到ARM在服务器系统中的日益流行[4,63,87]，我们将我们的方法应用到主线Linux KVM/ARM [22,23] hypervisor上，从而展示了催眠可以如何提高现有商品管理程序的安全性。表1比较了普通管理程序和当前的催眠实现，显示了这种安全性改进不会损害管理程序特性。由于KVM是与主机OS内核紧密集成的托管虚拟机监控程序，因此对KVM进行改造还可以证明，在支持作为主机监控程序一部分的整个OS内核方面，它是可行的。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gik5jlbdntj30ss0ymq7x.jpg)

对于内存虚拟化，它需要更高特权的CPU模式、嵌套的页表，而对于DMA保护，它需要一个IOMMU。ARM架构满足了这些要求。ARM VE为比用户(EL0)和内核(EL1)模式拥有更严格特权的管理程序提供了Hyp (EL2)模式。EL2有自己的由寄存器和控制状态定义的执行上下文，因此可以在软件中切换EL0和EL1的执行上下文。因此，hypervisor可以在与EL0和EL1隔离的地址空间中运行。ARM VE提供了阶段2页表，这些页表是在EL2中配置的嵌套级页表，影响EL0和EL1中的软件。ARM提供系统内存管理单元(SMMU)[8]来保护DMA。

在机器启动时初始化，并在EL2中运行，以完全控制硬件。催眠的代码嵌入到Linux内核二进制文件中，通过UEFI进行验证和加载。内核在EL2中引导并安装一个陷阱处理程序，稍后返回到EL2。内核进入EL1，这样主机监控程序就可以引导机器。主机监控程序为协作者分配资源并配置硬件。然后，主机监控程序对EL2中的合作者进行超调用，以启用催眠功能。

催眠ARM实现利用KVM/ARM的拆分为一个EL2 lowvisor和一个EL1 highvisor来支持ARM虚拟化架构。这样做是因为EL2是控制硬件虚拟化特性所必需的，但是Linux和KVM被设计为在内核模式EL1下运行。因此，lowvisor管理硬件虚拟化特性和VM-hypervisor开关，而highvisor包含其他的hypervisor和Linux。但是，如果Linux或KVM的任何其他部分被破坏，lowvisor不能保护VM数据;通过KVM/ARM, Linux主机可以不受限制地访问所有VM数据。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gijmjxlt4bj30s40ke77n.jpg)

如图3所示，协同修改器封装了KVM lowvisor并在EL2中运行。主机监控程序(包括KVM highvisor及其集成的Linux OS内核)在EL1中运行。主机监控程序不能访问EL2寄存器，并且不能破坏协同修改或禁用虚拟机保护。HypSec利用ARM VE来强制需要hypervisor干预的VM操作陷入EL2中。corevisor直接处理陷阱以保护VM数据，或将硬件切换至EL1以运行主机监控程序(如果需要更复杂的处理)。当主机监控程序完成其工作时，它进行一个超调用来trap到EL2，以便协同修改者可以安全地将VM状态恢复到硬件上。corevisor插入VM与主机监控程序之间的每一次切换，从而保护VM的执行上下文。我们的实现确保了主机监控程序不能通过超调用调用任意的协同修改函数。

利用ARM VE的阶段2内存转换支持虚拟化VM内存并防止访问受保护的物理内存。corevisor将阶段2页面错误路由至EL2，并拒绝非法主机监控程序和VM内存访问。corevisor从其受保护的物理内存中分配hNPTs和vm的sNPTs，并管理页表。

为了保护DMA，协作者在主机监控程序访问SMMU时使用陷阱和模拟。催眠保证只有合作者有访问SMMU硬件。协作者管理其受保护内存中的SMMU页表，以确保主机监控设备不能访问协作者或VM内存，而分配给VM的设备只能访问VM内存。

它利用VGIC和KVM/ARM现有支持的硬件特性来虚拟化中断。我们的实现支持ARM GIC 2.0。催眠依赖于QEMU和KVM对I/O虚拟化的虚拟设备支持。我们的实现支持通过MMIO实现的模拟设备，通过virtio实现的准虚拟化设备[67]，以及直通设备。对于virtio，我们修改了前端驱动程序，使其使用GRANT/REVOKE_MEM超调用与主机监控程序后端驱动程序共享内存。为了支持直通设备，HypSec将硬件配置为授予vm直接访问它们的权限。我们修改了前端virtio-balloon驱动程序，以通知协作者为气球设备分配的页面。corevisor将这些页面清理并分配给主机监控程序，允许其根据需要安全地回收内存。我们当前的实现不支持页面交换和KSM，这两项工作留给以后做。

使用基于ARM trustzone的TEE框架(如OP-TEE[61])来安全地存储签名和密钥，从而支持安全的VM引导。催眠任务QEMU将VM引导映像加载到VM内存中，但是corevisor要求QEMU参与其验证过的引导过程。corevisor从信任区域检索VM引导映像签名和用户公钥，以验证VM映像重新映射到其地址空间。协同编辑使用Ed25519[62]来验证引导映像。使用到已验证的VM引导映像的映射构建VM的阶段2页表。如果验证失败，则会停止VM引导过程。同样的方案也可以验证VM固件和其他二进制文件。催眠还检索加密的密码，以保护虚拟机的加密磁盘免受信任区或云提供商的密钥管理服务。[45]移植到EL2中运行的小型AES实现执行解密。我们在EL2中只包含两个小而足够的密码库，以保持TCB小。这限制了加密算法的数量，但避免包含全面但过于庞大的加密库，比如OpenSSL。催眠利用AES来支持加密的VM迁移和快照，并确保只有加密的VM数据暴露给主机监控程序。

通过使用虚拟机扩展(VMX)[35]和IOMMU，也可以在Intel的x86架构上满足其硬件需求。可以对现有的x86虚拟机监控程序进行改造，以在VMX根操作中运行corevisor，这允许控制虚拟化特性，取消主机监控的特权。主机监控程序在VMX非根操作中运行，以提供资源管理和虚拟I/O。corevisor通过管理虚拟机控制结构(VMCS)perCPU保护VM执行状态，通过使用扩展页表(EPT)和控制IOMMU保护vm memory。

### 5 Security Analysis

1. 在系统的生命周期中，安全顾问的协作者是值得信任的，可以对抗远程攻击者。

2. 催眠确保只有受信任的VM映像可以在VM上引导。

3. 催眠隔离一个给定VM的内存从所有其他VM和主机监控程序。

4. 它保护给定VM的CPU寄存器不受主机监控程序和所有其他VM的影响。

5. 假设虚拟机采用端到端的方法来保护I/O，那么它可以保护给定虚拟机I/O数据对主机监控程序和所有其他虚拟机的机密性。

6. 假设VM采用端到端的方法来保护I/O，并且可以在永久修改VM的I/O数据之前对I/O数据进行验证，那么在主机监控程序和所有其他VM上保护给定VM的I/O数据的机密性和完整性。

7. 假设VM采用端到端的方法来保护其I/O，那么，在远程攻击者(包括攻击者危及任何其他VM或主机监控程序本身的情况下)面前，可以保护VM所有数据的机密性。

8. 假设一个VM需要端到端的方法来保护它的I / O和I / O可以验证之前,永久地修改任何虚拟机数据,HypSec保护的完整性的所有虚拟机的数据对远程攻击者,包括如果攻击者妥协任何其他VM或hostvisor本身。

9. 如果虚拟机监控程序是良性的，并且负责处理I/O，则可以保护所有VM数据的机密性和完整性，不受其他VM的损害。

### 8 Conclusions

我们创建了一种新的hypervisor设计方法，可以减少保护虚拟机所需的TCB。它将一个独立的虚拟机监控程序分解为一个小的、受信任的协作者和不受信任的主机监控程序，后者包含绝大多数虚拟机监控程序功能，包括整个主机操作系统内核。corevisor利用硬件虚拟化支持在更高的特权级别上执行，并提供访问控制机制来限制主机监控程序对VM数据的访问。它可以很简单，因为它只需要执行基本的CPU和内存虚拟化。当VM使用安全的I/O通道时，可以保护所有VM数据的机密性和完整性。我们已经演示了通过改造KVM/ARM，可以支持现有的商品管理程序。得到的TCB比最初的KVM/ARM小一个数量级。对于真实的应用程序工作负载，只需适度的性能开销，就可以为虚拟机提供强大的安全保证。









应用场景，具体怎么用，可以用到哪个领域，方法是什么，

