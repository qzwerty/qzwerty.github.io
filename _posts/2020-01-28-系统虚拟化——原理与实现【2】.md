---
layout:     post
title:      系统虚拟化 
subtitle:   原理与实现【2】
date:       2020-01-28
author:     qzwerty
header-img: img/book.png
catalog: true
tags:
    - virtualization
---

## 第二章 x86 架构及操作系统概述
### 2.1 x86 的历史和操作系统概要
#### 2.1.1 x86 的历史
**8086处理器**拥有16位的寄存器和16位的外部数据总线，使用20位地址寻址（拥有1MB的地址空间）。**80286处理器**引入了保护模式的概念。**80386处理器**是x86体系结构下第一款32位处理器，并且引入了虚拟内存。**80486**采用了5级流水线机制，并且引入了片，一级缓存和能量管理。**奔腾处理器（Pentium）**进一步增大一级缓存，并将其分成指令缓存和数据缓存两个部分，进一步加快处理器对主存的访问时间。
**P6家族处理器**采用超标量（superscalar）技术，以乱序执行的方式进一步增强了处理器的处理速度。**奔腾4家族的处理器**基于NetBurst微处理结构，提升了性能，进一步增强了对多媒体处理的支持，引入了超线程（Hyper-Threading）的概念。在奔腾4的672和662处理器上，加入了虚拟化支持（Intel VT技术）。后来，处理器进入多核时代（Multicore）。
#### 2.1.2 操作系统概述
操作系统对下负责管理平台硬件，对上向应用程序提供标准接口。操作系统中最重要的部分称为操作系统内核，运行在CPU最高的特权级上，可以访问系统的一切资源。操作系统内核运行的状态为**内核态**。应用程序通常运行在CPU最低的特权级上，只能访问部分资源，称为**用户态**。

操作系统利用平台架构提供的各种功能，使用硬件资源，其实现和平台架构紧密相关。
### 2.2 x86 内存架构
#### 2.2.1 地址空间
	如果把内存（这里指安插在主板上的RAM）比作一个大数组，地址就是这个数组的索引。
	地址空间则是一个更大的数组，它是所有可用资源的集合，同样，地址是这个数组的索引。

*1. 物理地址空间*

硬件平台可以粗略划分为三个部分：CPU，内存和其他硬件设备。从CPU的角度看，内存和其他硬件设备都是可以使用的资源。这些资源组合在一起，分布在CPU的物理地址空间内。CPU通过物理地址索引这些资源。物理地址空间的大小，由CPU实现的物理地址位数决定。
![](https://tva1.sinaimg.cn/large/006tNbRwgy1gbcd0b5ou9j30gs0k6jv6.jpg)

*2. 线性地址空间*

每个程序都认为自己独享整个平台的硬件资源。引入线性地址让多个程序能够有效地相互隔离和使用物理地址空间的资源。
	
	线性地址空间的大小与物理地址空间的大小没有必然联系，
	物理地址空间的大小与CPU处理数据的能力（即CPU位数）无关。

线性地址空间会被映射到物理地址空间某一部分或整个物理地址空间，CPU负责将线性地址转换成物理地址，使程序能够正常访问到该线性地址空间所映射到的物理地址空间。一个平台上可以有多个地址空间。在现代操作系统中，每个进程通常都拥有自己的私有地址空间。

#### 2.2.2 地址
可分为**线性地址**和**物理地址**。但由于x86特殊的段机制，还有一种额外地址——**逻辑地址**。x86架构无法禁用段机制，逻辑地址一直存在。

*1. 逻辑地址*
是程序直接使用的地址。逻辑地址由一个16位的段选择符号一个32位的偏移量（32位平台）构成。

*2 线性地址*
又称*虚拟地址*。是逻辑地址转换后的结果，用于索引线性地址空间。
	
	当CPU使用分页机制时，线性地址必须转换为物理地址才能访问平台内存或硬件设备；
	当分页机制未启用时，线性地址等于物理地址。

*3. 物理地址*
索引物理地址空间。是CPU提交到总线用于访问平台内存和硬件设备的最终地址。

另外还有总线地址的说法。在x86下有时也称物理地址为总线地址。

#### 2.2.3 x86 内存管理机制
*1. 分段机制*

将内存划分为以起始地址（Base）和长度（limit）描述的块（即段）。

	程序可以简单分为代码段、数据段和栈，段机制中就有对应的代码段、数据段和栈段。

分段机制由4个基本部分构成：**逻辑地址**、**段选择寄存器**、**段描述符**和**段描述符表**。**核心思想**：使用**段描述符**描述短的基地址、长度以及各种属性（例如读写属性、访问权限）。当程序使用**逻辑地址**访问内存的某个部分时，CPU通过逻辑地址中的**段选择符**索引**段描述符表**以得到该内存对应的**段描述符**，并检测程序的访问是否合法。如合法，根据段描述符中的基地址将逻辑地址转换为线性地址。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gbceaxcnxmj30vc0l8wjb.jpg)

*(1) 段选择符（segment selector）*

共16位。
![](https://tva1.sinaimg.cn/large/006tNbRwgy1gbceq6cmtvj30fo0ao40m.jpg)

* Index：段描述符表的索引。
* TI：用于指明索引哪个段描述符表。0为GDT，全局描述符表；1为LDT，本地描述符表。
* RPL：权限级别。

段选择符对程序是可见的。但通常段描述符的修改和分配由连接器和加载器完成。
	
	x86架构提供了6个段寄存器（segment register）用于存放当前程序的各个段的段选择符。
	*CS（code-segment，代码段）：存放代码段的段选择符。
	*DS（data-segment，数据段）：存放数据段的段选择符。
	*SS（stack-segment，栈段）：存放栈的段选择符。
	*ES、FS、GS：供程序自由使用。
	
*(2) 段描述符（Segment Descriptor）*
![](https://tva1.sinaimg.cn/large/006tNbRwgy1gbcf2dv4woj30vw0nsn55.jpg)

Base字段描述了该断的基地址，Limit字段描述了该段的长度。当CPU通过一个逻辑地址的段选择符获得该段对应的段描述符后，会使用描述符中各种属性字段对访问进行检查，一旦访问被确认合法，CPU将段描述符中的32位基地址和逻辑地址中的32位偏移量相加以获得该逻辑地址对应的线性地址。

为加速段描述符的访问，x86在段寄存器后增加了一个程序不可见的段描述符寄存器。

*(3)段描述符表*

**全局段描述符表（Global Descriptor Table，GDT）**
系统中至少有一个GDT可以被所有进程访问。GDT仅仅是内存中的一个数据结构，可以看作一个数组，由Base和Limit描述。

**本地段描述符表（Local Descriptor Table，LDT）**
系统中可以有一个或多个LDT，可以被某进程私有，也可以被多个进程共享。LDT是一个段，需要一个段描述符来描述它。

LDT的段描述符存放在GDT中，当系统中有多个LDT时GDT中必须有对应数量的段描述符。

x86提供GDTR寄存器和LDTR寄存器，以加速对GDT和LDT的访问。
**GDTR**：包括一个32位的基地址（BASE）和一个16位长度（LIMIT）。
**LDTR**：结构同段寄存器（包括对程序不可见的段描述符寄存器）。

可以使用LGDT/SGDT指令对GDTR进行读取/存储。LDT同。通常在进程切换时，LDTR中的值会被换成新进程对应的LDT的段描述符。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gbcfp1274sj30pe0py43h.jpg)

*(4)逻辑地址转换总结*

假设程序中某条语句访问了数据段，例如：

```
int a = 100 //全局变量
int func()
{
    int b;
    b = a;
}
```
程序从加载到变量a的逻辑地址转换为线性地址的过程：

**(1)程序加载。**

1) 通过该进程LDT的段选择符索引GDT，获得LDT的段描述符，被加载到LDTR寄存器中。

2）该进程的CS、DS、SS被加载入相应的段选择符。同时，CPU根据段选择符的TI字段索引GDT/LDT，获得相应的段描述符并加载入CS、DS、SS对应的不可见的段描述符寄存器。

(2)程序执行到b=a，需要从a所在的内存中取值，必须**把a的逻辑地址转换为线性地址**。
1)进行必要的属性、访问权限检查。
2)从DS对应的段描述符寄存器获得该段的基地址。
3)将a的32位偏移量和描述符中的基地址相加得a的线性地址。

*2. 分页机制*
这里只介绍最经典的4KB页面管理机制。分页机制通过页表将线性地址转换为物理地址，并配合旁路转换缓冲区（Translation Lookaside Buffer，TLB）来加速地址转换过程。操作系统在启动过程中，通过将CR0寄存器中的PG位置1来启动分页机制。
![](https://tva1.sinaimg.cn/large/006tNbRwgy1gbcgciwzn1j30qm0jigq3.jpg)

如图，分页机制主要由**页表**、**CR3寄存器**和**TLB**三个部件构成。

*(1)页表（Page Table）*

**页帧号（或页框架）**：一个地址对齐到页边界后的值，实际是该地址所在页面的基地址。页表是存储VFN到PFN映射的数据结构。4KB大小的页面使用两级页表。

	虚拟页帧号（Virtual Frame Number，VFN）：线性地址对应的页帧号。
	物理页帧号（Physical Frame Number，PFN），或机器页帧号（Machine Frame Number，MFN）：物理地址对应的页帧号。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gbcglx6170j30si0lejwl.jpg)


**页目录项（Page Directory Entry）**：如下图。包含页表的物理地址。存放在页目录（Page Directory）中。CPU使用线性地址的22～31位索引页目录，以获得该线性地址对应的页目录项。每个页目录项大小为4
B，页目录占用一个4KB大小的物理页面，包含1024的页目录项。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gbcgu0tfo4j30x80jcwlq.jpg)

**页表项（Page Table Entry）**：包含该线性地址对应的PFN。存放在页表（Page Table）中，CPU使用线性地址的12～21位索引页表，获得该线性地址对应的页表项。通过将线性地址的0～11位偏移量和基地址相加，可以得到线性地址对应的物理地址。页表占用一个4KB页面。
![](https://tva1.sinaimg.cn/large/006tNbRwgy1gbch0sv4vdj30xc0kqqal.jpg)

	对于页目录项和页表项的P字段，该字段使得虚拟内存的实现成为可能。
	P = 1：物理页面存在于物理内存中，CPU完成地址转换后，可以直接访问该页面。
	P = 0：页面不在物理内存中。	

P = 0的情况：当CPU访问该页面时会产生一个缺页错误（Page Fault）并交由操作系统的缺页错误处理程序处理。通常操作系统会将存放在磁盘上的页面调入物理内存，使访问可以继续。此时页目录项、页表项格式变为下图。此时1～31位供操作系统使用以记录物理页面在磁盘上的信息，通常是物理页面在磁盘上的位置。
![](https://tva1.sinaimg.cn/large/006tNbRwgy1gbch9ass0xj30xk05cdhn.jpg)

*(2)CR3寄存器*

也称为页目录基地址寄存器（Page-directory base register，PDBR）。CPU在索引页目录之前，必须知道页目录所在的物理地址，该物理地址存放在CR3上。一个进程在运行之前，必须将其页目录基地址存入CR3。页目录基地址必须对齐到4K边界。

*(3)TLB*
x86对最近用到的页面映射进行缓存，当CPU访问某个线性地址，其所在页面映射存在于TLB中时，无需查找页表即可进行地址转换。TLB存放VFN到PFN的转换。也就是说，CPU从TLB获得一个线性地址对应的PFN后，还要与线性地址偏移相加才能得到物理地址。

TLB中的映射条目和页表中的映射条目的一致性问题：当操作系统对页表进行修改后，要负责对TLB中对应的条目或整个TLB进行刷新。

	x86提供的两种刷新TLB的方法：
	1）更新CR3：导致TLB整体刷新。
	2）INVLPG指令：对TLB中单独的页目录项、页表性进行刷新。

*(4)总结线性地址转换成物理地址*

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gbchw7mbbtj319s0iyqht.jpg)

### 2.3 x86 架构的基本运行环境
#### 2.3.1 三种基本模式
x86有4种运行模式：

(1) **实模式（Real Mode）**：当CPU加电并经历最初的混沌状态后，首先进入的就是实模式，是早期Intel 8086 处理器工作的模式。在该模式下，逻辑地址转换后即为物理地址，CPU可以访问1MB的物理地址空间（实际是1MB+64KB）。操作系统或BIOS通常在该模式下准备必要的数据结构和初始化关键的寄存器，然后切换入保护模式。

(2) **保护模式（Protect Mode）**：常用模式。在该模式下CPU的所有功能几乎都能得到使用，可以访问架构允许的所有物理空间（如x86是4GB）。

(3) **虚拟8086模式（Virtual 8086 mode）**：可以让CPU在保护模式下为8086程序虚拟实模式的运行环境。

(4) **SMM模式**

### 2.3.2 基本寄存器组
x86架构的寄存器：

**通用寄存器**：共有8个32位的通用寄存器，如EAX、EDX等，用来保存程序运行时的临时变量、栈指针等数据。

**内存管理寄存器**：包括段寄存器和描述符表寄存器。

**EFLAGS寄存器**：保存程序运行中的一些标志位信息，如溢出、开启中断与否、分支跳转等信息。

**EIP寄存器**：用来保存指向当前指令的地址，该寄存器也被称为PC指针。

**浮点运算寄存器**：提供浮点运算的基本环境。

**控制寄存器**：5个，CR0～CR4寄存器。决定CPU运行的模式和特征等。

其他寄存器：8个**调试寄存器**（DR0～DR7），**内存区域类型寄存器（MTRR）**、**机器检查寄存器（Machine Check Registers）**以及性能监控寄存器。

### 2.3.3 权限控制

CPU对资源进行分类，使不同权限的程序只能访问自身权限所允许访问的资源。

x86架构提供两种权限控制机制：

*1. 段保护*

(1)**当前权限级别（Current Privilege Level，CPL）**：当前运行的代码的权限。CS的0、1位记录代码的CPL值。即Ring 0～3。CPL值越高权限越低。

(2) **描述符权限级别（Descriptor Privilege Level，DPL）**：表示段和门（Gate）所具有的权限。表示代码访问某个段或者通过某个门时所需要的最低权限。若某个数据段DPL=2，则只有CPL=0、1、2的代码可以访问该数据段，CPL=3的不能访问。

(3) **所要求权限级别（Requested Privilege Level，RPL）**：存在于段寄存器的0～1位，用于程序在访问段时增加一级检查。

只有当CPL<=DPL且RPL<=DPL时，访问才被允许。

*2. 页保护*
在页目录项、页表项中引入一个User/Supervisor位，将页面分成这两个特权级。该位为0时表示Supervisor模式，对应CPL=0，1，2的情况，为1表示User模式，对应CPL=3的情况。

### 2.4 中断与异常
#### 2.4.1 中断架构
中断从设备发送到CPU需要由被称为“**中断控制器**”的部件转发。包括PIC和APIC。

*1. PIC（Programmable Interrupt Controller，可编程中断控制器）*

就是8259A芯片。只能在UP（单处理器平台）工作。有一个EOI位，当CPU处理完一个中断时，通过写该位告知PIC中断处理完成。

*2.APIC*

可在MP（多处理器）平台工作。由位于CPU中的本地高级可编程中断控制器（LAPIC）和位于主板南桥中I/O高级可编程中断控制器（IOAPIC）两部分构成。
![](https://tva1.sinaimg.cn/large/006tNbRwgy1gbdlfatg4nj30mq0hq0vl.jpg)

*3. 处理器间中断（Inter-processor Interrupt，IPI）*

提供CPU之间相互通信的手段。操作系统通常使用IPI完成诸如进程转移、中断平衡和TLB刷新等工作。

*4. 中断的概念*

1) 分类

	从中断源的角度看，可以分为：
	*外部中断：指连接在IOAPIC上设备产生的中断、LAPIC上连接的设备或LAPIC内部中断源产生的中断以及处理器间的中断。
	*可屏蔽中断：可通过某种方式（如CLI指令、TPR寄存器、PIC/IOAPIC的中断屏蔽位）进行屏蔽的中断。还有不可屏蔽中断。
	*软件产生中断：通过INT n指令产生。

	根据外部中断的触发方式，可分为：
	*edge触发中断
	*level触发中断
	
2) 优先级
PIC中管脚决定，连接IR0的设备具有最高优先级。APIC中，由设备所连接管脚对应的RTE中的vector字段决定。越大优先级越高。

3) 中断屏蔽

4）IDT表

用于存放各种门。当中断或者异常发生时，CPU用他们对应的vector号索引IDT表以获得对应的门。IDT表的基地址存放在IDTR寄存器中。

5) 中断门

实际上是系统描述符（System Descriptor），由段描述符的S位控制。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gbdm9hakx4j31260f8ad3.jpg)

#### 2.4.2 异常
在程序执行的过程中同步发生。分为**错误（Fault）**、**陷阱（Trap）**、**终止（Abort）**