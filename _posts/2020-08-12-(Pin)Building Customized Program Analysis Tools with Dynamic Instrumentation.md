---
layout:     post
title:      (Pin)Building Customized Program Analysis Tools with Dynamic Instrumentation
subtitle:   (PLDI’05)
date:       2020-08-12
author:     qzwerty
header-img: img/blog-bj-1.png
catalog: true
tags:
    - security analysis



---

## (Pin)Building Customized Program Analysis Tools with Dynamic Instrumentation

健壮而强大的软件仪表工具对于程序分析任务(如概要分析、性能评估和bug检测)是必不可少的。为了满足这一需求，我们开发了一种新的插装系统，称为Pin。我们的目标是提供易用、便携、透明和高效的工具。插装工具Pintools是利用Pin丰富的API用C/ c++编写的。Pin遵循ATOM模型，允许工具作者在指令层上分析应用程序，而不需要详细了解底层指令集。该API被设计为尽可能独立于架构，使Pintools源代码能够兼容不同架构。但是，Pintool可以在必要时访问特定于体系结构的细节。由于应用程序和Pintool可以观察应用程序原始的、未插装的行为，使用Pin进行检测基本上是透明的。Pin使用动态编译来对正在运行的可执行程序进行插装。为了提高效率，Pin使用了几种技术，包括内联、寄存器重新分配、活性分析和指令调度来优化仪表。这种完全自动化的方法提供了比类似工具更好的仪器性能。例如，对于基本块计数，Pin比Valgrind快3.3倍，比DynamoRIO快2倍。为了说明Pin的通用性，我们描述了两个用于分析生产软件的日常使用的Pin工具。Pin可以在以下四种架构上的Linux平台上公开使用:IA32(32位x86)、EM64T(64位x86)、Itanium R和ARM。自从2004年7月《Pin 2》发布以来的10个月里，其网站的下载量已经超过了3000次。

Keywords Instrumentation, program analysis tools, dynamic compilation

### 1 Introduction

随着软件复杂性的增加，插装——一种向应用程序中插入额外代码以观察其行为的技术——变得越来越重要。插装可以在不同的阶段执行:在源代码中、编译时、发布链接时或运行时。Pin是一个对Linux应用程序执行运行时二进制插装的软件系统。

Pin的目标是提供一个插装平台，用于为多种架构构建各种程序分析工具。因此，设计强调易用性、可移植性、透明性、效率和健壮性。本文描述了Pin的设计，并说明了它是如何提供这些特性的。

Pin的插装使用方便。它的用户模型与流行的ATOM [30] API类似，后者允许工具在可执行文件中的任意位置插入对插装的调用。用户不需要手动内联指令或保存和恢复状态。Pin提供了丰富的API，抽象出了底层指令集的特性，使编写可移植的插装工具成为可能。Pin包括许多独立于架构的示例Pintools，包括分析器、缓存模拟器、跟踪分析器和内存bug检查器。API还允许访问特定于体系结构的信息。

Pin使用just-in-time(JIT)编译器来插入和优化代码，从而提供了有效的插装。除了用于动态插装系统的一些标准技术(包括代码缓存和跟踪链接)之外，Pin还实现了寄存器重新分配、内联、活性分析和指令调度，以优化jitted code.。这种完全自动化的方法将Pin与其他大多数需要用户帮助来提高性能的插装工具区别开来。例如，Valgrind[22]依赖于工具编写者在它们的中间表示中插入特殊的操作来执行内联;类似地，DynamoRIO[6]要求工具编写者手动内联和保存/恢复应用程序寄存器。

另一个使Pin有效的特性是进程附加和分离。与调试器一样，Pin可以附加到进程，对其进行插装，收集配置文件，并最终分离。应用程序只在附加Pin期间引入插装开销。对于长时间运行的大型应用程序来说，附加和分离的能力是必需的。

Pin基于jit的插装将代码发现延迟到运行时，这使得Pin比使用静态插装或代码补丁的系统更加健壮。Pin可以无缝地处理混合代码和数据、可变长度的指令、静态未知的间接跳转目标、动态加载的库和动态生成的代码。

Pin通过提供插装透明性来保留原始的应用程序行为。应用程序观察到与在非检测执行中相同的地址(指令和数据)和相同的值(寄存器和内存)。透明性使得插装收集的信息更加相关，而且对于正确性也是必要的。例如，一些应用程序无意中访问堆栈顶部以外的数据，因此Pin和插装不会修改应用程序堆栈。

Pin’s ﬁrst generation, Pin 0, supports Itanium R . The recentlyreleased second generation, Pin 2, extends the support to four1  architectures: IA32 (32-bit x86) [14], EM64T (64-bit x86) [15], Itanium R [13], and ARM [16]. Pin 2 for Itanium R is still under development.

自从2004年7月第一次发布Pin 2以来，已经有超过3000次的下载量，Pin 2在Intel内外都受到了欢迎。本文对Pin进行了深入的描述，组织如下。我们首先在第2节中概述了Pin的插装功能。接下来，我们将在第3节中讨论设计和实现问题。然后我们在第4节评估了Pin的插装性能，并将其与其他工具进行比较。在第5节中，我们将讨论在实践中使用的两个Pintools示例。最后，我们将Pin与第6节中的其他工作联系起来，并在第7节中结论。

### 2 Instrumentation with Pin

Pin API使观察进程的所有体系结构状态成为可能，比如寄存器、内存和控制流的内容。它使用类似于ATOM[30]的模型，其中用户将过程(在ATOM的概念中称为分析例程)添加到应用程序进程中，并编写插装例程来确定在何处调用分析例程。分析例程的参数可以是架构状态或常量。通过允许分析例程覆盖应用程序寄存器和应用程序内存，Pin还提供了改变程序行为的有限能力。

插装由即时(JIT)编译器执行。但是，该编译器的输入不是字节码，而是本机可执行文件。Pin拦截可执行程序的第一个指令的执行，并为从这个指令开始的直线代码序列生成(“编译”)新的代码。然后它将控制权转移到生成的序列。生成的代码序列几乎与原始代码序列相同，但Pin确保在分支退出序列时重新获得控制权。在重新获得控制权后，Pin为分支目标生成更多代码并继续执行。每当JIT获取一些代码时，Pintool都有机会在编译之前对其进行检测。翻译后的代码及其插装保存在代码缓存中，以便将来执行相同的指令序列以提高性能。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghqlsmh5lxj30u00vh7d4.jpg)

在图1中，我们列出了用户为创建Pintool而编写的代码，该Pintool在程序中为每次 内存写入 输出 地址和大小 的跟踪。main函数对Pin进行初始化，注册Instruction函数，通知Pin开始执行程序。JIT在向代码缓存中插入新指令时调用Instruction函数，赋予它解码后指令的句柄。如果指令写入内存，Pintool会在指令前插入一个RecordMemWrite调用，（即IPOINT_BEFORE to INS_InstertPredicatedCall），传递指令指针（即IARG_INST_PTR），内存操作的有效地址（IARG_MEMORYWRITE_EA）和写入的字节数（IARG_MEMORYWRITE_SIZE）。使用INS_InstertPredicatedCall保证了仅当内存指令被断言为true时才调用RecordMemWrite。

注意，相同的源代码适用于所有架构。用户不需要知道Itanium捆绑的指令,每个体系结构上的各种寻址模式,Itanium和ARM支持的不同形式的预测,可以编写一个适应内存区域的x86字符串指令,或者类似push这样可以隐式地写内存的x86指令。

Pin为检测和插装提供了一个全面的API。在这个特定的示例中，插装操作一次只执行一条指令。在进行插装时，也可以检查整个跟踪、程序和映像。Pin用户手册[12]提供了API的完整描述。

Pin的基于调用的模型比其他工具更简单，用户可以通过添加和删除中间语言中的语句来插入插装。然而，它在观察体系结构状态方面同样强大，它使用户不必理解指令集的特性或学习中间语言。所插入的代码可以覆盖划痕寄存器或条件代码;Pin有效地保存和恢复调用前后的状态，因此这些副作用不会改变原始的应用程序行为。不管指令集是RISC、CISC还是VLIW, Pin模型使得编写高效且与体系结构无关的工具成为可能。内联、注册重新分配和其他优化的组合使得Pin的基于过程调用的模型与更底层的插装模型一样有效。

### 3 Design and Implementation

在本节中，我们从Pin的系统概述开始。然后，我们将讨论Pin最初如何获得对应用程序的控制权，然后详细描述Pin如何动态编译应用程序。最后，我们讨论了Pin源代码的组织。

#### 3.1 System Overview

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghqmsgqn40j310a0rc782.jpg)

图2说明了Pin的软件架构。在最高级别上，Pin由虚拟机(VM)、代码缓存和Pintools调用的插装API组成。VM由一个即时编译器(JIT)、一个仿真器emulator和一个分派器dispatcher组成。Pin获得应用程序的控制权后，VM协调其组件来执行应用程序。JIT编译和检测应用程序代码，然后由dispatcher启动这些代码。编译后的代码存储在代码缓存中。进入/离开虚拟机从/到代码缓存涉及到保存和恢复应用程序寄存器状态。仿真器解释不能直接执行的指令。它用于需要从VM进行特殊处理的系统调用。由于Pin位于操作系统之上，它只能捕获用户级别的代码。

如图2所示，当一个插装程序运行时，会出现三个二进制程序:应用程序、Pin和Pintool。Pin是对应用程序进行jit和插装的引擎。Pintool包含插装和分析例程，并与一个库连接，这个库允许它与Pin通信。他们共享相同的地址空间,但不共享任何库,所以通常有三份`glibc`的副本。通过使所有库私有，我们可以避免Pin、Pintool和应用程序之间不必要的交互。一个交互问题的例子是当应用程序执行一个不可重入的`glibc`函数。如果应用程序开始执行这个函数,然后试图执行一些代码触发进一步编译,它将进入JIT。如果JIT执行相同的`glibc`函数,它将再次进入相同的程序，而此时在应用程序仍在运行它,导致一个错误。而本方案中每个组件都有单独的`glibc`副本，所以Pin和应用程序不会共享任何数据，也不会有重入问题。同样的问题也发生当我们对Pintool中调用`glibc`的分析代码进行jit时(jit分析程序允许我们大大减少在Itanium中简单插装的开销)。

#### 3.2 Injecting Pin

注入器将Pin加载到应用程序的地址空间中。注入过程使用Unix Ptrace API获得对应用程序的控制并捕获处理器上下文。它将Pin二进制文件加载到应用程序地址空间并开始运行。在初始化自己之后，Pin将Pintool加载到地址空间并开始运行。Pintool初始化自己，然后请求Pin启动应用程序。Pin创建初始上下文并在入口点(或者在附加的情况下在当前PC)开始对应用程序进行jitting。使用Ptrace作为注入机制允许我们以与调试器相同的方式附加到已经运行的进程。还可以从插装的进程中分离并继续执行原始的、未插装的代码。

其他工具,如DynamoRIO[6]依靠LD_PRELOAD环境变量,迫使动态加载程序加载地址空间的共享库。首先LD_PRELOAD不使用静态链接的二进制文件,而他是我们的许多用户需要。其次，与非插装执行相比，加载额外的共享库将把所有应用程序共享库和一些动态分配的内存转移到更高的地址。我们试图尽可能地保存原始的行为。第三，在共享库加载程序部分执行之后，插装工具才能获得对应用程序的控制，而我们的方法能够插装程序中的第一条指令。这个功能实际上暴露了Linux共享库加载器中的一个bug，这个bug是由引用堆栈上未初始化的数据引起的。

#### 3.3 The JIT Compiler

##### 3.3.1 Basics

Pin直接从一个ISA编译成相同的ISA(例如，IA32到IA32, ARM到ARM)而不经过中间格式，编译后的代码存储在基于软件的代码缓存中。只执行驻留在代码缓存中的代码—不会执行原始代码。一次编译一个应用程序的一个跟踪。一个跟踪是一个直线的指令序列，它终止于以下条件之一:(i)一个无条件的控制转移(分支，呼叫，或返回)，(ii)一个预定义数量的条件控制转移，或(iii)一个预定义的指令数量已经在跟踪中被获取。除了最后一个出口之外，跟踪还可以有多个旁路出口(条件控制传输)。每个出口最初都分支到一个stub，该stub将控制重定向到VM。VM确定目标地址(对于间接控制传输来说，目标地址是静态未知的)，如果之前没有生成过该目标，则为该目标生成新的跟踪，并在目标跟踪处继续执行。

在本节的其余部分中，我们将讨论JIT的以下特性:跟踪链接、注册重新分配和插装优化。我们目前的性能工作主要集中在IA32、EM64T和Itanium上，它们实现了所有这些特性。虽然ARM版本的Pin是完全功能，一些优化还没有实现。

##### 3.3.2 Trace Linking

为了提高性能，Pin尝试直接从跟踪出口分支到目标跟踪，绕过stub和VM。我们称这个过程为跟踪链接。链接一个直接控制转移是直接的，因为它有一个唯一的目标。我们只需在一个跟踪结束时对分支进行补丁，以跳转到目标跟踪。但是，间接控制传输(跳转、调用或返回)具有多个可能的目标，因此需要某种目标预测机制。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghrruudol4j30ok12o43s.jpg)

图3(a)展示了我们在x86体系结构上实现的间接链接方法。Pin将间接跳转换为一个move和一个直接跳转。move指令把间接跳转的目标地址放入寄存器%edx（图3(a)中的%edx和%ecx，%esi通过寄存器重新分配获取，见Section 3.3.3）。直接跳转跳转到预测的第一个目标地址0x40001000（在这个例子中被影射到代码缓存中的0x70001000）。我们通过lea/jecxz（DynamoRIO中用的）来对比%edx和0x40001000，避免了修改eflags。如果预测结果正确（即%ecx=0），我们就跳转到match1来执行预测目标的剩下的代码。如果错了，我们就尝试另一个目标0x40002000（映射到代码缓存中的0x70002000）。如果没找到目标，就跳转到LookupHtab_1，在哈希表中找目标（本例中基地址0x30898200）。如果查找成功，我们就会根据目标跳转到转换的地址。如果查找失败，我们会转换到vm来进行间接目标处理。

虽然我们的间接链接机制类似于DynamoRIO[6]中采用的方法，但有三个重要的区别。首先，在DynamoRIO中，整个链是一次性产生的，并嵌入在间接跳转的翻译处。因此，在链生成之后，不能将新的预测目标添加到链上。相比之下，我们的方法是在程序运行时逐步构建链，因此我们可以以任何顺序将新看到的目标插入链中(例如，Pin可以将新目标放在链的前端或末端)。下次出现这些新目标时，可以在链中找到它们，而无需搜索哈希表。第二个不同之处在于，DynamoRIO为所有间接跳转使用一个全局哈希表，而Pin为每个间接跳转使用一个本地哈希表。Kim和Smith[17]的一项研究表明，本地哈希表方法通常提供更高的性能。第三个不同之处是，我们应用函数克隆[10]来加速最常见的间接控制转移形式:返回。如果从多个站点调用一个函数，则克隆该函数的多个副本，每个副本对应一个调用站点。因此，在大多数情况下，每个克隆中的返回在链上只有一个预测的目标，如图3(b)中的示例所示。为了实现克隆，我们将调用堆栈与每个跟踪关联起来(更准确地说，关联到每个跟踪的静态上下文，我们将在3.3.3节中讨论)。每个调用堆栈记住最后四个调用站点，并通过将调用站点地址散列成一个64位整数紧凑地表示。

#### 3.3.3 Register Re-allocation

在jitting期间，我们经常需要额外的寄存器。例如，图3(a)中用于解决间接分支的代码需要三个空闲寄存器。当插装将调用插入应用程序时，JIT必须确保调用不会覆盖应用程序可能正在使用的任何刮擦寄存器。使用线性扫描寄存器分配[24]，Pin重新分配应用程序和Pintool中使用的寄存器，而不是以特殊的方式获得额外的寄存器。Pin的分配器是唯一的，因为它执行过程间分配，但是必须一次编译一个跟踪，同时在执行期间逐步发现流图。相比之下，静态编译器一次只能编译一个文件，字节码jit[5,8]一次可以编译整个方法。我们描述了基于跟踪的寄存器重新分配方案必须解决的两个问题:寄存器活性分析和寄存器绑定的协调。

**Register Liveness Analysis**

寄存器在跟踪出口的精确活性信息使寄存器分配更加有效，因为死寄存器可以通过引脚重用而不会导致溢出。没有一个完整的流程图，我们必须逐步计算活性。在编译了地址¥处的跟踪之后，我们使用地址¥作为键在哈希表中记录跟踪开始处的活跃度。如果跟踪出口有一个静态已知的目标，我们尝试从哈希表检索活动信息，这样我们就可以为当前跟踪计算更精确的活动。这个简单的方法引入了可忽略的空间和时间开销，但在减少由Pin的寄存器分配引入的寄存器溢出方面是有效的。

**Reconciliation of Register Bindings**











![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu4tj8guuj30i80xkjvo.jpg)









![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu4u7zaz1j30ic09yabm.jpg)









![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu4ux51k9j30hy0autag.jpg)







![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu51mih3aj30u00uxgub.jpg)





![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu52anhvhj311s0diq5u.jpg)





![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu5301ll2j30j60vqtd2.jpg)







![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu53hmypqj30ii0nkjuy.jpg)



![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu53yleqcj30ii0hkgot.jpg)



